{
    "image": "free5gc/base",
    "unapproved": [
        "CVE-2022-1304",
        "CVE-2023-4039",
        "CVE-2023-4016",
        "CVE-2022-4450",
        "CVE-2023-5678",
        "CVE-2022-4304",
        "CVE-2010-0928",
        "CVE-2023-3446",
        "CVE-2023-3817",
        "CVE-2007-6755",
        "CVE-2023-0286",
        "CVE-2023-0465",
        "CVE-2023-2650",
        "CVE-2024-0727",
        "CVE-2023-0215",
        "CVE-2022-2097",
        "CVE-2023-0466",
        "CVE-2023-0464",
        "CVE-2023-4039",
        "CVE-2020-22218",
        "CVE-2013-0340",
        "CVE-2023-52425",
        "CVE-2024-28757",
        "CVE-2023-52426",
        "CVE-2023-7104",
        "CVE-2021-36690",
        "CVE-2021-31239",
        "CVE-2022-35737",
        "CVE-2021-45346",
        "CVE-2021-33560",
        "CVE-2018-6829",
        "CVE-2024-2236",
        "CVE-2011-4116",
        "CVE-2023-31486",
        "CVE-2023-47038",
        "CVE-2023-31484",
        "CVE-2020-16156",
        "CVE-2022-47673",
        "CVE-2018-20673",
        "CVE-2019-1010204",
        "CVE-2022-44840",
        "CVE-2021-3549",
        "CVE-2018-20712",
        "CVE-2021-45078",
        "CVE-2023-25586",
        "CVE-2018-9996",
        "CVE-2021-20284",
        "CVE-2022-47695",
        "CVE-2022-47696",
        "CVE-2022-47010",
        "CVE-2021-32256",
        "CVE-2021-3826",
        "CVE-2022-47007",
        "CVE-2023-1972",
        "CVE-2022-47011",
        "CVE-2023-25585",
        "CVE-2022-48063",
        "CVE-2017-13716",
        "CVE-2023-1579",
        "CVE-2018-18483",
        "CVE-2022-47008",
        "CVE-2021-3530",
        "CVE-2022-35206",
        "CVE-2020-19726",
        "CVE-2022-45703",
        "CVE-2021-46174",
        "CVE-2022-4285",
        "CVE-2021-20197",
        "CVE-2023-25584",
        "CVE-2021-46195",
        "CVE-2020-35448",
        "CVE-2022-48065",
        "CVE-2022-48064",
        "CVE-2023-25588",
        "CVE-2022-35205",
        "CVE-2022-38533",
        "CVE-2023-29491",
        "CVE-2022-29458",
        "CVE-2023-45918",
        "CVE-2023-50495",
        "CVE-2018-1000021",
        "CVE-2023-22490",
        "CVE-2022-23521",
        "CVE-2023-25815",
        "CVE-2023-23946",
        "CVE-2023-29007",
        "CVE-2022-24765",
        "CVE-2022-39260",
        "CVE-2022-41903",
        "CVE-2023-25652",
        "CVE-2022-24975",
        "CVE-2022-39253",
        "CVE-2022-29187",
        "CVE-2022-25147",
        "CVE-2023-32006",
        "CVE-2023-32002",
        "CVE-2023-30589",
        "CVE-2023-32559",
        "CVE-2024-22025",
        "CVE-2023-30581",
        "CVE-2023-46809",
        "CVE-2023-30590",
        "CVE-2024-22019",
        "CVE-2022-3219",
        "CVE-2023-45853",
        "CVE-2023-45322",
        "CVE-2022-2309",
        "CVE-2023-39615",
        "CVE-2024-25062",
        "CVE-2016-3709",
        "CVE-2022-41409",
        "CVE-2022-24963",
        "CVE-2008-1688",
        "CVE-2008-1687",
        "CVE-2024-26458",
        "CVE-2024-26461",
        "CVE-2023-36054",
        "CVE-2018-5709",
        "CVE-2024-26462",
        "CVE-2024-26622",
        "CVE-2019-19378",
        "CVE-2023-1998",
        "CVE-2022-4129",
        "CVE-2023-6535",
        "CVE-2023-52491",
        "CVE-2023-52594",
        "CVE-2007-3719",
        "CVE-2022-3108",
        "CVE-2023-52340",
        "CVE-2024-21803",
        "CVE-2024-26601",
        "CVE-2023-52504",
        "CVE-2023-52477",
        "CVE-2024-24860",
        "CVE-2019-12382",
        "CVE-2023-0240",
        "CVE-2023-1073",
        "CVE-2023-52429",
        "CVE-2022-47929",
        "CVE-2022-4382",
        "CVE-2022-1247",
        "CVE-2023-6932",
        "CVE-2023-39189",
        "CVE-2023-4132",
        "CVE-2022-1280",
        "CVE-2023-3777",
        "CVE-2021-33631",
        "CVE-2023-31436",
        "CVE-2023-52524",
        "CVE-2022-4269",
        "CVE-2022-3344",
        "CVE-2019-12455",
        "CVE-2023-6040",
        "CVE-2023-1281",
        "CVE-2024-26629",
        "CVE-2023-35788",
        "CVE-2023-1855",
        "CVE-2023-52528",
        "CVE-2023-35001",
        "CVE-2023-21255",
        "CVE-2023-4194",
        "CVE-2022-48628",
        "CVE-2023-46343",
        "CVE-2022-2961",
        "CVE-2024-0564",
        "CVE-2022-45884",
        "CVE-2023-3358",
        "CVE-2023-52488",
        "CVE-2024-26598",
        "CVE-2022-3566",
        "CVE-2023-51780",
        "CVE-2023-52467",
        "CVE-2023-37454",
        "CVE-2023-52489",
        "CVE-2021-47028",
        "CVE-2022-2196",
        "CVE-2024-26627",
        "CVE-2023-23039",
        "CVE-2023-52444",
        "CVE-2023-3863",
        "CVE-2023-6240",
        "CVE-2021-39686",
        "CVE-2019-12378",
        "CVE-2023-3611",
        "CVE-2023-52515",
        "CVE-2023-3090",
        "CVE-2023-52569",
        "CVE-2023-52567",
        "CVE-2023-5178",
        "CVE-2023-0394",
        "CVE-2023-52597",
        "CVE-2023-0597",
        "CVE-2019-16231",
        "CVE-2023-52587",
        "CVE-2024-26614",
        "CVE-2023-51781",
        "CVE-2023-3567",
        "CVE-2022-44032",
        "CVE-2020-35501",
        "CVE-2022-3523",
        "CVE-2023-42754",
        "CVE-2023-23454",
        "CVE-2022-43945",
        "CVE-2023-3389",
        "CVE-2023-51782",
        "CVE-2023-52479",
        "CVE-2023-22998",
        "CVE-2023-6121",
        "CVE-2023-3212",
        "CVE-2023-3111",
        "CVE-2023-21400",
        "CVE-2023-4207",
        "CVE-2023-52612",
        "CVE-2023-52589",
        "CVE-2023-3776",
        "CVE-2024-24857",
        "CVE-2023-1206",
        "CVE-2021-4149",
        "CVE-2022-38457",
        "CVE-2021-3669",
        "CVE-2023-2163",
        "CVE-2023-2156",
        "CVE-2024-26595",
        "CVE-2023-3397",
        "CVE-2024-23851",
        "CVE-2023-52595",
        "CVE-2011-4915",
        "CVE-2023-23455",
        "CVE-2023-52507",
        "CVE-2023-45862",
        "CVE-2023-1074",
        "CVE-2023-6817",
        "CVE-2019-12380",
        "CVE-2023-52606",
        "CVE-2024-23196",
        "CVE-2023-52452",
        "CVE-2023-52516",
        "CVE-2019-12456",
        "CVE-2023-4622",
        "CVE-2024-25741",
        "CVE-2022-4379",
        "CVE-2023-46838",
        "CVE-2023-52609",
        "CVE-2024-0607",
        "CVE-2005-3660",
        "CVE-2023-4147",
        "CVE-2023-4244",
        "CVE-2023-3772",
        "CVE-2023-4010",
        "CVE-2024-1086",
        "CVE-2022-45934",
        "CVE-2023-28466",
        "CVE-2023-33288",
        "CVE-2023-39194",
        "CVE-2016-8660",
        "CVE-2023-34324",
        "CVE-2022-45885",
        "CVE-2024-24861",
        "CVE-2024-26585",
        "CVE-2023-51042",
        "CVE-2013-7445",
        "CVE-2023-3338",
        "CVE-2024-26641",
        "CVE-2019-15213",
        "CVE-2024-23850",
        "CVE-2023-52484",
        "CVE-2019-16089",
        "CVE-2014-9900",
        "CVE-2023-52498",
        "CVE-2023-52443",
        "CVE-2024-26600",
        "CVE-2023-52517",
        "CVE-2014-9892",
        "CVE-2024-22386",
        "CVE-2023-6915",
        "CVE-2023-40283",
        "CVE-2021-4204",
        "CVE-2023-52447",
        "CVE-2023-3610",
        "CVE-2023-2985",
        "CVE-2023-52591",
        "CVE-2024-26610",
        "CVE-2023-6270",
        "CVE-2023-52482",
        "CVE-2023-4208",
        "CVE-2023-34319",
        "CVE-2024-0565",
        "CVE-2023-3390",
        "CVE-2022-44033",
        "CVE-2022-41848",
        "CVE-2023-5717",
        "CVE-2023-52590",
        "CVE-2021-47094",
        "CVE-2024-0841",
        "CVE-2023-52572",
        "CVE-2023-52614",
        "CVE-2023-52600",
        "CVE-2023-28328",
        "CVE-2023-51043",
        "CVE-2011-4917",
        "CVE-2024-0775",
        "CVE-2008-2544",
        "CVE-2021-33061",
        "CVE-2023-52454",
        "CVE-2019-15794",
        "CVE-2019-19814",
        "CVE-2023-2166",
        "CVE-2024-26636",
        "CVE-2021-26934",
        "CVE-2024-26639",
        "CVE-2019-16233",
        "CVE-2021-3847",
        "CVE-2023-6610",
        "CVE-2024-26589",
        "CVE-2023-52575",
        "CVE-2023-20569",
        "CVE-2024-26640",
        "CVE-2020-12363",
        "CVE-2024-26581",
        "CVE-2022-40133",
        "CVE-2023-42753",
        "CVE-2023-52476",
        "CVE-2018-1121",
        "CVE-2015-2877",
        "CVE-2022-36280",
        "CVE-2023-6536",
        "CVE-2023-52531",
        "CVE-2023-52617",
        "CVE-2022-4696",
        "CVE-2023-52585",
        "CVE-2023-52445",
        "CVE-2023-31083",
        "CVE-2023-2124",
        "CVE-2023-52434",
        "CVE-2023-23586",
        "CVE-2024-25740",
        "CVE-2023-52469",
        "CVE-2023-52619",
        "CVE-2023-31248",
        "CVE-2023-52438",
        "CVE-2024-24858",
        "CVE-2022-40982",
        "CVE-2019-16234",
        "CVE-2023-1859",
        "CVE-2023-0179",
        "CVE-2023-3141",
        "CVE-2021-47070",
        "CVE-2023-52494",
        "CVE-2019-16230",
        "CVE-2024-26602",
        "CVE-2024-26607",
        "CVE-2023-52561",
        "CVE-2022-45919",
        "CVE-2023-1192",
        "CVE-2023-52457",
        "CVE-2024-26643",
        "CVE-2023-52503",
        "CVE-2023-1075",
        "CVE-2022-3567",
        "CVE-2023-52578",
        "CVE-2023-1078",
        "CVE-2023-52501",
        "CVE-2023-6531",
        "CVE-2023-5197",
        "CVE-2023-1611",
        "CVE-2022-25265",
        "CVE-2024-26615",
        "CVE-2023-4133",
        "CVE-2024-26584",
        "CVE-2023-1989",
        "CVE-2023-0386",
        "CVE-2023-1513",
        "CVE-2023-52497",
        "CVE-2023-21102",
        "CVE-2023-35829",
        "CVE-2024-23848",
        "CVE-2024-24855",
        "CVE-2024-0641",
        "CVE-2023-52525",
        "CVE-2023-4206",
        "CVE-2020-36694",
        "CVE-2021-47101",
        "CVE-2023-52603",
        "CVE-2019-19070",
        "CVE-2023-52577",
        "CVE-2023-52510",
        "CVE-2023-52530",
        "CVE-2023-39197",
        "CVE-2022-0480",
        "CVE-2023-52601",
        "CVE-2024-26583",
        "CVE-2023-52602",
        "CVE-2023-52435",
        "CVE-2023-2269",
        "CVE-2023-52509",
        "CVE-2022-3545",
        "CVE-2024-24864",
        "CVE-2023-1990",
        "CVE-2023-30772",
        "CVE-2023-3220",
        "CVE-2021-47105",
        "CVE-2022-0400",
        "CVE-2024-24859",
        "CVE-2023-52449",
        "CVE-2023-52522",
        "CVE-2023-52607",
        "CVE-2023-52439",
        "CVE-2023-23003",
        "CVE-2023-1670",
        "CVE-2023-3773",
        "CVE-2023-20593",
        "CVE-2023-28327",
        "CVE-2023-31081",
        "CVE-2022-3424",
        "CVE-2023-52448",
        "CVE-2023-52596",
        "CVE-2023-23000",
        "CVE-2022-3114",
        "CVE-2022-48626",
        "CVE-2023-52462",
        "CVE-2017-13694",
        "CVE-2023-32233",
        "CVE-2021-47076",
        "CVE-2023-28746",
        "CVE-2023-4273",
        "CVE-2023-32269",
        "CVE-2023-31085",
        "CVE-2023-0160",
        "CVE-2023-46862",
        "CVE-2024-26593",
        "CVE-2023-52584",
        "CVE-2023-1295",
        "CVE-2021-3714",
        "CVE-2024-26597",
        "CVE-2022-4543",
        "CVE-2023-52500",
        "CVE-2023-52451",
        "CVE-2023-2898",
        "CVE-2023-39192",
        "CVE-2023-22995",
        "CVE-2022-27672",
        "CVE-2019-16229",
        "CVE-2023-6931",
        "CVE-2023-52618",
        "CVE-2023-6356",
        "CVE-2023-52478",
        "CVE-2020-12362",
        "CVE-2021-3864",
        "CVE-2024-0193",
        "CVE-2023-52610",
        "CVE-2023-4134",
        "CVE-2023-52464",
        "CVE-2023-34256",
        "CVE-2023-52502",
        "CVE-2010-4563",
        "CVE-2023-52573",
        "CVE-2024-23849",
        "CVE-2023-45863",
        "CVE-2023-52493",
        "CVE-2023-47233",
        "CVE-2023-6546",
        "CVE-2020-12364",
        "CVE-2010-5321",
        "CVE-2022-2873",
        "CVE-2021-46987",
        "CVE-2023-26545",
        "CVE-2023-52458",
        "CVE-2004-0230",
        "CVE-2016-10723",
        "CVE-2022-45886",
        "CVE-2023-4623",
        "CVE-2023-52475",
        "CVE-2023-52604",
        "CVE-2017-13693",
        "CVE-2019-16232",
        "CVE-2022-44034",
        "CVE-2023-2002",
        "CVE-2023-52616",
        "CVE-2023-35824",
        "CVE-2024-0639",
        "CVE-2023-30456",
        "CVE-2021-47036",
        "CVE-2023-52566",
        "CVE-2023-1076",
        "CVE-2019-12379",
        "CVE-2024-0340",
        "CVE-2023-0045",
        "CVE-2023-52470",
        "CVE-2022-0500",
        "CVE-2023-3161",
        "CVE-2023-52593",
        "CVE-2023-52508",
        "CVE-2024-1151",
        "CVE-2023-52608",
        "CVE-2023-52598",
        "CVE-2023-23004",
        "CVE-2019-12381",
        "CVE-2024-26606",
        "CVE-2023-52481",
        "CVE-2024-23307",
        "CVE-2023-52485",
        "CVE-2024-2193",
        "CVE-2024-26586",
        "CVE-2021-47014",
        "CVE-2023-52492",
        "CVE-2022-45887",
        "CVE-2008-4609",
        "CVE-2023-25012",
        "CVE-2023-6176",
        "CVE-2023-52480",
        "CVE-2023-0266",
        "CVE-2023-1380",
        "CVE-2023-1079",
        "CVE-2023-31082",
        "CVE-2023-2162",
        "CVE-2023-4569",
        "CVE-2023-4004",
        "CVE-2023-52527",
        "CVE-2011-4916",
        "CVE-2023-1872",
        "CVE-2023-52615",
        "CVE-2018-17977",
        "CVE-2023-52456",
        "CVE-2021-44879",
        "CVE-2020-11725",
        "CVE-2023-52620",
        "CVE-2023-52474",
        "CVE-2023-0459",
        "CVE-2023-1118",
        "CVE-2023-42755",
        "CVE-2023-3268",
        "CVE-2024-25739",
        "CVE-2023-6606",
        "CVE-2023-35827",
        "CVE-2023-0458",
        "CVE-2023-35828",
        "CVE-2023-52586",
        "CVE-2020-24504",
        "CVE-2023-51779",
        "CVE-2019-11191",
        "CVE-2022-39189",
        "CVE-2019-20794",
        "CVE-2024-26625",
        "CVE-2023-52583",
        "CVE-2022-3707",
        "CVE-2023-3609",
        "CVE-2023-52513",
        "CVE-2021-4023",
        "CVE-2023-52574",
        "CVE-2023-39193",
        "CVE-2023-33203",
        "CVE-2023-1829",
        "CVE-2023-25775",
        "CVE-2024-0646",
        "CVE-2023-52564",
        "CVE-2023-52486",
        "CVE-2023-52599",
        "CVE-2021-32078",
        "CVE-2023-7192",
        "CVE-2023-52511",
        "CVE-2012-4542",
        "CVE-2023-0461",
        "CVE-2023-31084",
        "CVE-2023-35823",
        "CVE-2023-46813",
        "CVE-2023-20588",
        "CVE-2022-41218",
        "CVE-2023-2007",
        "CVE-2024-26642",
        "CVE-2023-3640",
        "CVE-2022-3623",
        "CVE-2021-46926",
        "CVE-2020-14304",
        "CVE-2024-26624",
        "CVE-2021-46937",
        "CVE-2023-45871",
        "CVE-2023-23559",
        "CVE-2023-2194",
        "CVE-2023-1077",
        "CVE-2023-52588",
        "CVE-2019-19449",
        "CVE-2023-39198",
        "CVE-2023-7042",
        "CVE-2024-26633",
        "CVE-2023-4921",
        "CVE-2023-52463",
        "CVE-2021-47037",
        "CVE-2023-37453",
        "CVE-2023-42756",
        "CVE-2023-52436",
        "CVE-2024-22099",
        "CVE-2017-0630",
        "CVE-2023-26242",
        "CVE-2018-12928",
        "CVE-2024-26635",
        "CVE-2024-26651",
        "CVE-2021-47176",
        "CVE-2024-26644",
        "CVE-2023-52622",
        "CVE-2023-52621",
        "CVE-2024-26647",
        "CVE-2023-52625",
        "CVE-2023-52628",
        "CVE-2023-52627",
        "CVE-2021-47178",
        "CVE-2023-52624",
        "CVE-2024-26648",
        "CVE-2024-26646",
        "CVE-2023-52623",
        "CVE-2024-26645",
        "CVE-2023-52629",
        "CVE-2022-4899",
        "CVE-2022-4415",
        "CVE-2023-31437",
        "CVE-2023-50387",
        "CVE-2022-3821",
        "CVE-2023-31438",
        "CVE-2020-13529",
        "CVE-2023-7008",
        "CVE-2023-50868",
        "CVE-2023-31439",
        "CVE-2013-4392",
        "CVE-2022-3715",
        "CVE-2021-31879",
        "CVE-2024-0553",
        "CVE-2023-5981",
        "CVE-2011-3389",
        "CVE-2024-28835",
        "CVE-2024-28834",
        "CVE-2023-0361",
        "CVE-2024-0567",
        "CVE-2016-2781",
        "CVE-2017-18018",
        "CVE-2017-17740",
        "CVE-2017-14159",
        "CVE-2020-15719",
        "CVE-2023-2953",
        "CVE-2015-3276",
        "CVE-2023-44487",
        "CVE-2023-29499",
        "CVE-2023-32665",
        "CVE-2023-32611",
        "CVE-2012-0039",
        "CVE-2019-1010023",
        "CVE-2019-1010022",
        "CVE-2023-4813",
        "CVE-2019-1010024",
        "CVE-2019-1010025",
        "CVE-2018-20796",
        "CVE-2019-9192",
        "CVE-2010-4756",
        "CVE-2023-4806",
        "CVE-2023-4911",
        "CVE-2019-8457",
        "CVE-2011-3374",
        "CVE-2019-19882",
        "CVE-2023-29383",
        "CVE-2013-4235",
        "CVE-2007-5686",
        "CVE-2023-4641",
        "CVE-2023-46218",
        "CVE-2023-23916",
        "CVE-2022-42916",
        "CVE-2022-43551",
        "CVE-2023-28321",
        "CVE-2021-22922",
        "CVE-2023-27533",
        "CVE-2023-27534",
        "CVE-2023-27536",
        "CVE-2023-38545",
        "CVE-2021-22923",
        "CVE-2023-28320",
        "CVE-2022-32221",
        "CVE-2023-23915",
        "CVE-2023-23914",
        "CVE-2023-28322",
        "CVE-2023-46219",
        "CVE-2023-38546",
        "CVE-2023-27538",
        "CVE-2022-43552",
        "CVE-2023-27535",
        "CVE-2024-2398",
        "CVE-2024-2379",
        "CVE-2022-0563",
        "CVE-2024-28085",
        "CVE-2022-0391",
        "CVE-2021-28861",
        "CVE-2023-24329",
        "CVE-2023-27043",
        "CVE-2021-4189",
        "CVE-2022-45061",
        "CVE-2023-40217",
        "CVE-2021-3426",
        "CVE-2022-42919",
        "CVE-2020-27619",
        "CVE-2022-37454",
        "CVE-2023-6597",
        "CVE-2015-20107",
        "CVE-2024-0450",
        "CVE-2020-10735",
        "CVE-2021-3737",
        "CVE-2021-3733",
        "CVE-2021-29921",
        "CVE-2017-16231",
        "CVE-2019-20838",
        "CVE-2017-7246",
        "CVE-2017-11164",
        "CVE-2017-7245",
        "CVE-2020-15778",
        "CVE-2007-2768",
        "CVE-2018-15919",
        "CVE-2023-51767",
        "CVE-2019-6110",
        "CVE-2016-20012",
        "CVE-2021-36368",
        "CVE-2008-3234",
        "CVE-2023-38408",
        "CVE-2021-41617",
        "CVE-2023-51385",
        "CVE-2023-48795",
        "CVE-2007-2243",
        "CVE-2020-14145",
        "CVE-2022-42916",
        "CVE-2022-43551",
        "CVE-2021-22922",
        "CVE-2021-22923",
        "CVE-2023-28320",
        "CVE-2023-23915",
        "CVE-2023-23914",
        "CVE-2023-46219",
        "CVE-2024-2398",
        "CVE-2024-2379",
        "CVE-2005-2541",
        "CVE-2022-48303",
        "CVE-2023-39804",
        "CVE-2021-36087",
        "CVE-2021-36084",
        "CVE-2021-36085",
        "CVE-2021-36086",
        "CVE-2024-22365",
        "CVE-2023-30571",
        "CVE-2022-36227",
        "CVE-2021-36976",
        "CVE-2022-26280"
    ],
    "vulnerabilities": [
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2019-19814",
            "namespace": "debian:11",
            "description": "In the Linux kernel 5.0.21, mounting a crafted f2fs filesystem image can cause __remove_dirty_segment slab-out-of-bounds write access because an array is bounded by the number of dirty types (8) but the array index can exceed this.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-19814",
            "severity": "Critical",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2013-7445",
            "namespace": "debian:11",
            "description": "The Direct Rendering Manager (DRM) subsystem in the Linux kernel through 4.x mishandles requests for Graphics Execution Manager (GEM) objects, which allows context-dependent attackers to cause a denial of service (memory consumption) via an application that processes graphics data, as demonstrated by JavaScript code that creates many CANVAS elements for rendering by Chrome or Firefox.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2013-7445",
            "severity": "High",
            "fixedby": ""
        },
        {
            "featurename": "git",
            "featureversion": "1:2.30.2-1",
            "vulnerability": "CVE-2022-24765",
            "namespace": "debian:11",
            "description": "Git for Windows is a fork of Git containing Windows-specific patches. This vulnerability affects users working on multi-user machines, where untrusted parties have write access to the same hard disk. Those untrusted parties could create the folder `C:\\.git`, which would be picked up by Git operations run supposedly outside a repository while searching for a Git directory. Git would then respect any config in said Git directory. Git Bash users who set `GIT_PS1_SHOWDIRTYSTATE` are vulnerable as well. Users who installed posh-gitare vulnerable simply by starting a PowerShell. Users of IDEs such as Visual Studio are vulnerable: simply creating a new project would already read and respect the config specified in `C:\\.git\\config`. Users of the Microsoft fork of Git are vulnerable simply by starting a Git Bash. The problem has been patched in Git for Windows v2.35.2. Users unable to upgrade may create the folder `.git` on all drives where Git commands are run, and remove read/write access from those folders as a workaround. Alternatively, define or extend `GIT_CEILING_DIRECTORIES` to cover the _parent_ directory of the user profile, e.g. `C:\\Users` if the user profile is located in `C:\\Users\\my-user-name`.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-24765",
            "severity": "High",
            "fixedby": "1:2.30.2-1+deb11u1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2021-3847",
            "namespace": "debian:11",
            "description": "An unauthorized access to the execution of the setuid file with capabilities flaw in the Linux kernel OverlayFS subsystem was found in the way user copying a capable file from a nosuid mount into another mount. A local user could use this flaw to escalate their privileges on the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-3847",
            "severity": "High",
            "fixedby": ""
        },
        {
            "featurename": "git",
            "featureversion": "1:2.30.2-1",
            "vulnerability": "CVE-2022-29187",
            "namespace": "debian:11",
            "description": "Git is a distributed revision control system. Git prior to versions 2.37.1, 2.36.2, 2.35.4, 2.34.4, 2.33.4, 2.32.3, 2.31.4, and 2.30.5, is vulnerable to privilege escalation in all platforms. An unsuspecting user could still be affected by the issue reported in CVE-2022-24765, for example when navigating as root into a shared tmp directory that is owned by them, but where an attacker could create a git repository. Versions 2.37.1, 2.36.2, 2.35.4, 2.34.4, 2.33.4, 2.32.3, 2.31.4, and 2.30.5 contain a patch for this issue. The simplest way to avoid being affected by the exploit described in the example is to avoid running git as root (or an Administrator in Windows), and if needed to reduce its use to a minimum. While a generic workaround is not possible, a system could be hardened from the exploit described in the example by removing any such repository if it exists already and creating one as root to block any future attacks.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-29187",
            "severity": "High",
            "fixedby": "1:2.30.2-1+deb11u1"
        },
        {
            "featurename": "python3.9",
            "featureversion": "3.9.2-1",
            "vulnerability": "CVE-2021-3737",
            "namespace": "debian:11",
            "description": "A flaw was found in python. An improperly handled HTTP response in the HTTP client code of python may allow a remote attacker, who controls the HTTP server, to make the client script enter an infinite loop, consuming CPU time. The highest threat from this vulnerability is to system availability.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-3737",
            "severity": "High",
            "fixedby": ""
        },
        {
            "featurename": "python3.9",
            "featureversion": "3.9.2-1",
            "vulnerability": "CVE-2015-20107",
            "namespace": "debian:11",
            "description": "In Python (aka CPython) up to 3.10.8, the mailcap module does not add escape characters into commands discovered in the system mailcap file. This may allow attackers to inject shell commands into applications that call mailcap.findmatch with untrusted input (if they lack validation of user-provided filenames or arguments). The fix is also back-ported to 3.7, 3.8, 3.9",
            "link": "https://security-tracker.debian.org/tracker/CVE-2015-20107",
            "severity": "High",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2021-39686",
            "namespace": "debian:11",
            "description": "In several functions of binder.c, there is a possible way to represent the wrong domain to SELinux due to a race condition. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-200688826References: Upstream kernel",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-39686",
            "severity": "High",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2019-15794",
            "namespace": "debian:11",
            "description": "Overlayfs in the Linux kernel and shiftfs, a non-upstream patch to the Linux kernel included in the Ubuntu 5.0 and 5.3 kernel series, both replace vma-\u003evm_file in their mmap handlers. On error the original value is not restored, and the reference is put for the file to which vm_file points. On upstream kernels this is not an issue, as no callers dereference vm_file following after call_mmap() returns an error. However, the aufs patchs change mmap_region() to replace the fput() using a local variable with vma_fput(), which will fput() vm_file, leading to a refcount underflow.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-15794",
            "severity": "High",
            "fixedby": ""
        },
        {
            "featurename": "python3.9",
            "featureversion": "3.9.2-1",
            "vulnerability": "CVE-2022-0391",
            "namespace": "debian:11",
            "description": "A flaw was found in Python, specifically within the urllib.parse module. This module helps break Uniform Resource Locator (URL) strings into components. The issue involves how the urlparse method does not sanitize input and allows characters like '\\r' and '\\n' in the URL path. This flaw allows an attacker to input a crafted URL, leading to injection attacks. This flaw affects Python versions prior to 3.10.0b1, 3.9.5, 3.8.11, 3.7.11 and 3.6.14.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-0391",
            "severity": "Medium",
            "fixedby": ""
        },
        {
            "featurename": "libxml2",
            "featureversion": "2.9.10+dfsg-6.7+deb11u4",
            "vulnerability": "CVE-2022-2309",
            "namespace": "debian:11",
            "description": "NULL Pointer Dereference allows attackers to cause a denial of service (or application crash). This only applies when lxml is used together with libxml2 2.9.10 through 2.9.14. libxml2 2.9.9 and earlier are not affected. It allows triggering crashes through forged input data, given a vulnerable code sequence in the application. The vulnerability is caused by the iterwalk function (also used by the canonicalize function). Such code shouldn't be in wide-spread use, given that parsing + iterwalk would usually be replaced with the more efficient iterparse function. However, an XML converter that serialises to C14N would also be vulnerable, for example, and there are legitimate use cases for this code sequence. If untrusted input is received (also remotely) and processed via iterwalk function, a crash can be triggered.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-2309",
            "severity": "Medium",
            "fixedby": ""
        },
        {
            "featurename": "perl",
            "featureversion": "5.32.1-4+deb11u2",
            "vulnerability": "CVE-2020-16156",
            "namespace": "debian:11",
            "description": "CPAN 2.28 allows Signature Verification Bypass.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-16156",
            "severity": "Medium",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2019-16089",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 5.2.13. nbd_genl_status in drivers/block/nbd.c does not check the nla_nest_start_noflag return value.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-16089",
            "severity": "Medium",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2019-15213",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel before 5.2.3. There is a use-after-free caused by a malicious USB device in the drivers/media/usb/dvb-usb/dvb-usb-init.c driver.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-15213",
            "severity": "Medium",
            "fixedby": ""
        },
        {
            "featurename": "openssh",
            "featureversion": "1:8.4p1-5+deb11u1",
            "vulnerability": "CVE-2021-41617",
            "namespace": "debian:11",
            "description": "sshd in OpenSSH 6.2 through 8.x before 8.8, when certain non-default configurations are used, allows privilege escalation because supplemental groups are not initialized as expected. Helper programs for AuthorizedKeysCommand and AuthorizedPrincipalsCommand may run with privileges associated with group memberships of the sshd process, if the configuration specifies running the command as a different user.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-41617",
            "severity": "Medium",
            "fixedby": "1:8.4p1-5+deb11u3"
        },
        {
            "featurename": "openssl",
            "featureversion": "1.1.1n-0+deb11u3",
            "vulnerability": "CVE-2022-2097",
            "namespace": "debian:11",
            "description": "AES OCB mode for 32-bit x86 platforms using the AES-NI assembly optimised implementation will not encrypt the entirety of the data under some circumstances. This could reveal sixteen bytes of data that was preexisting in the memory that wasn't written. In the special case of \"in place\" encryption, sixteen bytes of the plaintext would be revealed. Since OpenSSL does not support OCB based cipher suites for TLS and DTLS, they are both unaffected. Fixed in OpenSSL 3.0.5 (Affected 3.0.0-3.0.4). Fixed in OpenSSL 1.1.1q (Affected 1.1.1-1.1.1p).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-2097",
            "severity": "Medium",
            "fixedby": "1.1.1n-0+deb11u4"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2021-44879",
            "namespace": "debian:11",
            "description": "In gc_data_segment in fs/f2fs/gc.c in the Linux kernel before 5.16.3, special files are not considered, leading to a move_data_page NULL pointer dereference.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-44879",
            "severity": "Medium",
            "fixedby": "5.10.205-2"
        },
        {
            "featurename": "python3.9",
            "featureversion": "3.9.2-1",
            "vulnerability": "CVE-2021-3733",
            "namespace": "debian:11",
            "description": "There's a flaw in urllib's AbstractBasicAuthHandler class. An attacker who controls a malicious HTTP server that an HTTP client (such as web browser) connects to, could trigger a Regular Expression Denial of Service (ReDOS) during an authentication request with a specially crafted payload that is sent by the server to the client. The greatest threat that this flaw poses is to application availability.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-3733",
            "severity": "Medium",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2019-20794",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel 4.18 through 5.6.11 when unprivileged user namespaces are allowed. A user can create their own PID namespace, and mount a FUSE filesystem. Upon interaction with this FUSE filesystem, if the userspace component is terminated via a kill of the PID namespace's pid 1, it will result in a hung task, and resources being permanently locked up until system reboot. This can result in resource exhaustion.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-20794",
            "severity": "Medium",
            "fixedby": ""
        },
        {
            "featurename": "libgcrypt20",
            "featureversion": "1.8.7-6",
            "vulnerability": "CVE-2021-33560",
            "namespace": "debian:11",
            "description": "Libgcrypt before 1.8.8 and 1.9.x before 1.9.3 mishandles ElGamal encryption because it lacks exponent blinding to address a side-channel attack against mpi_powm, and the window size is not chosen appropriately. This, for example, affects use of ElGamal in OpenPGP.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-33560",
            "severity": "Medium",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2019-19449",
            "namespace": "debian:11",
            "description": "In the Linux kernel 5.0.21, mounting a crafted f2fs filesystem image can lead to slab-out-of-bounds read access in f2fs_build_segment_manager in fs/f2fs/segment.c, related to init_min_max_mtime in fs/f2fs/segment.c (because the second argument to get_seg_entry is not validated).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-19449",
            "severity": "Medium",
            "fixedby": ""
        },
        {
            "featurename": "e2fsprogs",
            "featureversion": "1.46.2-2",
            "vulnerability": "CVE-2022-1304",
            "namespace": "debian:11",
            "description": "An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-1304",
            "severity": "Medium",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2020-12362",
            "namespace": "debian:11",
            "description": "Integer overflow in the firmware for some Intel(R) Graphics Drivers for Windows * before version 26.20.100.7212 and before Linux kernel version 5.5 may allow a privileged user to potentially enable an escalation of privilege via local access.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-12362",
            "severity": "Medium",
            "fixedby": ""
        },
        {
            "featurename": "ncurses",
            "featureversion": "6.2+20201114-2",
            "vulnerability": "CVE-2022-29458",
            "namespace": "debian:11",
            "description": "ncurses 6.3 before patch 20220416 has an out-of-bounds read and segmentation violation in convert_strings in tinfo/read_entry.c in the terminfo library.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-29458",
            "severity": "Medium",
            "fixedby": "6.2+20201114-2+deb11u1"
        },
        {
            "featurename": "wget",
            "featureversion": "1.21-1+deb11u1",
            "vulnerability": "CVE-2021-31879",
            "namespace": "debian:11",
            "description": "GNU Wget through 1.21.1 does not omit the Authorization header upon a redirect to a different origin, a related issue to CVE-2018-1000007.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-31879",
            "severity": "Medium",
            "fixedby": ""
        },
        {
            "featurename": "coreutils",
            "featureversion": "8.32-4",
            "vulnerability": "CVE-2016-2781",
            "namespace": "debian:11",
            "description": "chroot in GNU coreutils, when used with --userspec, allows local users to escape to the parent session via a crafted TIOCSTI ioctl call, which pushes characters to the terminal's input buffer.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2016-2781",
            "severity": "Low",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-1280",
            "namespace": "debian:11",
            "description": "A use-after-free vulnerability was found in drm_lease_held in drivers/gpu/drm/drm_lease.c in the Linux kernel due to a race problem. This flaw allows a local user privilege attacker to cause a denial of service (DoS) or a kernel information leak.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-1280",
            "severity": "Low",
            "fixedby": ""
        },
        {
            "featurename": "libsepol",
            "featureversion": "3.1-1",
            "vulnerability": "CVE-2021-36087",
            "namespace": "debian:11",
            "description": "The CIL compiler in SELinux 3.2 has a heap-based buffer over-read in ebitmap_match_any (called indirectly from cil_check_neverallow). This occurs because there is sometimes a lack of checks for invalid statements in an optional block.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-36087",
            "severity": "Low",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2018-12928",
            "namespace": "debian:11",
            "description": "In the Linux kernel 4.15.0, a NULL pointer dereference was discovered in hfs_ext_read_extent in hfs.ko. This can occur during a mount of a crafted hfs filesystem.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2018-12928",
            "severity": "Low",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2020-14304",
            "namespace": "debian:11",
            "description": "A memory disclosure flaw was found in the Linux kernel's ethernet drivers, in the way it read data from the EEPROM of the device. This flaw allows a local user to read uninitialized values from the kernel memory. The highest threat from this vulnerability is to confidentiality.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-14304",
            "severity": "Low",
            "fixedby": ""
        },
        {
            "featurename": "libsepol",
            "featureversion": "3.1-1",
            "vulnerability": "CVE-2021-36084",
            "namespace": "debian:11",
            "description": "The CIL compiler in SELinux 3.2 has a use-after-free in __cil_verify_classperms (called from __cil_verify_classpermission and __cil_pre_verify_helper).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-36084",
            "severity": "Low",
            "fixedby": ""
        },
        {
            "featurename": "libsepol",
            "featureversion": "3.1-1",
            "vulnerability": "CVE-2021-36085",
            "namespace": "debian:11",
            "description": "The CIL compiler in SELinux 3.2 has a use-after-free in __cil_verify_classperms (called from __verify_map_perm_classperms and hashtab_map).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-36085",
            "severity": "Low",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2021-4149",
            "namespace": "debian:11",
            "description": "A vulnerability was found in btrfs_alloc_tree_b in fs/btrfs/extent-tree.c in the Linux kernel due to an improper lock operation in btrfs. In this flaw, a user with a local privilege may cause a denial of service (DOS) due to a deadlock problem.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-4149",
            "severity": "Low",
            "fixedby": ""
        },
        {
            "featurename": "libsepol",
            "featureversion": "3.1-1",
            "vulnerability": "CVE-2021-36086",
            "namespace": "debian:11",
            "description": "The CIL compiler in SELinux 3.2 has a use-after-free in cil_reset_classpermission (called from cil_reset_classperms_set and cil_reset_classperms_list).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-36086",
            "severity": "Low",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2020-12363",
            "namespace": "debian:11",
            "description": "Improper input validation in some Intel(R) Graphics Drivers for Windows* before version 26.20.100.7212 and before Linux kernel version 5.5 may allow a privileged user to potentially enable a denial of service via local access.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-12363",
            "severity": "Low",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2021-33061",
            "namespace": "debian:11",
            "description": "Insufficient control flow management for the Intel(R) 82599 Ethernet Controllers and Adapters may allow an authenticated user to potentially enable denial of service via local access.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-33061",
            "severity": "Low",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2020-12364",
            "namespace": "debian:11",
            "description": "Null pointer reference in some Intel(R) Graphics Drivers for Windows* before version 26.20.100.7212 and before version Linux kernel version 5.5 may allow a privileged user to potentially enable a denial of service via local access.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-12364",
            "severity": "Low",
            "fixedby": ""
        },
        {
            "featurename": "pcre3",
            "featureversion": "2:8.39-13",
            "vulnerability": "CVE-2017-7246",
            "namespace": "debian:11",
            "description": "Stack-based buffer overflow in the pcre32_copy_substring function in pcre_get.c in libpcre1 in PCRE 8.40 allows remote attackers to cause a denial of service (WRITE of size 268) or possibly have unspecified other impact via a crafted file.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2017-7246",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-21400",
            "namespace": "debian:11",
            "description": "In multiple functions  of io_uring.c, there is a possible kernel memory corruption due to improper locking. This could lead to local escalation of privilege in the kernel with System execution privileges needed. User interaction is not needed for exploitation.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-21400",
            "severity": "Negligible",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2019-1010204",
            "namespace": "debian:11",
            "description": "GNU binutils gold gold v1.11-v1.16 (GNU binutils v2.21-v2.31.1) is affected by: Improper Input Validation, Signed/Unsigned Comparison, Out-of-bounds Read. The impact is: Denial of service. The component is: gold/fileread.cc:497, elfcpp/elfcpp_file.h:644. The attack vector is: An ELF file with an invalid e_shoff header field must be opened.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-1010204",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2022-44840",
            "namespace": "debian:11",
            "description": "Heap buffer overflow vulnerability in binutils readelf before 2.40 via function find_section_in_set in file readelf.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-44840",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2021-3549",
            "namespace": "debian:11",
            "description": "An out of bounds flaw was found in GNU binutils objdump utility version 2.36. An attacker could use this flaw and pass a large section to avr_elf32_load_records_from_section() probably resulting in a crash or in some cases memory corruption. The highest threat from this vulnerability is to integrity as well as system availability.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-3549",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2018-20712",
            "namespace": "debian:11",
            "description": "A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty, as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults, leading to denial-of-service, as demonstrated by c++filt.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2018-20712",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2021-45078",
            "namespace": "debian:11",
            "description": "stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact, as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-45078",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2023-25586",
            "namespace": "debian:11",
            "description": "A flaw was found in Binutils. A logic fail in the bfd_init_section_decompress_status function may lead to the use of an uninitialized variable that can cause a crash and local denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-25586",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2018-9996",
            "namespace": "debian:11",
            "description": "An issue was discovered in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.30. Stack Exhaustion occurs in the C++ demangling functions provided by libiberty, and there are recursive stack frames: demangle_template_value_parm, demangle_integral_value, and demangle_expression.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2018-9996",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2021-20284",
            "namespace": "debian:11",
            "description": "A flaw was found in GNU Binutils 2.35.1, where there is a heap-based buffer overflow in _bfd_elf_slurp_secondary_reloc_section in elf.c due to the number of symbols not calculated correctly. The highest threat from this vulnerability is to system availability.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-20284",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2022-47695",
            "namespace": "debian:11",
            "description": "An issue was discovered Binutils objdump before 2.39.3 allows attackers to cause a denial of service or other unspecified impacts via function bfd_mach_o_get_synthetic_symtab in match-o.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-47695",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2022-47696",
            "namespace": "debian:11",
            "description": "An issue was discovered Binutils objdump before 2.39.3 allows attackers to cause a denial of service or other unspecified impacts via function compare_symbols.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-47696",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2022-47010",
            "namespace": "debian:11",
            "description": "An issue was discovered function pr_function_type in prdbg.c in Binutils 2.34 thru 2.38, allows attackers to cause a denial of service due to memory leaks.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-47010",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2021-32256",
            "namespace": "debian:11",
            "description": "An issue was discovered in GNU libiberty, as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-32256",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2021-3826",
            "namespace": "debian:11",
            "description": "Heap/stack buffer overflow in the dlang_lname function in d-demangle.c in libiberty allows attackers to potentially cause a denial of service (segmentation fault and crash) via a crafted mangled symbol.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-3826",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2022-47007",
            "namespace": "debian:11",
            "description": "An issue was discovered function stab_demangle_v3_arg in stabs.c in Binutils 2.34 thru 2.38, allows attackers to cause a denial of service due to memory leaks.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-47007",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2023-1972",
            "namespace": "debian:11",
            "description": "A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1972",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2022-47011",
            "namespace": "debian:11",
            "description": "An issue was discovered function parse_stab_struct_fields in stabs.c in Binutils 2.34 thru 2.38, allows attackers to cause a denial of service due to memory leaks.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-47011",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2023-25585",
            "namespace": "debian:11",
            "description": "A flaw was found in Binutils. The use of an uninitialized field in the struct module *module may lead to application crash and local denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-25585",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2022-48063",
            "namespace": "debian:11",
            "description": "GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function load_separate_debug_files at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-48063",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2017-13716",
            "namespace": "debian:11",
            "description": "The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2017-13716",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2023-1579",
            "namespace": "debian:11",
            "description": "Heap based buffer overflow in binutils-gdb/bfd/libbfd.c in bfd_getl64.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1579",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2018-18483",
            "namespace": "debian:11",
            "description": "The get_count function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31, allows remote attackers to cause a denial of service (malloc called with the result of an integer-overflowing calculation) or possibly have unspecified other impact via a crafted string, as demonstrated by c++filt.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2018-18483",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2022-47008",
            "namespace": "debian:11",
            "description": "An issue was discovered function make_tempdir, and make_tempname in bucomm.c in Binutils 2.34 thru 2.38, allows attackers to cause a denial of service due to memory leaks.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-47008",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2021-3530",
            "namespace": "debian:11",
            "description": "A flaw was discovered in GNU libiberty within demangle_path() in rust-demangle.c, as distributed in GNU Binutils version 2.36. A crafted symbol can cause stack memory to be exhausted leading to a crash.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-3530",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2022-35206",
            "namespace": "debian:11",
            "description": "Null pointer dereference vulnerability in Binutils readelf 2.38.50 via function read_and_display_attr_value in file dwarf.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-35206",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2020-19726",
            "namespace": "debian:11",
            "description": "An issue was discovered in binutils libbfd.c 2.36 relating to the auxiliary symbol data allows attackers to read or write to system memory or cause a denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-19726",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2022-45703",
            "namespace": "debian:11",
            "description": "Heap buffer overflow vulnerability in binutils readelf before 2.40 via function display_debug_section in file readelf.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-45703",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2021-46174",
            "namespace": "debian:11",
            "description": "Heap-based Buffer Overflow in function bfd_getl32 in Binutils objdump 3.37.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-46174",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2022-4285",
            "namespace": "debian:11",
            "description": "An illegal memory access flaw was found in the binutils package. Parsing an ELF file containing corrupt symbol version information may result in a denial of service. This issue is the result of an incomplete fix for CVE-2020-16599.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-4285",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2021-20197",
            "namespace": "debian:11",
            "description": "There is an open race window when writing output in the following utilities in GNU binutils version 2.35 and earlier:ar, objcopy, strip, ranlib. When these utilities are run as a privileged user (presumably as part of a script updating binaries across different users), an unprivileged user can trick these utilities into getting ownership of arbitrary files through a symlink.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-20197",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2023-25584",
            "namespace": "debian:11",
            "description": "An out-of-bounds read flaw was found in the parse_module function in bfd/vms-alpha.c in Binutils.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-25584",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2021-46195",
            "namespace": "debian:11",
            "description": "GCC v12.0 was discovered to contain an uncontrolled recursion via the component libiberty/rust-demangle.c. This vulnerability allows attackers to cause a Denial of Service (DoS) by consuming excessive CPU and memory resources.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-46195",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2020-35448",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.35.1. A heap-based buffer over-read can occur in bfd_getl_signed_32 in libbfd.c because sh_entsize is not validated in _bfd_elf_slurp_secondary_reloc_section in elf.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-35448",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2022-48065",
            "namespace": "debian:11",
            "description": "GNU Binutils before 2.40 was discovered to contain a memory leak vulnerability var the function find_abstract_instance in dwarf2.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-48065",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2022-48064",
            "namespace": "debian:11",
            "description": "GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function bfd_dwarf2_find_nearest_line_with_alt at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-48064",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2023-25588",
            "namespace": "debian:11",
            "description": "A flaw was found in Binutils. The field `the_bfd` of `asymbol`struct is uninitialized in the `bfd_mach_o_get_synthetic_symtab` function, which may lead to an application crash and local denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-25588",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2022-35205",
            "namespace": "debian:11",
            "description": "An issue was discovered in Binutils readelf 2.38.50, reachable assertion failure in function display_debug_names allows attackers to cause a denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-35205",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2022-38533",
            "namespace": "debian:11",
            "description": "In GNU Binutils before 2.40, there is a heap-buffer-overflow in the error function bfd_getl32 when called from the strip_main function in strip-new via a crafted file.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-38533",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "openssh",
            "featureversion": "1:8.4p1-5+deb11u1",
            "vulnerability": "CVE-2008-3234",
            "namespace": "debian:11",
            "description": "sshd in OpenSSH 4 on Debian GNU/Linux, and the 20070303 OpenSSH snapshot, allows remote authenticated users to obtain access to arbitrary SELinux roles by appending a :/ (colon slash) sequence, followed by the role name, to the username.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2008-3234",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2022-47673",
            "namespace": "debian:11",
            "description": "An issue was discovered in Binutils addr2line before 2.39.3, function parse_module contains multiple out of bound reads which may cause a denial of service or other unspecified impacts.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-47673",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "openssh",
            "featureversion": "1:8.4p1-5+deb11u1",
            "vulnerability": "CVE-2021-36368",
            "namespace": "debian:11",
            "description": "An issue was discovered in OpenSSH before 8.9. If a client is using public-key authentication with agent forwarding but without -oLogLevel=verbose, and an attacker has silently modified the server to support the None authentication option, then the user cannot determine whether FIDO authentication is going to confirm that the user wishes to connect to that server, or that the user wishes to allow that server to connect to a different server on the user's behalf. NOTE: the vendor's position is \"this is not an authentication bypass, since nothing is being bypassed.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-36368",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "openssh",
            "featureversion": "1:8.4p1-5+deb11u1",
            "vulnerability": "CVE-2016-20012",
            "namespace": "debian:11",
            "description": "OpenSSH through 8.7 allows remote attackers, who have a suspicion that a certain combination of username and public key is known to an SSH server, to test whether this suspicion is correct. This occurs because a challenge is sent only when that combination could be valid for a login session. NOTE: the vendor does not recognize user enumeration as a vulnerability for this product",
            "link": "https://security-tracker.debian.org/tracker/CVE-2016-20012",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "git",
            "featureversion": "1:2.30.2-1",
            "vulnerability": "CVE-2018-1000021",
            "namespace": "debian:11",
            "description": "GIT version 2.15.1 and earlier contains a Input Validation Error vulnerability in Client that can result in problems including messing up terminal configuration to RCE. This attack appear to be exploitable via The user must interact with a malicious git server, (or have their traffic modified in a MITM attack).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2018-1000021",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "openssh",
            "featureversion": "1:8.4p1-5+deb11u1",
            "vulnerability": "CVE-2019-6110",
            "namespace": "debian:11",
            "description": "In OpenSSH 7.9, due to accepting and displaying arbitrary stderr output from the server, a malicious server (or Man-in-The-Middle attacker) can manipulate the client output, for example to use ANSI control codes to hide additional files being transferred.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-6110",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "openssh",
            "featureversion": "1:8.4p1-5+deb11u1",
            "vulnerability": "CVE-2023-51767",
            "namespace": "debian:11",
            "description": "OpenSSH through 9.6, when common types of DRAM are used, might allow row hammer attacks (for authentication bypass) because the integer value of authenticated in mm_answer_authpassword does not resist flips of a single bit. NOTE: this is applicable to a certain threat model of attacker-victim co-location in which the attacker has user privileges.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-51767",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "openssh",
            "featureversion": "1:8.4p1-5+deb11u1",
            "vulnerability": "CVE-2018-15919",
            "namespace": "debian:11",
            "description": "Remotely observable behaviour in auth-gss2.c in OpenSSH through 7.8 could be used by remote attackers to detect existence of users on a target system when GSS2 is in use. NOTE: the discoverer states 'We understand that the OpenSSH developers do not want to treat such a username enumeration (or \"oracle\") as a vulnerability.'",
            "link": "https://security-tracker.debian.org/tracker/CVE-2018-15919",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "openssh",
            "featureversion": "1:8.4p1-5+deb11u1",
            "vulnerability": "CVE-2007-2768",
            "namespace": "debian:11",
            "description": "OpenSSH, when using OPIE (One-Time Passwords in Everything) for PAM, allows remote attackers to determine the existence of certain user accounts, which displays a different response if the user account exists and is configured to use one-time passwords (OTP), a similar issue to CVE-2007-2243.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2007-2768",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "openssh",
            "featureversion": "1:8.4p1-5+deb11u1",
            "vulnerability": "CVE-2020-15778",
            "namespace": "debian:11",
            "description": "scp in OpenSSH through 8.3p1 allows command injection in the scp.c toremote function, as demonstrated by backtick characters in the destination argument. NOTE: the vendor reportedly has stated that they intentionally omit validation of \"anomalous argument transfers\" because that could \"stand a great chance of breaking existing workflows.\"",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-15778",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "perl",
            "featureversion": "5.32.1-4+deb11u2",
            "vulnerability": "CVE-2023-47038",
            "namespace": "debian:11",
            "description": "A vulnerability was found in perl. This issue occurs when a crafted regular expression is compiled by perl, which can allow an attacker controlled byte buffer overflow in a heap allocated buffer.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-47038",
            "severity": "Negligible",
            "fixedby": "5.32.1-4+deb11u3"
        },
        {
            "featurename": "pcre3",
            "featureversion": "2:8.39-13",
            "vulnerability": "CVE-2017-7245",
            "namespace": "debian:11",
            "description": "Stack-based buffer overflow in the pcre32_copy_substring function in pcre_get.c in libpcre1 in PCRE 8.40 allows remote attackers to cause a denial of service (WRITE of size 4) or possibly have unspecified other impact via a crafted file.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2017-7245",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "pcre3",
            "featureversion": "2:8.39-13",
            "vulnerability": "CVE-2017-11164",
            "namespace": "debian:11",
            "description": "In PCRE 8.41, the OP_KETRMAX feature in the match function in pcre_exec.c allows stack exhaustion (uncontrolled recursion) when processing a crafted regular expression.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2017-11164",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52503",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  tee: amdtee: fix use-after-free vulnerability in amdtee_close_session  There is a potential race condition in amdtee_close_session that may cause use-after-free in amdtee_open_session. For instance, if a session has refcount == 1, and one thread tries to free this session via:      kref_put(\u0026sess-\u003erefcount, destroy_session);  the reference count will get decremented, and the next step would be to call destroy_session(). However, if in another thread, amdtee_open_session() is called before destroy_session() has completed execution, alloc_session() may return 'sess' that will be freed up later in destroy_session() leading to use-after-free in amdtee_open_session.  To fix this issue, treat decrement of sess-\u003erefcount and removal of 'sess' from session list in destroy_session() as a critical section, so that it is executed atomically.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52503",
            "severity": "Negligible",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "git",
            "featureversion": "1:2.30.2-1",
            "vulnerability": "CVE-2022-24975",
            "namespace": "debian:11",
            "description": "The --mirror documentation for Git through 2.35.1 does not mention the availability of deleted content, aka the \"GitBleed\" issue. This could present a security risk if information-disclosure auditing processes rely on a clone operation without the --mirror option.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-24975",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "pcre3",
            "featureversion": "2:8.39-13",
            "vulnerability": "CVE-2019-20838",
            "namespace": "debian:11",
            "description": "libpcre in PCRE before 8.43 allows a subject buffer over-read in JIT when UTF is disabled, and \\X or \\R has more than one fixed quantifier, a related issue to CVE-2019-20454.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-20838",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "perl",
            "featureversion": "5.32.1-4+deb11u2",
            "vulnerability": "CVE-2023-31486",
            "namespace": "debian:11",
            "description": "HTTP::Tiny before 0.083, a Perl core module since 5.13.9 and available standalone on CPAN, has an insecure default TLS configuration where users must opt in to verify certificates.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-31486",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "pcre3",
            "featureversion": "2:8.39-13",
            "vulnerability": "CVE-2017-16231",
            "namespace": "debian:11",
            "description": "In PCRE 8.41, after compiling, a pcretest load test PoC produces a crash overflow in the function match() in pcre_exec.c because of a self-recursive call. NOTE: third parties dispute the relevance of this report, noting that there are options that can be used to limit the amount of stack that is used",
            "link": "https://security-tracker.debian.org/tracker/CVE-2017-16231",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "nodejs",
            "featureversion": "20.12.0-1nodesource1",
            "vulnerability": "CVE-2023-32006",
            "namespace": "debian:11",
            "description": "The use of `module.constructor.createRequire()` can bypass the policy mechanism and require modules outside of the policy.json definition for a given module.  This vulnerability affects all users using the experimental policy mechanism in all active release lines: 16.x, 18.x, and, 20.x.  Please note that at the time this CVE was issued, the policy is an experimental feature of Node.js.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-32006",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "nodejs",
            "featureversion": "20.12.0-1nodesource1",
            "vulnerability": "CVE-2023-32002",
            "namespace": "debian:11",
            "description": "The use of `Module._load()` can bypass the policy mechanism and require modules outside of the policy.json definition for a given module.  This vulnerability affects all users using the experimental policy mechanism in all active release lines: 16.x, 18.x and, 20.x.  Please note that at the time this CVE was issued, the policy is an experimental feature of Node.js.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-32002",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "nodejs",
            "featureversion": "20.12.0-1nodesource1",
            "vulnerability": "CVE-2023-30589",
            "namespace": "debian:11",
            "description": "The llhttp parser in the http module in Node v20.2.0 does not strictly use the CRLF sequence to delimit HTTP requests. This can lead to HTTP Request Smuggling (HRS).\r \r The CR character (without LF) is sufficient to delimit HTTP header fields in the llhttp parser. According to RFC7230 section 3, only the CRLF sequence should delimit each header-field. This impacts all Node.js active versions: v16, v18, and, v20",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-30589",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "nodejs",
            "featureversion": "20.12.0-1nodesource1",
            "vulnerability": "CVE-2023-32559",
            "namespace": "debian:11",
            "description": "A privilege escalation vulnerability exists in the experimental policy mechanism in all active release lines: 16.x, 18.x and, 20.x. The use of the deprecated API `process.binding()` can bypass the policy mechanism by requiring internal modules and eventually take advantage of `process.binding('spawn_sync')` run arbitrary code, outside of the limits defined in a `policy.json` file. Please note that at the time this CVE was issued, the policy is an experimental feature of Node.js.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-32559",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "python3.9",
            "featureversion": "3.9.2-1",
            "vulnerability": "CVE-2021-29921",
            "namespace": "debian:11",
            "description": "In Python before 3,9,5, the ipaddress library mishandles leading zero characters in the octets of an IP address string. This (in some situations) allows attackers to bypass access control that is based on IP addresses.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-29921",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "nodejs",
            "featureversion": "20.12.0-1nodesource1",
            "vulnerability": "CVE-2023-30581",
            "namespace": "debian:11",
            "description": "The use of __proto__ in process.mainModule.__proto__.require() can bypass the policy mechanism and require modules outside of the policy.json definition. This vulnerability affects all users using the experimental policy mechanism in all active release lines: v16, v18 and, v20.  Please note that at the time this CVE was issued, the policy is an experimental feature of Node.js",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-30581",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "perl",
            "featureversion": "5.32.1-4+deb11u2",
            "vulnerability": "CVE-2011-4116",
            "namespace": "debian:11",
            "description": "_is_safe in the File::Temp module for Perl does not properly handle symlinks.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2011-4116",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "openssh",
            "featureversion": "1:8.4p1-5+deb11u1",
            "vulnerability": "CVE-2023-48795",
            "namespace": "debian:11",
            "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-48795",
            "severity": "Negligible",
            "fixedby": "1:8.4p1-5+deb11u3"
        },
        {
            "featurename": "nodejs",
            "featureversion": "20.12.0-1nodesource1",
            "vulnerability": "CVE-2024-22019",
            "namespace": "debian:11",
            "description": "A vulnerability in Node.js HTTP servers allows an attacker to send a specially crafted HTTP request with chunked encoding, leading to resource exhaustion and denial of service (DoS). The server reads an unbounded number of bytes from a single connection, exploiting the lack of limitations on chunk extension bytes. The issue can cause CPU and network bandwidth exhaustion, bypassing standard safeguards like timeouts and body size limits.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-22019",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "gnupg2",
            "featureversion": "2.2.27-2+deb11u2",
            "vulnerability": "CVE-2022-3219",
            "namespace": "debian:11",
            "description": "GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-3219",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "libgcrypt20",
            "featureversion": "1.8.7-6",
            "vulnerability": "CVE-2018-6829",
            "namespace": "debian:11",
            "description": "cipher/elgamal.c in Libgcrypt through 1.8.2, when used to encrypt messages directly, improperly encodes plaintexts, which allows attackers to obtain sensitive information by reading ciphertext data (i.e., it does not have semantic security in face of a ciphertext-only attack). The Decisional Diffie-Hellman (DDH) assumption does not hold for Libgcrypt's ElGamal implementation.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2018-6829",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "python3.9",
            "featureversion": "3.9.2-1",
            "vulnerability": "CVE-2023-6597",
            "namespace": "debian:11",
            "description": "An issue was found in the CPython `tempfile.TemporaryDirectory` class affecting versions 3.12.2, 3.11.8, 3.10.13, 3.9.18, and 3.8.18 and prior.  The tempfile.TemporaryDirectory class would dereference symlinks during cleanup of permissions-related errors. This means users which can run privileged programs are potentially able to modify permissions of files referenced by symlinks in some circumstances.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-6597",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "sqlite3",
            "featureversion": "3.34.1-3",
            "vulnerability": "CVE-2021-45346",
            "namespace": "debian:11",
            "description": "A Memory Leak vulnerability exists in SQLite Project SQLite3 3.35.1 and 3.37.0 via maliciously crafted SQL Queries (made via editing the Database File), it is possible to query a record, and leak subsequent bytes of memory that extend beyond the record, which could let a malicious user obtain sensitive information. NOTE: The developer disputes this as a vulnerability stating that If you give SQLite a corrupted database file and submit a query against the database, it might read parts of the database that you did not intend or expect.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-45346",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "python3.9",
            "featureversion": "3.9.2-1",
            "vulnerability": "CVE-2022-37454",
            "namespace": "debian:11",
            "description": "The Keccak XKCP SHA-3 reference implementation before fdc6fef has an integer overflow and resultant buffer overflow that allows attackers to execute arbitrary code or eliminate expected cryptographic properties. This occurs in the sponge function interface.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-37454",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "python3.9",
            "featureversion": "3.9.2-1",
            "vulnerability": "CVE-2020-27619",
            "namespace": "debian:11",
            "description": "In Python 3 through 3.9.0, the Lib/test/multibytecodec_support.py CJK codec tests call eval() on content retrieved via HTTP.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-27619",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "python3.9",
            "featureversion": "3.9.2-1",
            "vulnerability": "CVE-2022-42919",
            "namespace": "debian:11",
            "description": "Python 3.9.x before 3.9.16 and 3.10.x before 3.10.9 on Linux allows local privilege escalation in a non-default configuration. The Python multiprocessing library, when used with the forkserver start method on Linux, allows pickles to be deserialized from any user in the same machine local network namespace, which in many system configurations means any user on the same machine. Pickles can execute arbitrary code. Thus, this allows for local user privilege escalation to the user that any forkserver process is running as. Setting multiprocessing.util.abstract_sockets_supported to False is a workaround. The forkserver start method for multiprocessing is not the default start method. This issue is Linux specific because only Linux supports abstract namespace sockets. CPython before 3.9 does not make use of Linux abstract namespace sockets by default. Support for users manually specifying an abstract namespace socket was added as a bugfix in 3.7.8 and 3.8.3, but users would need to make specific uncommon API calls in order to do that in CPython before 3.9.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-42919",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "pcre2",
            "featureversion": "10.36-2+deb11u1",
            "vulnerability": "CVE-2022-41409",
            "namespace": "debian:11",
            "description": "Integer overflow vulnerability in pcre2test before 10.41 allows attackers to cause a denial of service or other unspecified impacts via negative input.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-41409",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "apr",
            "featureversion": "1.7.0-6+deb11u1",
            "vulnerability": "CVE-2022-24963",
            "namespace": "debian:11",
            "description": "Integer Overflow or Wraparound vulnerability in apr_encode functions of Apache Portable Runtime (APR) allows an attacker to write beyond bounds of a buffer. This issue affects Apache Portable Runtime (APR) version 1.7.0.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-24963",
            "severity": "Negligible",
            "fixedby": "1.7.0-6+deb11u2"
        },
        {
            "featurename": "m4",
            "featureversion": "1.4.18-5",
            "vulnerability": "CVE-2008-1688",
            "namespace": "debian:11",
            "description": "Unspecified vulnerability in GNU m4 before 1.4.11 might allow context-dependent attackers to execute arbitrary code, related to improper handling of filenames specified with the -F option.  NOTE: it is not clear when this issue crosses privilege boundaries.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2008-1688",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "m4",
            "featureversion": "1.4.18-5",
            "vulnerability": "CVE-2008-1687",
            "namespace": "debian:11",
            "description": "The (1) maketemp and (2) mkstemp builtin functions in GNU m4 before 1.4.11 do not quote their output when a file is created, which might allow context-dependent attackers to trigger a macro expansion, leading to unspecified use of an incorrect filename.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2008-1687",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "python3.9",
            "featureversion": "3.9.2-1",
            "vulnerability": "CVE-2021-3426",
            "namespace": "debian:11",
            "description": "There's a flaw in Python 3's pydoc. A local or adjacent attacker who discovers or is able to convince another local or adjacent user to start a pydoc server could access the server and use it to disclose sensitive information belonging to the other user that they would not normally be able to access. The highest risk of this flaw is to data confidentiality. This flaw affects Python versions before 3.8.9, Python versions before 3.9.3 and Python versions before 3.10.0a7.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-3426",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "python3.9",
            "featureversion": "3.9.2-1",
            "vulnerability": "CVE-2021-4189",
            "namespace": "debian:11",
            "description": "A flaw was found in Python, specifically in the FTP (File Transfer Protocol) client library in PASV (passive) mode. The issue is how the FTP client trusts the host from the PASV response by default. This flaw allows an attacker to set up a malicious FTP server that can trick FTP clients into connecting back to a given IP address and port. This vulnerability could lead to FTP client scanning ports, which otherwise would not have been possible.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-4189",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "python3.9",
            "featureversion": "3.9.2-1",
            "vulnerability": "CVE-2021-28861",
            "namespace": "debian:11",
            "description": "Python 3.x through 3.10 has an open redirection vulnerability in lib/http/server.py due to no protection against multiple (/) at the beginning of URI path which may leads to information disclosure. NOTE: this is disputed by a third party because the http.server.html documentation page states \"Warning: http.server is not recommended for production. It only implements basic security checks.\"",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-28861",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "krb5",
            "featureversion": "1.18.3-6+deb11u3",
            "vulnerability": "CVE-2018-5709",
            "namespace": "debian:11",
            "description": "An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable \"dbentry-\u003en_key_data\" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a \"u4\" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2018-5709",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "sqlite3",
            "featureversion": "3.34.1-3",
            "vulnerability": "CVE-2022-35737",
            "namespace": "debian:11",
            "description": "SQLite 1.0.12 through 3.39.x before 3.39.2 sometimes allows an array-bounds overflow if billions of bytes are used in a string argument to a C API.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-35737",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "util-linux",
            "featureversion": "2.36.1-8+deb11u1",
            "vulnerability": "CVE-2022-0563",
            "namespace": "debian:11",
            "description": "A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an \"INPUTRC\" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-0563",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2019-19378",
            "namespace": "debian:11",
            "description": "In the Linux kernel 5.0.21, mounting a crafted btrfs filesystem image can lead to slab-out-of-bounds write access in index_rbio_pages in fs/btrfs/raid56.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-19378",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u3",
            "vulnerability": "CVE-2024-2379",
            "namespace": "debian:11",
            "description": "libcurl skips the certificate verification for a QUIC connection under certain conditions, when built to use wolfSSL. If told to use an unknown/bad cipher or curve, the error path accidentally skips the verification and returns OK, thus ignoring any certificate problems.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-2379",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u3",
            "vulnerability": "CVE-2023-46219",
            "namespace": "debian:11",
            "description": "When saving HSTS data to an excessively long file name, curl could end up removing all contents, making subsequent requests using that file unaware of the HSTS status they should otherwise use.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-46219",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u3",
            "vulnerability": "CVE-2023-23914",
            "namespace": "debian:11",
            "description": "A cleartext transmission of sensitive information vulnerability exists in curl \u003cv7.88.0 that could cause HSTS functionality fail when multiple URLs are requested serially. Using its HSTS support, curl can be instructed to use HTTPS instead of usingan insecure clear-text HTTP step even when HTTP is provided in the URL. ThisHSTS mechanism would however surprisingly be ignored by subsequent transferswhen done on the same command line because the state would not be properlycarried on.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-23914",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u3",
            "vulnerability": "CVE-2023-23915",
            "namespace": "debian:11",
            "description": "A cleartext transmission of sensitive information vulnerability exists in curl \u003cv7.88.0 that could cause HSTS functionality to behave incorrectly when multiple URLs are requested in parallel. Using its HSTS support, curl can be instructed to use HTTPS instead of using an insecure clear-text HTTP step even when HTTP is provided in the URL. This HSTS mechanism would however surprisingly fail when multiple transfers are done in parallel as the HSTS cache file gets overwritten by the most recentlycompleted transfer. A later HTTP-only transfer to the earlier host name would then *not* get upgraded properly to HSTS.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-23915",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u3",
            "vulnerability": "CVE-2023-28320",
            "namespace": "debian:11",
            "description": "A denial of service vulnerability exists in curl \u003cv8.1.0 in the way libcurl provides several different backends for resolving host names, selected at build time. If it is built to use the synchronous resolver, it allows name resolves to time-out slow operations using `alarm()` and `siglongjmp()`. When doing this, libcurl used a global buffer that was not mutex protected and a multi-threaded application might therefore crash or otherwise misbehave.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-28320",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2007-3719",
            "namespace": "debian:11",
            "description": "The process scheduler in the Linux kernel 2.6.16 gives preference to \"interactive\" processes that perform voluntary sleeps, which allows local users to cause a denial of service (CPU consumption), as described in \"Secretly Monopolizing the CPU Without Superuser Privileges.\"",
            "link": "https://security-tracker.debian.org/tracker/CVE-2007-3719",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u3",
            "vulnerability": "CVE-2021-22923",
            "namespace": "debian:11",
            "description": "When curl is instructed to get content using the metalink feature, and a user name and password are used to download the metalink XML file, those same credentials are then subsequently passed on to each of the servers from which curl will download or try to download the contents from. Often contrary to the user's expectations and intentions and without telling the user it happened.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-22923",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u3",
            "vulnerability": "CVE-2023-38545",
            "namespace": "debian:11",
            "description": "This flaw makes curl overflow a heap based buffer in the SOCKS5 proxy handshake.  When curl is asked to pass along the host name to the SOCKS5 proxy to allow that to resolve the address instead of it getting done by curl itself, the maximum length that host name can be is 255 bytes.  If the host name is detected to be longer, curl switches to local name resolving and instead passes on the resolved address only. Due to this bug, the local variable that means \"let the host resolve the name\" could get the wrong value during a slow SOCKS5 handshake, and contrary to the intention, copy the too long host name to the target buffer instead of copying just the resolved address there.  The target buffer being a heap based buffer, and the host name coming from the URL that curl has been told to operate with.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-38545",
            "severity": "Negligible",
            "fixedby": "7.74.0-1.3+deb11u10"
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u3",
            "vulnerability": "CVE-2021-22922",
            "namespace": "debian:11",
            "description": "When curl is instructed to download content using the metalink feature, thecontents is verified against a hash provided in the metalink XML file.The metalink XML file points out to the client how to get the same contentfrom a set of different URLs, potentially hosted by different servers and theclient can then download the file from one or several of them. In a serial orparallel manner.If one of the servers hosting the contents has been breached and the contentsof the specific file on that server is replaced with a modified payload, curlshould detect this when the hash of the file mismatches after a completeddownload. It should remove the contents and instead try getting the contentsfrom another URL. This is not done, and instead such a hash mismatch is onlymentioned in text and the potentially malicious content is kept in the file ondisk.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-22922",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26601",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  ext4: regenerate buddy after block freeing failed if under fc replay  This mostly reverts commit 6bd97bf273bd (\"ext4: remove redundant mb_regenerate_buddy()\") and reintroduces mb_regenerate_buddy(). Based on code in mb_free_blocks(), fast commit replay can end up marking as free blocks that are already marked as such. This causes corruption of the buddy bitmap so we need to regenerate it in that case.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26601",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u3",
            "vulnerability": "CVE-2022-43551",
            "namespace": "debian:11",
            "description": "A vulnerability exists in curl \u003c7.87.0 HSTS check that could be bypassed to trick it to keep using HTTP. Using its HSTS support, curl can be instructed to use HTTPS instead of using an insecure clear-text HTTP step even when HTTP is provided in the URL. However, the HSTS mechanism could be bypassed if the host name in the given URL first uses IDN characters that get replaced to ASCII counterparts as part of the IDN conversion. Like using the character UTF-8 U+3002 (IDEOGRAPHIC FULL STOP) instead of the common ASCII full stop (U+002E) `.`. Then in a subsequent request, it does not detect the HSTS state and makes a clear text transfer. Because it would store the info IDN encoded but look for it IDN decoded.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-43551",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u3",
            "vulnerability": "CVE-2022-42916",
            "namespace": "debian:11",
            "description": "In curl before 7.86.0, the HSTS check could be bypassed to trick it into staying with HTTP. Using its HSTS support, curl can be instructed to use HTTPS directly (instead of using an insecure cleartext HTTP step) even when HTTP is provided in the URL. This mechanism could be bypassed if the host name in the given URL uses IDN characters that get replaced with ASCII counterparts as part of the IDN conversion, e.g., using the character UTF-8 U+3002 (IDEOGRAPHIC FULL STOP) instead of the common ASCII full stop of U+002E (.). The earliest affected version is 7.77.0 2021-05-26.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-42916",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-24860",
            "namespace": "debian:11",
            "description": "A race condition was found in the Linux kernel's bluetooth device driver in {min,max}_key_size_set() function. This can result in a null pointer dereference issue, possibly leading to a kernel panic or denial of service issue.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-24860",
            "severity": "Negligible",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2019-12382",
            "namespace": "debian:11",
            "description": "An issue was discovered in drm_load_edid_firmware in drivers/gpu/drm/drm_edid_load.c in the Linux kernel through 5.1.5. There is an unchecked kstrdup of fwstr, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: The vendor disputes this issues as not being a vulnerability because kstrdup() returning NULL is handled sufficiently and there is no chance for a NULL pointer dereference",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-12382",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-0240",
            "namespace": "debian:11",
            "description": "There is a logic error in io_uring's implementation which can be used to trigger a use-after-free vulnerability leading to privilege escalation.  In the io_prep_async_work function the assumption that the last io_grab_identity call cannot return false is not true, and in this case the function will use the init_cred or the previous linked requests identity to do operations instead of using the current identity. This can lead to reference counting issues causing use-after-free. We recommend upgrading past version 5.10.161.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-0240",
            "severity": "Negligible",
            "fixedby": "5.10.162-1"
        },
        {
            "featurename": "shadow",
            "featureversion": "1:4.8.1-1",
            "vulnerability": "CVE-2007-5686",
            "namespace": "debian:11",
            "description": "initscripts in rPath Linux 1 sets insecure permissions for the /var/log/btmp file, which allows local users to obtain sensitive information regarding authentication attempts.  NOTE: because sshd detects the insecure permissions and does not log certain events, this also prevents sshd from logging failed authentication attempts by remote attackers.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2007-5686",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "shadow",
            "featureversion": "1:4.8.1-1",
            "vulnerability": "CVE-2013-4235",
            "namespace": "debian:11",
            "description": "shadow: TOCTOU (time-of-check time-of-use) race condition when copying and removing directory trees",
            "link": "https://security-tracker.debian.org/tracker/CVE-2013-4235",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "shadow",
            "featureversion": "1:4.8.1-1",
            "vulnerability": "CVE-2019-19882",
            "namespace": "debian:11",
            "description": "shadow 4.8, in certain circumstances affecting at least Gentoo, Arch Linux, and Void Linux, allows local users to obtain root access because setuid programs are misconfigured. Specifically, this affects shadow 4.8 when compiled using --with-libpam but without explicitly passing --disable-account-tools-setuid, and without a PAM configuration suitable for use with setuid account management tools. This combination leads to account management tools (groupadd, groupdel, groupmod, useradd, userdel, usermod) that can easily be used by unprivileged local users to escalate privileges to root in multiple ways. This issue became much more relevant in approximately December 2019 when an unrelated bug was fixed (i.e., the chmod calls to suidusbins were fixed in the upstream Makefile which is now included in the release version 4.8).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-19882",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "apt",
            "featureversion": "2.2.4",
            "vulnerability": "CVE-2011-3374",
            "namespace": "debian:11",
            "description": "It was found that apt-key in apt, all versions, do not correctly validate gpg keys with the master keyring, leading to a potential man-in-the-middle attack.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2011-3374",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-1247",
            "namespace": "debian:11",
            "description": "An issue found in linux-kernel that leads to a race condition in rose_connect(). The rose driver uses rose_neigh-\u003euse to represent how many objects are using the rose_neigh. When a user wants to delete a rose_route via rose_ioctl(), the rose driver calls rose_del_node() and removes neighbours only if their “count” and “use” are zero.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-1247",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "db5.3",
            "featureversion": "5.3.28+dfsg1-0.8",
            "vulnerability": "CVE-2019-8457",
            "namespace": "debian:11",
            "description": "SQLite3 from 3.6.0 to and including 3.27.2 is vulnerable to heap out-of-bound read in the rtreenode() function when handling invalid rtree tables.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-8457",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "glibc",
            "featureversion": "2.31-13+deb11u5",
            "vulnerability": "CVE-2023-4911",
            "namespace": "debian:11",
            "description": "A buffer overflow was discovered in the GNU C Library's dynamic loader ld.so while processing the GLIBC_TUNABLES environment variable. This issue could allow a local attacker to use maliciously crafted GLIBC_TUNABLES environment variables when launching binaries with SUID permission to execute code with elevated privileges.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4911",
            "severity": "Negligible",
            "fixedby": "2.31-13+deb11u7"
        },
        {
            "featurename": "glibc",
            "featureversion": "2.31-13+deb11u5",
            "vulnerability": "CVE-2010-4756",
            "namespace": "debian:11",
            "description": "The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2010-4756",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "sqlite3",
            "featureversion": "3.34.1-3",
            "vulnerability": "CVE-2021-31239",
            "namespace": "debian:11",
            "description": "An issue found in SQLite SQLite3 v.3.35.4 that allows a remote attacker to cause a denial of service via the appendvfs.c function.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-31239",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-3777",
            "namespace": "debian:11",
            "description": "A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation.  When nf_tables_delrule() is flushing table rules, it is not checked whether the chain is bound and the chain's owner rule can also release the objects in certain circumstances.  We recommend upgrading past commit 6eaf41e87a223ae6f8e7a28d6e78384ad7e407f8.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3777",
            "severity": "Negligible",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "glibc",
            "featureversion": "2.31-13+deb11u5",
            "vulnerability": "CVE-2019-9192",
            "namespace": "debian:11",
            "description": "In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\\\1\\\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-9192",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "glibc",
            "featureversion": "2.31-13+deb11u5",
            "vulnerability": "CVE-2018-20796",
            "namespace": "debian:11",
            "description": "In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\\227|)(\\\\1\\\\1|t1|\\\\\\2537)+' in grep.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2018-20796",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52524",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  net: nfc: llcp: Add lock when modifying device list  The device list needs its associated lock held when modifying it, or the list could become corrupted, as syzbot discovered.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52524",
            "severity": "Negligible",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "glibc",
            "featureversion": "2.31-13+deb11u5",
            "vulnerability": "CVE-2019-1010025",
            "namespace": "debian:11",
            "description": "GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor's position is \"ASLR bypass itself is not a vulnerability.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-1010025",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "glibc",
            "featureversion": "2.31-13+deb11u5",
            "vulnerability": "CVE-2019-1010024",
            "namespace": "debian:11",
            "description": "GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate \"this is being treated as a non-security bug and no real threat.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-1010024",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2019-12455",
            "namespace": "debian:11",
            "description": "An issue was discovered in sunxi_divs_clk_setup in drivers/clk/sunxi/clk-sunxi.c in the Linux kernel through 5.1.5. There is an unchecked kstrndup of derived_name, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: This id is disputed as not being an issue because “The memory allocation that was not checked is part of a code that only runs at boot time, before user processes are started. Therefore, there is no possibility for an unprivileged user to control it, and no denial of service.”",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-12455",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "glibc",
            "featureversion": "2.31-13+deb11u5",
            "vulnerability": "CVE-2019-1010022",
            "namespace": "debian:11",
            "description": "GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate \"this is being treated as a non-security bug and no real threat.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-1010022",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "glibc",
            "featureversion": "2.31-13+deb11u5",
            "vulnerability": "CVE-2019-1010023",
            "namespace": "debian:11",
            "description": "GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate \"this is being treated as a non-security bug and no real threat.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-1010023",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "glib2.0",
            "featureversion": "2.66.8-1",
            "vulnerability": "CVE-2012-0039",
            "namespace": "debian:11",
            "description": "GLib 2.31.8 and earlier, when the g_str_hash function is used, computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table. NOTE: this issue may be disputed by the vendor; the existence of the g_str_hash function is not a vulnerability in the library, because callers of g_hash_table_new and g_hash_table_new_full can specify an arbitrary hash function that is appropriate for the application.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2012-0039",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "nghttp2",
            "featureversion": "1.43.0-1",
            "vulnerability": "CVE-2023-44487",
            "namespace": "debian:11",
            "description": "The HTTP/2 protocol allows a denial of service (server resource consumption) because request cancellation can reset many streams quickly, as exploited in the wild in August through October 2023.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-44487",
            "severity": "Negligible",
            "fixedby": "1.43.0-1+deb11u1"
        },
        {
            "featurename": "openldap",
            "featureversion": "2.4.57+dfsg-3+deb11u1",
            "vulnerability": "CVE-2015-3276",
            "namespace": "debian:11",
            "description": "The nss_parse_ciphers function in libraries/libldap/tls_m.c in OpenLDAP does not properly parse OpenSSL-style multi-keyword mode cipher strings, which might cause a weaker than intended cipher to be used and allow remote attackers to have unspecified impact via unknown vectors.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2015-3276",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "openldap",
            "featureversion": "2.4.57+dfsg-3+deb11u1",
            "vulnerability": "CVE-2020-15719",
            "namespace": "debian:11",
            "description": "libldap in certain third-party OpenLDAP packages has a certificate-validation flaw when the third-party package is asserting RFC6125 support. It considers CN even when there is a non-matching subjectAltName (SAN). This is fixed in, for example, openldap-2.4.46-10.el8 in Red Hat Enterprise Linux.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-15719",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "openldap",
            "featureversion": "2.4.57+dfsg-3+deb11u1",
            "vulnerability": "CVE-2017-14159",
            "namespace": "debian:11",
            "description": "slapd in OpenLDAP 2.4.45 and earlier creates a PID file after dropping privileges to a non-root account, which might allow local users to kill arbitrary processes by leveraging access to this non-root account for PID file modification before a root script executes a \"kill `cat /pathname`\" command, as demonstrated by openldap-initscript.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2017-14159",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "openldap",
            "featureversion": "2.4.57+dfsg-3+deb11u1",
            "vulnerability": "CVE-2017-17740",
            "namespace": "debian:11",
            "description": "contrib/slapd-modules/nops/nops.c in OpenLDAP through 2.4.45, when both the nops module and the memberof overlay are enabled, attempts to free a buffer that was allocated on the stack, which allows remote attackers to cause a denial of service (slapd crash) via a member MODDN operation.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2017-17740",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "coreutils",
            "featureversion": "8.32-4",
            "vulnerability": "CVE-2017-18018",
            "namespace": "debian:11",
            "description": "In GNU Coreutils through 8.29, chown-core.c in chown and chgrp does not prevent replacement of a plain file with a symlink during use of the POSIX \"-R -L\" options, which allows local users to modify the ownership of arbitrary files by leveraging a race condition.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2017-18018",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "sqlite3",
            "featureversion": "3.34.1-3",
            "vulnerability": "CVE-2021-36690",
            "namespace": "debian:11",
            "description": "A segmentation fault can occur in the sqlite3.exe command-line component of SQLite 3.36.0 via the idxGetTableInfo function when there is a crafted SQL query. NOTE: the vendor disputes the relevance of this report because a sqlite3.exe user already has full privileges (e.g., is intentionally allowed to execute commands). This report does NOT imply any problem in the SQLite library.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-36690",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "gnutls28",
            "featureversion": "3.7.1-5+deb11u2",
            "vulnerability": "CVE-2024-0567",
            "namespace": "debian:11",
            "description": "A vulnerability was found in GnuTLS, where a cockpit (which uses gnuTLS) rejects a certificate chain with distributed trust. This issue occurs when validating a certificate chain with cockpit-certificate-ensure. This flaw allows an unauthenticated, remote client or attacker to initiate a denial of service attack.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-0567",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-2961",
            "namespace": "debian:11",
            "description": "A use-after-free flaw was found in the Linux kernel’s PLP Rose functionality in the way a user triggers a race condition by calling bind while simultaneously triggering the rose_bind() function. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-2961",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "gnutls28",
            "featureversion": "3.7.1-5+deb11u2",
            "vulnerability": "CVE-2011-3389",
            "namespace": "debian:11",
            "description": "The SSL protocol, as used in certain configurations in Microsoft Windows and Microsoft Internet Explorer, Mozilla Firefox, Google Chrome, Opera, and other products, encrypts data by using CBC mode with chained initialization vectors, which allows man-in-the-middle attackers to obtain plaintext HTTP headers via a blockwise chosen-boundary attack (BCBA) on an HTTPS session, in conjunction with JavaScript code that uses (1) the HTML5 WebSocket API, (2) the Java URLConnection API, or (3) the Silverlight WebClient API, aka a \"BEAST\" attack.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2011-3389",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-45884",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvbdev.c has a use-after-free, related to dvb_register_device dynamically allocating fops.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-45884",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "openssh",
            "featureversion": "1:8.4p1-5+deb11u1",
            "vulnerability": "CVE-2007-2243",
            "namespace": "debian:11",
            "description": "OpenSSH 4.6 and earlier, when ChallengeResponseAuthentication is enabled, allows remote attackers to determine the existence of user accounts by attempting to authenticate via S/KEY, which displays a different response if the user account exists, a similar issue to CVE-2001-1483.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2007-2243",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "bash",
            "featureversion": "5.1-2+deb11u1",
            "vulnerability": "CVE-2022-3715",
            "namespace": "debian:11",
            "description": "A flaw was found in the bash package, where a heap-buffer overflow can occur in valid parameter_transform. This issue may lead to memory problems.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-3715",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "systemd",
            "featureversion": "247.3-7+deb11u1",
            "vulnerability": "CVE-2013-4392",
            "namespace": "debian:11",
            "description": "systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2013-4392",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "systemd",
            "featureversion": "247.3-7+deb11u1",
            "vulnerability": "CVE-2023-31439",
            "namespace": "debian:11",
            "description": "An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-31439",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "systemd",
            "featureversion": "247.3-7+deb11u1",
            "vulnerability": "CVE-2020-13529",
            "namespace": "debian:11",
            "description": "An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-13529",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52467",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  mfd: syscon: Fix null pointer dereference in of_syscon_register()  kasprintf() returns a pointer to dynamically allocated memory which can be NULL upon failure.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52467",
            "severity": "Negligible",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "systemd",
            "featureversion": "247.3-7+deb11u1",
            "vulnerability": "CVE-2023-31438",
            "namespace": "debian:11",
            "description": "An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-31438",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52489",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  mm/sparsemem: fix race in accessing memory_section-\u003eusage  The below race is observed on a PFN which falls into the device memory region with the system memory configuration where PFN's are such that [ZONE_NORMAL ZONE_DEVICE ZONE_NORMAL].  Since normal zone start and end pfn contains the device memory PFN's as well, the compaction triggered will try on the device memory PFN's too though they end up in NOP(because pfn_to_online_page() returns NULL for ZONE_DEVICE memory sections).  When from other core, the section mappings are being removed for the ZONE_DEVICE region, that the PFN in question belongs to, on which compaction is currently being operated is resulting into the kernel crash with CONFIG_SPASEMEM_VMEMAP enabled.  The crash logs can be seen at [1].  compact_zone()\t\t\tmemunmap_pages -------------\t\t\t--------------- __pageblock_pfn_to_page    ......  (a)pfn_valid():      valid_section()//return true \t\t\t      (b)__remove_pages()-\u003e \t\t\t\t  sparse_remove_section()-\u003e \t\t\t\t    section_deactivate(): \t\t\t\t    [Free the array ms-\u003eusage and set \t\t\t\t     ms-\u003eusage = NULL]      pfn_section_valid()      [Access ms-\u003eusage which      is NULL]  NOTE: From the above it can be said that the race is reduced to between the pfn_valid()/pfn_section_valid() and the section deactivate with SPASEMEM_VMEMAP enabled.  The commit b943f045a9af(\"mm/sparse: fix kernel crash with pfn_section_valid check\") tried to address the same problem by clearing the SECTION_HAS_MEM_MAP with the expectation of valid_section() returns false thus ms-\u003eusage is not accessed.  Fix this issue by the below steps:  a) Clear SECTION_HAS_MEM_MAP before freeing the -\u003eusage.  b) RCU protected read side critical section will either return NULL    when SECTION_HAS_MEM_MAP is cleared or can successfully access -\u003eusage.  c) Free the -\u003eusage with kfree_rcu() and set ms-\u003eusage = NULL.  No    attempt will be made to access -\u003eusage after this as the    SECTION_HAS_MEM_MAP is cleared thus valid_section() return false.  Thanks to David/Pavan for their inputs on this patch.  [1] https://lore.kernel.org/linux-mm/994410bb-89aa-d987-1f50-f514903c55aa@quicinc.com/  On Snapdragon SoC, with the mentioned memory configuration of PFN's as [ZONE_NORMAL ZONE_DEVICE ZONE_NORMAL], we are able to see bunch of issues daily while testing on a device farm.  For this particular issue below is the log.  Though the below log is not directly pointing to the pfn_section_valid(){ ms-\u003eusage;}, when we loaded this dump on T32 lauterbach tool, it is pointing.  [  540.578056] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000 [  540.578068] Mem abort info: [  540.578070]   ESR = 0x0000000096000005 [  540.578073]   EC = 0x25: DABT (current EL), IL = 32 bits [  540.578077]   SET = 0, FnV = 0 [  540.578080]   EA = 0, S1PTW = 0 [  540.578082]   FSC = 0x05: level 1 translation fault [  540.578085] Data abort info: [  540.578086]   ISV = 0, ISS = 0x00000005 [  540.578088]   CM = 0, WnR = 0 [  540.579431] pstate: 82400005 (Nzcv daif +PAN -UAO +TCO -DIT -SSBSBTYPE=--) [  540.579436] pc : __pageblock_pfn_to_page+0x6c/0x14c [  540.579454] lr : compact_zone+0x994/0x1058 [  540.579460] sp : ffffffc03579b510 [  540.579463] x29: ffffffc03579b510 x28: 0000000000235800 x27:000000000000000c [  540.579470] x26: 0000000000235c00 x25: 0000000000000068 x24:ffffffc03579b640 [  540.579477] x23: 0000000000000001 x22: ffffffc03579b660 x21:0000000000000000 [  540.579483] x20: 0000000000235bff x19: ffffffdebf7e3940 x18:ffffffdebf66d140 [  540.579489] x17: 00000000739ba063 x16: 00000000739ba063 x15:00000000009f4bff [  540.579495] x14: 0000008000000000 x13: 0000000000000000 x12:0000000000000001 [  540.579501] x11: 0000000000000000 x10: 0000000000000000 x9 :ffffff897d2cd440 [  540.579507] x8 : 0000000000000000 x7 : 0000000000000000 x6 :ffffffc03579b5b4 [  540.579512] x5 : 0000000000027f25 x4 : ffffffc03579b5b8 x3 :0000000000000 ---truncated---",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52489",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2021-47028",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  mt76: mt7915: fix txrate reporting  Properly check rate_info to fix unexpected reporting.  [ 1215.161863] Call trace: [ 1215.164307]  cfg80211_calculate_bitrate+0x124/0x200 [cfg80211] [ 1215.170139]  ieee80211s_update_metric+0x80/0xc0 [mac80211] [ 1215.175624]  ieee80211_tx_status_ext+0x508/0x838 [mac80211] [ 1215.181190]  mt7915_mcu_get_rx_rate+0x28c/0x8d0 [mt7915e] [ 1215.186580]  mt7915_mac_tx_free+0x324/0x7c0 [mt7915e] [ 1215.191623]  mt7915_queue_rx_skb+0xa8/0xd0 [mt7915e] [ 1215.196582]  mt76_dma_cleanup+0x7b0/0x11d0 [mt76] [ 1215.201276]  __napi_poll+0x38/0xf8 [ 1215.204668]  napi_workfn+0x40/0x80 [ 1215.208062]  process_one_work+0x1fc/0x390 [ 1215.212062]  worker_thread+0x48/0x4d0 [ 1215.215715]  kthread+0x120/0x128 [ 1215.218935]  ret_from_fork+0x10/0x1c",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-47028",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-2196",
            "namespace": "debian:11",
            "description": "A regression exists in the Linux Kernel within KVM: nVMX that allowed for speculative execution attacks. L2 can carry out Spectre v2 attacks on L1 due to L1 thinking it doesn't need retpolines or IBPB after running L2 due to KVM (L0) advertising eIBRS support to L1. An attacker at L2 with code execution can execute code on an indirect branch on the host machine. We recommend upgrading to Kernel 6.2 or past commit 2e7eab81425a",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-2196",
            "severity": "Negligible",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26627",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: core: Move scsi_host_busy() out of host lock for waking up EH handler  Inside scsi_eh_wakeup(), scsi_host_busy() is called \u0026 checked with host lock every time for deciding if error handler kthread needs to be waken up.  This can be too heavy in case of recovery, such as:   - N hardware queues   - queue depth is M for each hardware queue   - each scsi_host_busy() iterates over (N * M) tag/requests  If recovery is triggered in case that all requests are in-flight, each scsi_eh_wakeup() is strictly serialized, when scsi_eh_wakeup() is called for the last in-flight request, scsi_host_busy() has been run for (N * M - 1) times, and request has been iterated for (N*M - 1) * (N * M) times.  If both N and M are big enough, hard lockup can be triggered on acquiring host lock, and it is observed on mpi3mr(128 hw queues, queue depth 8169).  Fix the issue by calling scsi_host_busy() outside the host lock. We don't need the host lock for getting busy count because host the lock never covers that.  [mkp: Drop unnecessary 'busy' variables pointed out by Bart]",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26627",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-23039",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 6.2.0-rc2. drivers/tty/vcc.c has a race condition and resultant use-after-free if a physically proximate attacker removes a VCC device while calling open(), aka a race condition between vcc_open() and vcc_remove().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-23039",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "systemd",
            "featureversion": "247.3-7+deb11u1",
            "vulnerability": "CVE-2023-31437",
            "namespace": "debian:11",
            "description": "An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-31437",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2021-46937",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  mm/damon/dbgfs: fix 'struct pid' leaks in 'dbgfs_target_ids_write()'  DAMON debugfs interface increases the reference counts of 'struct pid's for targets from the 'target_ids' file write callback ('dbgfs_target_ids_write()'), but decreases the counts only in DAMON monitoring termination callback ('dbgfs_before_terminate()').  Therefore, when 'target_ids' file is repeatedly written without DAMON monitoring start/termination, the reference count is not decreased and therefore memory for the 'struct pid' cannot be freed.  This commit fixes this issue by decreasing the reference counts when 'target_ids' is written.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-46937",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2021-47178",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: target: core: Avoid smp_processor_id() in preemptible code  The BUG message \"BUG: using smp_processor_id() in preemptible [00000000] code\" was observed for TCMU devices with kernel config DEBUG_PREEMPT.  The message was observed when blktests block/005 was run on TCMU devices with fileio backend or user:zbc backend [1]. The commit 1130b499b4a7 (\"scsi: target: tcm_loop: Use LIO wq cmd submission helper\") triggered the symptom. The commit modified work queue to handle commands and changed 'current-\u003enr_cpu_allowed' at smp_processor_id() call.  The message was also observed at system shutdown when TCMU devices were not cleaned up [2]. The function smp_processor_id() was called in SCSI host work queue for abort handling, and triggered the BUG message. This symptom was observed regardless of the commit 1130b499b4a7 (\"scsi: target: tcm_loop: Use LIO wq cmd submission helper\").  To avoid the preemptible code check at smp_processor_id(), get CPU ID with raw_smp_processor_id() instead. The CPU ID is used for performance improvement then thread move to other CPU will not affect the code.  [1]  [   56.468103] run blktests block/005 at 2021-05-12 14:16:38 [   57.369473] check_preemption_disabled: 85 callbacks suppressed [   57.369480] BUG: using smp_processor_id() in preemptible [00000000] code: fio/1511 [   57.369506] BUG: using smp_processor_id() in preemptible [00000000] code: fio/1510 [   57.369512] BUG: using smp_processor_id() in preemptible [00000000] code: fio/1506 [   57.369552] caller is __target_init_cmd+0x157/0x170 [target_core_mod] [   57.369606] CPU: 4 PID: 1506 Comm: fio Not tainted 5.13.0-rc1+ #34 [   57.369613] Hardware name: System manufacturer System Product Name/PRIME Z270-A, BIOS 1302 03/15/2018 [   57.369617] Call Trace: [   57.369621] BUG: using smp_processor_id() in preemptible [00000000] code: fio/1507 [   57.369628]  dump_stack+0x6d/0x89 [   57.369642]  check_preemption_disabled+0xc8/0xd0 [   57.369628] caller is __target_init_cmd+0x157/0x170 [target_core_mod] [   57.369655]  __target_init_cmd+0x157/0x170 [target_core_mod] [   57.369695]  target_init_cmd+0x76/0x90 [target_core_mod] [   57.369732]  tcm_loop_queuecommand+0x109/0x210 [tcm_loop] [   57.369744]  scsi_queue_rq+0x38e/0xc40 [   57.369761]  __blk_mq_try_issue_directly+0x109/0x1c0 [   57.369779]  blk_mq_try_issue_directly+0x43/0x90 [   57.369790]  blk_mq_submit_bio+0x4e5/0x5d0 [   57.369812]  submit_bio_noacct+0x46e/0x4e0 [   57.369830]  __blkdev_direct_IO_simple+0x1a3/0x2d0 [   57.369859]  ? set_init_blocksize.isra.0+0x60/0x60 [   57.369880]  generic_file_read_iter+0x89/0x160 [   57.369898]  blkdev_read_iter+0x44/0x60 [   57.369906]  new_sync_read+0x102/0x170 [   57.369929]  vfs_read+0xd4/0x160 [   57.369941]  __x64_sys_pread64+0x6e/0xa0 [   57.369946]  ? lockdep_hardirqs_on+0x79/0x100 [   57.369958]  do_syscall_64+0x3a/0x70 [   57.369965]  entry_SYSCALL_64_after_hwframe+0x44/0xae [   57.369973] RIP: 0033:0x7f7ed4c1399f [   57.369979] Code: 08 89 3c 24 48 89 4c 24 18 e8 7d f3 ff ff 4c 8b 54 24 18 48 8b 54 24 10 41 89 c0 48 8b 74 24 08 8b 3c 24 b8 11 00 00 00 0f 05 \u003c48\u003e 3d 00 f0 ff ff 77 31 44 89 c7 48 89 04 24 e8 cd f3 ff ff 48 8b [   57.369983] RSP: 002b:00007ffd7918c580 EFLAGS: 00000293 ORIG_RAX: 0000000000000011 [   57.369990] RAX: ffffffffffffffda RBX: 00000000015b4540 RCX: 00007f7ed4c1399f [   57.369993] RDX: 0000000000001000 RSI: 00000000015de000 RDI: 0000000000000009 [   57.369996] RBP: 00000000015b4540 R08: 0000000000000000 R09: 0000000000000001 [   57.369999] R10: 0000000000e5c000 R11: 0000000000000293 R12: 00007f7eb5269a70 [   57.370002] R13: 0000000000000000 R14: 0000000000001000 R15: 00000000015b4568 [   57.370031] CPU: 7 PID: 1507 Comm: fio Not tainted 5.13.0-rc1+ #34 [   57.370036] Hardware name: System manufacturer System Product Name/PRIME Z270-A, BIOS 1302 03/15/2018 [   57.370039] Call Trace: [   57.370045]  dump_stack+0x6d/0x89 [   57.370056]  ch ---truncated---",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-47178",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "expat",
            "featureversion": "2.2.10-2+deb11u5",
            "vulnerability": "CVE-2023-52426",
            "namespace": "debian:11",
            "description": "libexpat through 2.5.0 allows recursive XML Entity Expansion if XML_DTD is undefined at compile time.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52426",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2019-12378",
            "namespace": "debian:11",
            "description": "An issue was discovered in ip6_ra_control in net/ipv6/ipv6_sockglue.c in the Linux kernel through 5.1.5. There is an unchecked kmalloc of new_ra, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: This has been disputed as not an issue",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-12378",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52627",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  iio: adc: ad7091r: Allow users to configure device events  AD7091R-5 devices are supported by the ad7091r-5 driver together with the ad7091r-base driver. Those drivers declared iio events for notifying user space when ADC readings fall bellow the thresholds of low limit registers or above the values set in high limit registers. However, to configure iio events and their thresholds, a set of callback functions must be implemented and those were not present until now. The consequence of trying to configure ad7091r-5 events without the proper callback functions was a null pointer dereference in the kernel because the pointers to the callback functions were not set.  Implement event configuration callbacks allowing users to read/write event thresholds and enable/disable event generation.  Since the event spec structs are generic to AD7091R devices, also move those from the ad7091r-5 driver the base driver so they can be reused when support for ad7091r-2/-4/-8 be added.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52627",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2021-47176",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  s390/dasd: add missing discipline function  Fix crash with illegal operation exception in dasd_device_tasklet. Commit b72949328869 (\"s390/dasd: Prepare for additional path event handling\") renamed the verify_path function for ECKD but not for FBA and DIAG. This leads to a panic when the path verification function is called for a FBA or DIAG device.  Fix by defining a wrapper function for dasd_generic_verify_path().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-47176",
            "severity": "Negligible",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "openssh",
            "featureversion": "1:8.4p1-5+deb11u1",
            "vulnerability": "CVE-2020-14145",
            "namespace": "debian:11",
            "description": "The client side in OpenSSH 5.7 through 8.4 has an Observable Discrepancy leading to an information leak in the algorithm negotiation. This allows man-in-the-middle attackers to target initial connection attempts (where no host key for the server has been cached by the client). NOTE: some reports state that 8.5 and 8.6 are also affected.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-14145",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u11",
            "vulnerability": "CVE-2022-42916",
            "namespace": "debian:11",
            "description": "In curl before 7.86.0, the HSTS check could be bypassed to trick it into staying with HTTP. Using its HSTS support, curl can be instructed to use HTTPS directly (instead of using an insecure cleartext HTTP step) even when HTTP is provided in the URL. This mechanism could be bypassed if the host name in the given URL uses IDN characters that get replaced with ASCII counterparts as part of the IDN conversion, e.g., using the character UTF-8 U+3002 (IDEOGRAPHIC FULL STOP) instead of the common ASCII full stop of U+002E (.). The earliest affected version is 7.77.0 2021-05-26.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-42916",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-26242",
            "namespace": "debian:11",
            "description": "afu_mmio_region_get_by_offset in drivers/fpga/dfl-afu-region.c in the Linux kernel through 6.1.12 has an integer overflow.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-26242",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-5178",
            "namespace": "debian:11",
            "description": "A use-after-free vulnerability was found in drivers/nvme/target/tcp.c` in `nvmet_tcp_free_crypto` due to a logical bug in the NVMe/TCP subsystem in the Linux kernel. This issue may allow a malicious user to cause a use-after-free and double-free problem, which may permit remote code execution or lead to local privilege escalation.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-5178",
            "severity": "Negligible",
            "fixedby": "5.10.205-2"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2017-0630",
            "namespace": "debian:11",
            "description": "An information disclosure vulnerability in the kernel trace subsystem could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it first requires compromising a privileged process. Product: Android. Versions: Kernel-3.10, Kernel-3.18. Android ID: A-34277115.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2017-0630",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-42756",
            "namespace": "debian:11",
            "description": "A flaw was found in the Netfilter subsystem of the Linux kernel. A race condition between IPSET_CMD_ADD and IPSET_CMD_SWAP can lead to a kernel panic due to the invocation of `__ip_set_put` on a wrong `set`. This issue may allow a local user to crash the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-42756",
            "severity": "Negligible",
            "fixedby": "5.10.197-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2021-47037",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  ASoC: q6afe-clocks: fix reprobing of the driver  Q6afe-clocks driver can get reprobed. For example if the APR services are restarted after the firmware crash. However currently Q6afe-clocks driver will oops because hw.init will get cleared during first _probe call. Rewrite the driver to fill the clock data at runtime rather than using big static array of clocks.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-47037",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2019-16231",
            "namespace": "debian:11",
            "description": "drivers/net/fjes/fjes_main.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-16231",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52463",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  efivarfs: force RO when remounting if SetVariable is not supported  If SetVariable at runtime is not supported by the firmware we never assign a callback for that function. At the same time mount the efivarfs as RO so no one can call that.  However, we never check the permission flags when someone remounts the filesystem as RW. As a result this leads to a crash looking like this:  $ mount -o remount,rw /sys/firmware/efi/efivars $ efi-updatevar -f PK.auth PK  [  303.279166] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000 [  303.280482] Mem abort info: [  303.280854]   ESR = 0x0000000086000004 [  303.281338]   EC = 0x21: IABT (current EL), IL = 32 bits [  303.282016]   SET = 0, FnV = 0 [  303.282414]   EA = 0, S1PTW = 0 [  303.282821]   FSC = 0x04: level 0 translation fault [  303.283771] user pgtable: 4k pages, 48-bit VAs, pgdp=000000004258c000 [  303.284913] [0000000000000000] pgd=0000000000000000, p4d=0000000000000000 [  303.286076] Internal error: Oops: 0000000086000004 [#1] PREEMPT SMP [  303.286936] Modules linked in: qrtr tpm_tis tpm_tis_core crct10dif_ce arm_smccc_trng rng_core drm fuse ip_tables x_tables ipv6 [  303.288586] CPU: 1 PID: 755 Comm: efi-updatevar Not tainted 6.3.0-rc1-00108-gc7d0c4695c68 #1 [  303.289748] Hardware name: Unknown Unknown Product/Unknown Product, BIOS 2023.04-00627-g88336918701d 04/01/2023 [  303.291150] pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) [  303.292123] pc : 0x0 [  303.292443] lr : efivar_set_variable_locked+0x74/0xec [  303.293156] sp : ffff800008673c10 [  303.293619] x29: ffff800008673c10 x28: ffff0000037e8000 x27: 0000000000000000 [  303.294592] x26: 0000000000000800 x25: ffff000002467400 x24: 0000000000000027 [  303.295572] x23: ffffd49ea9832000 x22: ffff0000020c9800 x21: ffff000002467000 [  303.296566] x20: 0000000000000001 x19: 00000000000007fc x18: 0000000000000000 [  303.297531] x17: 0000000000000000 x16: 0000000000000000 x15: 0000aaaac807ab54 [  303.298495] x14: ed37489f673633c0 x13: 71c45c606de13f80 x12: 47464259e219acf4 [  303.299453] x11: ffff000002af7b01 x10: 0000000000000003 x9 : 0000000000000002 [  303.300431] x8 : 0000000000000010 x7 : ffffd49ea8973230 x6 : 0000000000a85201 [  303.301412] x5 : 0000000000000000 x4 : ffff0000020c9800 x3 : 00000000000007fc [  303.302370] x2 : 0000000000000027 x1 : ffff000002467400 x0 : ffff000002467000 [  303.303341] Call trace: [  303.303679]  0x0 [  303.303938]  efivar_entry_set_get_size+0x98/0x16c [  303.304585]  efivarfs_file_write+0xd0/0x1a4 [  303.305148]  vfs_write+0xc4/0x2e4 [  303.305601]  ksys_write+0x70/0x104 [  303.306073]  __arm64_sys_write+0x1c/0x28 [  303.306622]  invoke_syscall+0x48/0x114 [  303.307156]  el0_svc_common.constprop.0+0x44/0xec [  303.307803]  do_el0_svc+0x38/0x98 [  303.308268]  el0_svc+0x2c/0x84 [  303.308702]  el0t_64_sync_handler+0xf4/0x120 [  303.309293]  el0t_64_sync+0x190/0x194 [  303.309794] Code: ???????? ???????? ???????? ???????? (????????) [  303.310612] ---[ end trace 0000000000000000 ]---  Fix this by adding a .reconfigure() function to the fs operations which we can use to check the requested flags and deny anything that's not RO if the firmware doesn't implement SetVariable at runtime.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52463",
            "severity": "Negligible",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "expat",
            "featureversion": "2.2.10-2+deb11u5",
            "vulnerability": "CVE-2013-0340",
            "namespace": "debian:11",
            "description": "expat 2.1.0 and earlier does not properly handle entities expansion unless an application developer uses the XML_SetEntityDeclHandler function, which allows remote attackers to cause a denial of service (resource consumption), send HTTP requests to intranet servers, or read arbitrary files via a crafted XML document, aka an XML External Entity (XXE) issue.  NOTE: it could be argued that because expat already provides the ability to disable external entity expansion, the responsibility for resolving this issue lies with application developers; according to this argument, this entry should be REJECTed, and each affected application would need its own CVE.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2013-0340",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "libzstd",
            "featureversion": "1.4.8+dfsg-2.1",
            "vulnerability": "CVE-2022-4899",
            "namespace": "debian:11",
            "description": "A vulnerability was found in zstd v1.4.10, where an attacker can supply empty string as an argument to the command line tool to cause buffer overrun.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-4899",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "binutils",
            "featureversion": "2.35.2-2",
            "vulnerability": "CVE-2018-20673",
            "namespace": "debian:11",
            "description": "The demangle_template function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31.1, contains an integer overflow vulnerability (for \"Create an array for saving the template argument values\") that can trigger a heap-based buffer overflow, as demonstrated by nm.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2018-20673",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2005-3660",
            "namespace": "debian:11",
            "description": "Linux kernel 2.4 and 2.6 allows attackers to cause a denial of service (memory exhaustion and panic) by creating a large number of connected file descriptors or socketpairs and setting a large data transfer buffer, then preventing Linux from being able to finish the transfer by causing the process to become a zombie, or closing the file descriptor without closing an associated reference.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2005-3660",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2020-35501",
            "namespace": "debian:11",
            "description": "A flaw was found in the Linux kernels implementation of audit rules, where a syscall can unexpectedly not be correctly not be logged by the audit subsystem",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-35501",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-3623",
            "namespace": "debian:11",
            "description": "A vulnerability was found in Linux Kernel. It has been declared as problematic. Affected by this vulnerability is the function follow_page_pte of the file mm/gup.c of the component BPF. The manipulation leads to race condition. The attack can be launched remotely. It is recommended to apply a patch to fix this issue. The identifier VDB-211921 was assigned to this vulnerability.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-3623",
            "severity": "Negligible",
            "fixedby": "5.10.162-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-3640",
            "namespace": "debian:11",
            "description": "A possible unauthorized memory access flaw was found in the Linux kernel's cpu_entry_area mapping of X86 CPU data to memory, where a user may guess the location of exception stacks or other important data. Based on the previous CVE-2023-0597, the 'Randomize per-cpu entry area' feature was implemented in /arch/x86/mm/cpu_entry_area.c, which works through the init_cea_offsets() function when KASLR is enabled. However, despite this feature, there is still a risk of per-cpu entry area leaks. This issue could allow a local user to gain access to some important data with memory in an expected location and potentially escalate their privileges on the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3640",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-20588",
            "namespace": "debian:11",
            "description": "A division-by-zero error on some AMD processors can potentially return speculative data resulting in loss of confidentiality.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-20588",
            "severity": "Negligible",
            "fixedby": "5.10.197-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-46813",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel before 6.5.9, exploitable by local users with userspace access to MMIO registers. Incorrect access checking in the #VC handler and instruction emulation of the SEV-ES emulation of MMIO accesses could lead to arbitrary write access to kernel memory (and thus privilege escalation). This depends on a race condition through which userspace can replace an instruction before the #VC handler reads it.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-46813",
            "severity": "Negligible",
            "fixedby": "5.10.205-2"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-3389",
            "namespace": "debian:11",
            "description": "A use-after-free vulnerability in the Linux Kernel io_uring subsystem can be exploited to achieve local privilege escalation.  Racing a io_uring cancel poll request with a linked timeout can cause a UAF in a hrtimer.  We recommend upgrading past commit ef7dfac51d8ed961b742218f526bd589f3900a59 (4716c73b188566865bdd79c3a6709696a224ac04 for 5.10 stable and 0e388fce7aec40992eadee654193cad345d62663 for 5.15 stable).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3389",
            "severity": "Negligible",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-35823",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel before 6.3.2. A use-after-free was found in saa7134_finidev in drivers/media/pci/saa7134/saa7134-core.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-35823",
            "severity": "Negligible",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2012-4542",
            "namespace": "debian:11",
            "description": "block/scsi_ioctl.c in the Linux kernel through 3.8 does not properly consider the SCSI device class during authorization of SCSI commands, which allows local users to bypass intended access restrictions via an SG_IO ioctl call that leverages overlapping opcodes.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2012-4542",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-22998",
            "namespace": "debian:11",
            "description": "In the Linux kernel before 6.0.3, drivers/gpu/drm/virtio/virtgpu_object.c misinterprets the drm_gem_shmem_get_sg_table return value (expects it to be NULL in the error case, whereas it is actually an error pointer).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-22998",
            "severity": "Negligible",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2021-32078",
            "namespace": "debian:11",
            "description": "An Out-of-Bounds Read was discovered in arch/arm/mach-footbridge/personal-pci.c in the Linux kernel through 5.12.11 because of the lack of a check for a value that shouldn't be negative, e.g., access to element -2 of an array, aka CID-298a58e165e4.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-32078",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52564",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  Revert \"tty: n_gsm: fix UAF in gsm_cleanup_mux\"  This reverts commit 9b9c8195f3f0d74a826077fc1c01b9ee74907239.  The commit above is reverted as it did not solve the original issue.  gsm_cleanup_mux() tries to free up the virtual ttys by calling gsm_dlci_release() for each available DLCI. There, dlci_put() is called to decrease the reference counter for the DLCI via tty_port_put() which finally calls gsm_dlci_free(). This already clears the pointer which is being checked in gsm_cleanup_mux() before calling gsm_dlci_release(). Therefore, it is not necessary to clear this pointer in gsm_cleanup_mux() as done in the reverted commit. The commit introduces a null pointer dereference:  \u003cTASK\u003e  ? __die+0x1f/0x70  ? page_fault_oops+0x156/0x420  ? search_exception_tables+0x37/0x50  ? fixup_exception+0x21/0x310  ? exc_page_fault+0x69/0x150  ? asm_exc_page_fault+0x26/0x30  ? tty_port_put+0x19/0xa0  gsmtty_cleanup+0x29/0x80 [n_gsm]  release_one_tty+0x37/0xe0  process_one_work+0x1e6/0x3e0  worker_thread+0x4c/0x3d0  ? __pfx_worker_thread+0x10/0x10  kthread+0xe1/0x110  ? __pfx_kthread+0x10/0x10  ret_from_fork+0x2f/0x50  ? __pfx_kthread+0x10/0x10  ret_from_fork_asm+0x1b/0x30  \u003c/TASK\u003e  The actual issue is that nothing guards dlci_put() from being called multiple times while the tty driver was triggered but did not yet finished calling gsm_dlci_free().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52564",
            "severity": "Negligible",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-0646",
            "namespace": "debian:11",
            "description": "An out-of-bounds memory write flaw was found in the Linux kernel’s Transport Layer Security functionality in how a user calls a function splice with a ktls socket as the destination. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-0646",
            "severity": "Negligible",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u11",
            "vulnerability": "CVE-2022-43551",
            "namespace": "debian:11",
            "description": "A vulnerability exists in curl \u003c7.87.0 HSTS check that could be bypassed to trick it to keep using HTTP. Using its HSTS support, curl can be instructed to use HTTPS instead of using an insecure clear-text HTTP step even when HTTP is provided in the URL. However, the HSTS mechanism could be bypassed if the host name in the given URL first uses IDN characters that get replaced to ASCII counterparts as part of the IDN conversion. Like using the character UTF-8 U+3002 (IDEOGRAPHIC FULL STOP) instead of the common ASCII full stop (U+002E) `.`. Then in a subsequent request, it does not detect the HSTS state and makes a clear text transfer. Because it would store the info IDN encoded but look for it IDN decoded.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-43551",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2021-4023",
            "namespace": "debian:11",
            "description": "A flaw was found in the io-workqueue implementation in the Linux kernel versions prior to 5.15-rc1. The kernel can panic when an improper cancellation operation triggers the submission of new io-uring operations during a shortage of free space. This flaw allows a local user with permissions to execute io-uring requests to possibly crash the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-4023",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52513",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  RDMA/siw: Fix connection failure handling  In case immediate MPA request processing fails, the newly created endpoint unlinks the listening endpoint and is ready to be dropped. This special case was not handled correctly by the code handling the later TCP socket close, causing a NULL dereference crash in siw_cm_work_handler() when dereferencing a NULL listener. We now also cancel the useless MPA timeout, if immediate MPA request processing fails.  This patch furthermore simplifies MPA processing in general: Scheduling a useless TCP socket read in sk_data_ready() upcall is now surpressed, if the socket is already moved out of TCP_ESTABLISHED state.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52513",
            "severity": "Negligible",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u11",
            "vulnerability": "CVE-2021-22922",
            "namespace": "debian:11",
            "description": "When curl is instructed to download content using the metalink feature, thecontents is verified against a hash provided in the metalink XML file.The metalink XML file points out to the client how to get the same contentfrom a set of different URLs, potentially hosted by different servers and theclient can then download the file from one or several of them. In a serial orparallel manner.If one of the servers hosting the contents has been breached and the contentsof the specific file on that server is replaced with a modified payload, curlshould detect this when the hash of the file mismatches after a completeddownload. It should remove the contents and instead try getting the contentsfrom another URL. This is not done, and instead such a hash mismatch is onlymentioned in text and the potentially malicious content is kept in the file ondisk.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-22922",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2019-11191",
            "namespace": "debian:11",
            "description": "The Linux kernel through 5.0.7, when CONFIG_IA32_AOUT is enabled and ia32_aout is loaded, allows local users to bypass ASLR on setuid a.out programs (if any exist) because install_exec_creds() is called too late in load_aout_binary() in fs/binfmt_aout.c, and thus the ptrace_may_access() check has a race condition when reading /proc/pid/stat. NOTE: the software maintainer disputes that this is a vulnerability because ASLR for a.out format executables has never been supported",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-11191",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2020-24504",
            "namespace": "debian:11",
            "description": "Uncontrolled resource consumption in some Intel(R) Ethernet E810 Adapter drivers for Linux before version 1.0.4 may allow an authenticated user to potentially enable denial of service via local access.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-24504",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-35828",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel before 6.3.2. A use-after-free was found in renesas_usb3_remove in drivers/usb/gadget/udc/renesas_usb3.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-35828",
            "severity": "Negligible",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u11",
            "vulnerability": "CVE-2021-22923",
            "namespace": "debian:11",
            "description": "When curl is instructed to get content using the metalink feature, and a user name and password are used to download the metalink XML file, those same credentials are then subsequently passed on to each of the servers from which curl will download or try to download the contents from. Often contrary to the user's expectations and intentions and without telling the user it happened.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-22923",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-38457",
            "namespace": "debian:11",
            "description": "A use-after-free(UAF) vulnerability was found in function 'vmw_cmd_res_check' in drivers/gpu/vmxgfx/vmxgfx_execbuf.c in Linux kernel's vmwgfx driver with device file '/dev/dri/renderD128 (or Dxxx)'. This flaw allows a local attacker with a user account on the system to gain privilege, causing a denial of service(DoS).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-38457",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2020-11725",
            "namespace": "debian:11",
            "description": "snd_ctl_elem_add in sound/core/control.c in the Linux kernel through 5.6.3 has a count=info-\u003eowner line, which later affects a private_size*count multiplication for unspecified \"interesting side effects.\" NOTE: kernel engineers dispute this finding, because it could be relevant only if new callers were added that were unfamiliar with the misuse of the info-\u003eowner field to represent data unrelated to the \"owner\" concept. The existing callers, SNDRV_CTL_IOCTL_ELEM_ADD and SNDRV_CTL_IOCTL_ELEM_REPLACE, have been designed to misuse the info-\u003eowner field in a safe way",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-11725",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-2163",
            "namespace": "debian:11",
            "description": "Incorrect verifier pruning in BPF in Linux Kernel \u003e=5.4 leads to unsafe code paths being incorrectly marked as safe, resulting in arbitrary read/write in kernel memory, lateral privilege escalation, and container escape.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-2163",
            "severity": "Negligible",
            "fixedby": "5.10.179-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-2156",
            "namespace": "debian:11",
            "description": "A flaw was found in the networking subsystem of the Linux kernel within the handling of the RPL protocol. This issue results from the lack of proper handling of user-supplied data, which can lead to an assertion failure. This may allow an unauthenticated remote attacker to create a denial of service condition on the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-2156",
            "severity": "Negligible",
            "fixedby": "5.10.179-2"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26595",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  mlxsw: spectrum_acl_tcam: Fix NULL pointer dereference in error path  When calling mlxsw_sp_acl_tcam_region_destroy() from an error path after failing to attach the region to an ACL group, we hit a NULL pointer dereference upon 'region-\u003egroup-\u003etcam' [1].  Fix by retrieving the 'tcam' pointer using mlxsw_sp_acl_to_tcam().  [1] BUG: kernel NULL pointer dereference, address: 0000000000000000 [...] RIP: 0010:mlxsw_sp_acl_tcam_region_destroy+0xa0/0xd0 [...] Call Trace:  mlxsw_sp_acl_tcam_vchunk_get+0x88b/0xa20  mlxsw_sp_acl_tcam_ventry_add+0x25/0xe0  mlxsw_sp_acl_rule_add+0x47/0x240  mlxsw_sp_flower_replace+0x1a9/0x1d0  tc_setup_cb_add+0xdc/0x1c0  fl_hw_replace_filter+0x146/0x1f0  fl_change+0xc17/0x1360  tc_new_tfilter+0x472/0xb90  rtnetlink_rcv_msg+0x313/0x3b0  netlink_rcv_skb+0x58/0x100  netlink_unicast+0x244/0x390  netlink_sendmsg+0x1e4/0x440  ____sys_sendmsg+0x164/0x260  ___sys_sendmsg+0x9a/0xe0  __sys_sendmsg+0x7a/0xc0  do_syscall_64+0x40/0xe0  entry_SYSCALL_64_after_hwframe+0x63/0x6b",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26595",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u11",
            "vulnerability": "CVE-2023-28320",
            "namespace": "debian:11",
            "description": "A denial of service vulnerability exists in curl \u003cv8.1.0 in the way libcurl provides several different backends for resolving host names, selected at build time. If it is built to use the synchronous resolver, it allows name resolves to time-out slow operations using `alarm()` and `siglongjmp()`. When doing this, libcurl used a global buffer that was not mutex protected and a multi-threaded application might therefore crash or otherwise misbehave.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-28320",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52456",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  serial: imx: fix tx statemachine deadlock  When using the serial port as RS485 port, the tx statemachine is used to control the RTS pin to drive the RS485 transceiver TX_EN pin. When the TTY port is closed in the middle of a transmission (for instance during userland application crash), imx_uart_shutdown disables the interface and disables the Transmission Complete interrupt. afer that, imx_uart_stop_tx bails on an incomplete transmission, to be retriggered by the TC interrupt. This interrupt is disabled and therefore the tx statemachine never transitions out of SEND. The statemachine is in deadlock now, and the TX_EN remains low, making the interface useless.  imx_uart_stop_tx now checks for incomplete transmission AND whether TC interrupts are enabled before bailing to be retriggered. This makes sure the state machine handling is reached, and is properly set to WAIT_AFTER_SEND.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52456",
            "severity": "Negligible",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2018-17977",
            "namespace": "debian:11",
            "description": "The Linux kernel 4.14.67 mishandles certain interaction among XFRM Netlink messages, IPPROTO_AH packets, and IPPROTO_IP packets, which allows local users to cause a denial of service (memory consumption and system hang) by leveraging root access to execute crafted applications, as demonstrated on CentOS 7.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2018-17977",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2011-4915",
            "namespace": "debian:11",
            "description": "fs/proc/base.c in the Linux kernel through 3.1 allows local users to obtain sensitive keystroke information via access to /proc/interrupts.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2011-4915",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-1872",
            "namespace": "debian:11",
            "description": "A use-after-free vulnerability in the Linux Kernel io_uring system can be exploited to achieve local privilege escalation.  The io_file_get_fixed function lacks the presence of ctx-\u003euring_lock which can lead to a Use-After-Free vulnerability due a race condition with fixed files getting unregistered.  We recommend upgrading past commit da24142b1ef9fd5d36b76e36bab328a5b27523e8.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1872",
            "severity": "Negligible",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2011-4916",
            "namespace": "debian:11",
            "description": "Linux kernel through 3.1 allows local users to obtain sensitive keystroke information via access to /dev/pts/ and /dev/tty*.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2011-4916",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-4004",
            "namespace": "debian:11",
            "description": "A use-after-free flaw was found in the Linux kernel's netfilter in the way a user triggers the nft_pipapo_remove function with the element, without a NFT_SET_EXT_KEY_END. This issue could allow a local user to crash the system or potentially escalate their privileges on the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4004",
            "severity": "Negligible",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-6176",
            "namespace": "debian:11",
            "description": "A null pointer dereference flaw was found in the Linux kernel API for the cryptographic algorithm scatterwalk functionality. This issue occurs when a user constructs a malicious packet with specific socket configuration, which could allow a local user to crash the system or escalate their privileges on the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-6176",
            "severity": "Negligible",
            "fixedby": "5.10.197-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-6817",
            "namespace": "debian:11",
            "description": "A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation.  The function nft_pipapo_walk did not skip inactive elements during set walk which could lead double deactivations of PIPAPO (Pile Packet Policies) elements, leading to use-after-free.  We recommend upgrading past commit 317eb9685095678f2c9f5a8189de698c5354316a.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-6817",
            "severity": "Negligible",
            "fixedby": "5.10.205-2"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2019-12380",
            "namespace": "debian:11",
            "description": "**DISPUTED** An issue was discovered in the efi subsystem in the Linux kernel through 5.1.5. phys_efi_set_virtual_address_map in arch/x86/platform/efi/efi.c and efi_call_phys_prolog in arch/x86/platform/efi/efi_64.c mishandle memory allocation failures. NOTE: This id is disputed as not being an issue because “All the code touched by the referenced commit runs only at boot, before any user processes are started. Therefore, there is no possibility for an unprivileged user to control it.”.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-12380",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-25012",
            "namespace": "debian:11",
            "description": "The Linux kernel through 6.1.9 has a Use-After-Free in bigben_remove in drivers/hid/hid-bigbenff.c via a crafted USB device because the LED controllers remain registered for too long.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-25012",
            "severity": "Negligible",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2008-4609",
            "namespace": "debian:11",
            "description": "The TCP implementation in (1) Linux, (2) platforms based on BSD Unix, (3) Microsoft Windows, (4) Cisco products, and probably other operating systems allows remote attackers to cause a denial of service (connection queue exhaustion) via multiple vectors that manipulate information in the TCP state table, as demonstrated by sockstress.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2008-4609",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52452",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Fix accesses to uninit stack slots  Privileged programs are supposed to be able to read uninitialized stack memory (ever since 6715df8d5) but, before this patch, these accesses were permitted inconsistently. In particular, accesses were permitted above state-\u003eallocated_stack, but not below it. In other words, if the stack was already \"large enough\", the access was permitted, but otherwise the access was rejected instead of being allowed to \"grow the stack\". This undesired rejection was happening in two places: - in check_stack_slot_within_bounds() - in check_stack_range_initialized() This patch arranges for these accesses to be permitted. A bunch of tests that were relying on the old rejection had to change; all of them were changed to add also run unprivileged, in which case the old behavior persists. One tests couldn't be updated - global_func16 - because it can't run unprivileged for other reasons.  This patch also fixes the tracking of the stack size for variable-offset reads. This second fix is bundled in the same commit as the first one because they're inter-related. Before this patch, writes to the stack using registers containing a variable offset (as opposed to registers with fixed, known values) were not properly contributing to the function's needed stack size. As a result, it was possible for a program to verify, but then to attempt to read out-of-bounds data at runtime because a too small stack had been allocated for it.  Each function tracks the size of the stack it needs in bpf_subprog_info.stack_depth, which is maintained by update_stack_depth(). For regular memory accesses, check_mem_access() was calling update_state_depth() but it was passing in only the fixed part of the offset register, ignoring the variable offset. This was incorrect; the minimum possible value of that register should be used instead.  This tracking is now fixed by centralizing the tracking of stack size in grow_stack_state(), and by lifting the calls to grow_stack_state() to check_stack_access_within_bounds() as suggested by Andrii. The code is now simpler and more convincingly tracks the correct maximum stack size. check_stack_range_initialized() can now rely on enough stack having been allocated for the access; this helps with the fix for the first issue.  A few tests were changed to also check the stack depth computation. The one that fails without this patch is verifier_var_off:stack_write_priv_vs_unpriv.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52452",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-45887",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 6.0.9. drivers/media/usb/ttusb-dec/ttusb_dec.c has a memory leak because of the lack of a dvb_frontend_detach call.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-45887",
            "severity": "Negligible",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2019-12456",
            "namespace": "debian:11",
            "description": "An issue was discovered in the MPT3COMMAND case in _ctl_ioctl_main in drivers/scsi/mpt3sas/mpt3sas_ctl.c in the Linux kernel through 5.1.5. It allows local users to cause a denial of service or possibly have unspecified other impact by changing the value of ioc_number between two kernel reads of that value, aka a \"double fetch\" vulnerability. NOTE: a third party reports that this is unexploitable because the doubly fetched value is not used",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-12456",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52492",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  dmaengine: fix NULL pointer in channel unregistration function  __dma_async_device_channel_register() can fail. In case of failure, chan-\u003elocal is freed (with free_percpu()), and chan-\u003elocal is nullified. When dma_async_device_unregister() is called (because of managed API or intentionally by DMA controller driver), channels are unconditionally unregistered, leading to this NULL pointer: [    1.318693] Unable to handle kernel NULL pointer dereference at virtual address 00000000000000d0 [...] [    1.484499] Call trace: [    1.486930]  device_del+0x40/0x394 [    1.490314]  device_unregister+0x20/0x7c [    1.494220]  __dma_async_device_channel_unregister+0x68/0xc0  Look at dma_async_device_register() function error path, channel device unregistration is done only if chan-\u003elocal is not NULL.  Then add the same condition at the beginning of __dma_async_device_channel_unregister() function, to avoid NULL pointer issue whatever the API used to reach this function.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52492",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2021-47014",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  net/sched: act_ct: fix wild memory access when clearing fragments  while testing re-assembly/re-fragmentation using act_ct, it's possible to observe a crash like the following one:   KASAN: maybe wild-memory-access in range [0x0001000000000448-0x000100000000044f]  CPU: 50 PID: 0 Comm: swapper/50 Tainted: G S                5.12.0-rc7+ #424  Hardware name: Dell Inc. PowerEdge R730/072T6D, BIOS 2.4.3 01/17/2017  RIP: 0010:inet_frag_rbtree_purge+0x50/0xc0  Code: 00 fc ff df 48 89 c3 31 ed 48 89 df e8 a9 7a 38 ff 4c 89 fe 48 89 df 49 89 c6 e8 5b 3a 38 ff 48 8d 7b 40 48 89 f8 48 c1 e8 03 \u003c42\u003e 80 3c 20 00 75 59 48 8d bb d0 00 00 00 4c 8b 6b 40 48 89 f8 48  RSP: 0018:ffff888c31449db8 EFLAGS: 00010203  RAX: 0000200000000089 RBX: 000100000000040e RCX: ffffffff989eb960  RDX: 0000000000000140 RSI: ffffffff97cfb977 RDI: 000100000000044e  RBP: 0000000000000900 R08: 0000000000000000 R09: ffffed1186289350  R10: 0000000000000003 R11: ffffed1186289350 R12: dffffc0000000000  R13: 000100000000040e R14: 0000000000000000 R15: ffff888155e02160  FS:  0000000000000000(0000) GS:ffff888c31440000(0000) knlGS:0000000000000000  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033  CR2: 00005600cb70a5b8 CR3: 0000000a2c014005 CR4: 00000000003706e0  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400  Call Trace:   \u003cIRQ\u003e   inet_frag_destroy+0xa9/0x150   call_timer_fn+0x2d/0x180   run_timer_softirq+0x4fe/0xe70   __do_softirq+0x197/0x5a0   irq_exit_rcu+0x1de/0x200   sysvec_apic_timer_interrupt+0x6b/0x80   \u003c/IRQ\u003e  when act_ct temporarily stores an IP fragment, restoring the skb qdisc cb results in putting random data in FRAG_CB(), and this causes those \"wild\" memory accesses later, when the rbtree is purged. Never overwrite the skb cb in case tcf_ct_handle_fragments() returns -EINPROGRESS.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-47014",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-4379",
            "namespace": "debian:11",
            "description": "A use-after-free vulnerability was found in __nfs42_ssc_open() in fs/nfs/nfs4file.c in the Linux kernel. This flaw allows an attacker to conduct a remote denial",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-4379",
            "severity": "Negligible",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-2193",
            "namespace": "debian:11",
            "description": "A Speculative Race Condition (SRC) vulnerability that impacts modern CPU architectures supporting speculative execution (related to Spectre V1) has been disclosed. An unauthenticated attacker can exploit this vulnerability to disclose arbitrary data from the CPU using race conditions to access the speculative executable code paths.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-2193",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2019-12381",
            "namespace": "debian:11",
            "description": "An issue was discovered in ip_ra_control in net/ipv4/ip_sockglue.c in the Linux kernel through 5.1.5. There is an unchecked kmalloc of new_ra, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: this is disputed because new_ra is never used if it is NULL",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-12381",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-23004",
            "namespace": "debian:11",
            "description": "In the Linux kernel before 5.19, drivers/gpu/drm/arm/malidp_planes.c misinterprets the get_sg_table return value (expects it to be NULL in the error case, whereas it is actually an error pointer).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-23004",
            "severity": "Negligible",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-44032",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 6.0.6. drivers/char/pcmcia/cm4000_cs.c has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling open(), aka a race condition between cmm_open() and cm4000_detach().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-44032",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-4147",
            "namespace": "debian:11",
            "description": "A use-after-free flaw was found in the Linux kernel’s Netfilter functionality when adding a rule with NFTA_RULE_CHAIN_ID. This flaw allows a local user to crash or escalate their privileges on the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4147",
            "severity": "Negligible",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52608",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  firmware: arm_scmi: Check mailbox/SMT channel for consistency  On reception of a completion interrupt the shared memory area is accessed to retrieve the message header at first and then, if the message sequence number identifies a transaction which is still pending, the related payload is fetched too.  When an SCMI command times out the channel ownership remains with the platform until eventually a late reply is received and, as a consequence, any further transmission attempt remains pending, waiting for the channel to be relinquished by the platform.  Once that late reply is received the channel ownership is given back to the agent and any pending request is then allowed to proceed and overwrite the SMT area of the just delivered late reply; then the wait for the reply to the new request starts.  It has been observed that the spurious IRQ related to the late reply can be wrongly associated with the freshly enqueued request: when that happens the SCMI stack in-flight lookup procedure is fooled by the fact that the message header now present in the SMT area is related to the new pending transaction, even though the real reply has still to arrive.  This race-condition on the A2P channel can be detected by looking at the channel status bits: a genuine reply from the platform will have set the channel free bit before triggering the completion IRQ.  Add a consistency check to validate such condition in the A2P ISR.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52608",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-0500",
            "namespace": "debian:11",
            "description": "A flaw was found in unrestricted eBPF usage by the BPF_BTF_LOAD, leading to a possible out-of-bounds memory write in the Linux kernel’s BPF subsystem due to the way a user loads BTF. This flaw allows a local user to crash or escalate their privileges on the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-0500",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2019-12379",
            "namespace": "debian:11",
            "description": "An issue was discovered in con_insert_unipair in drivers/tty/vt/consolemap.c in the Linux kernel through 5.1.5. There is a memory leak in a certain case of an ENOMEM outcome of kmalloc. NOTE: This id is disputed as not being an issue",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-12379",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2021-47036",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  udp: skip L4 aggregation for UDP tunnel packets  If NETIF_F_GRO_FRAGLIST or NETIF_F_GRO_UDP_FWD are enabled, and there are UDP tunnels available in the system, udp_gro_receive() could end-up doing L4 aggregation (either SKB_GSO_UDP_L4 or SKB_GSO_FRAGLIST) at the outer UDP tunnel level for packets effectively carrying and UDP tunnel header.  That could cause inner protocol corruption. If e.g. the relevant packets carry a vxlan header, different vxlan ids will be ignored/ aggregated to the same GSO packet. Inner headers will be ignored, too, so that e.g. TCP over vxlan push packets will be held in the GRO engine till the next flush, etc.  Just skip the SKB_GSO_UDP_L4 and SKB_GSO_FRAGLIST code path if the current packet could land in a UDP tunnel, and let udp_gro_receive() do GRO via udp_sk(sk)-\u003egro_receive.  The check implemented in this patch is broader than what is strictly needed, as the existing UDP tunnel could be e.g. configured on top of a different device: we could end-up skipping GRO at-all for some packets.  Anyhow, that is a very thin corner case and covering it will add quite a bit of complexity.  v1 -\u003e v2:  - hopefully clarify the commit message",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-47036",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-35824",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel before 6.3.2. A use-after-free was found in dm1105_remove in drivers/media/pci/dm1105/dm1105.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-35824",
            "severity": "Negligible",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52616",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  crypto: lib/mpi - Fix unexpected pointer access in mpi_ec_init  When the mpi_ec_ctx structure is initialized, some fields are not cleared, causing a crash when referencing the field when the structure was released. Initially, this issue was ignored because memory for mpi_ec_ctx is allocated with the __GFP_ZERO flag. For example, this error will be triggered when calculating the Za value for SM2 separately.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52616",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-44034",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 6.0.6. drivers/char/pcmcia/scr24x_cs.c has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling open(), aka a race condition between scr24x_open() and scr24x_remove().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-44034",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2019-16232",
            "namespace": "debian:11",
            "description": "drivers/net/wireless/marvell/libertas/if_sdio.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-16232",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2016-8660",
            "namespace": "debian:11",
            "description": "The XFS subsystem in the Linux kernel through 4.8.2 allows local users to cause a denial of service (fdatasync failure and system hang) by using the vfs syscall group in the trinity program, related to a \"page lock order bug in the XFS seek hole/data implementation.\"",
            "link": "https://security-tracker.debian.org/tracker/CVE-2016-8660",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2017-13693",
            "namespace": "debian:11",
            "description": "The acpi_ds_create_operands() function in drivers/acpi/acpica/dsutils.c in the Linux kernel through 4.12.9 does not flush the operand cache and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2017-13693",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-45885",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvb_frontend.c has a race condition that can cause a use-after-free when a device is disconnected.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-45885",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-45886",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvb_net.c has a .disconnect versus dvb_device_open race condition that leads to a use-after-free.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-45886",
            "severity": "Negligible",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26585",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  tls: fix race between tx work scheduling and socket close  Similarly to previous commit, the submitting thread (recvmsg/sendmsg) may exit as soon as the async crypto handler calls complete(). Reorder scheduling the work before calling complete(). This seems more logical in the first place, as it's the inverse order of what the submitting thread will do.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26585",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2016-10723",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 4.17.2. Since the page allocator does not yield CPU resources to the owner of the oom_lock mutex, a local unprivileged user can trivially lock up the system forever by wasting CPU resources from the page allocator (e.g., via concurrent page fault events) when the global OOM killer is invoked. NOTE: the software maintainer has not accepted certain proposed patches, in part because of a viewpoint that \"the underlying problem is non-trivial to handle.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2016-10723",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u11",
            "vulnerability": "CVE-2023-23915",
            "namespace": "debian:11",
            "description": "A cleartext transmission of sensitive information vulnerability exists in curl \u003cv7.88.0 that could cause HSTS functionality to behave incorrectly when multiple URLs are requested in parallel. Using its HSTS support, curl can be instructed to use HTTPS instead of using an insecure clear-text HTTP step even when HTTP is provided in the URL. This HSTS mechanism would however surprisingly fail when multiple transfers are done in parallel as the HSTS cache file gets overwritten by the most recentlycompleted transfer. A later HTTP-only transfer to the earlier host name would then *not* get upgraded properly to HSTS.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-23915",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2004-0230",
            "namespace": "debian:11",
            "description": "TCP, when using a large Window Size, makes it easier for remote attackers to guess sequence numbers and cause a denial of service (connection loss) to persistent TCP connections by repeatedly injecting a TCP RST packet, especially in protocols that use long-lived connections, such as BGP.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2004-0230",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2021-46987",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: fix deadlock when cloning inline extents and using qgroups  There are a few exceptional cases where cloning an inline extent needs to copy the inline extent data into a page of the destination inode.  When this happens, we end up starting a transaction while having a dirty page for the destination inode and while having the range locked in the destination's inode iotree too. Because when reserving metadata space for a transaction we may need to flush existing delalloc in case there is not enough free space, we have a mechanism in place to prevent a deadlock, which was introduced in commit 3d45f221ce627d (\"btrfs: fix deadlock when cloning inline extent and low on free metadata space\").  However when using qgroups, a transaction also reserves metadata qgroup space, which can also result in flushing delalloc in case there is not enough available space at the moment. When this happens we deadlock, since flushing delalloc requires locking the file range in the inode's iotree and the range was already locked at the very beginning of the clone operation, before attempting to start the transaction.  When this issue happens, stack traces like the following are reported:    [72747.556262] task:kworker/u81:9   state:D stack:    0 pid:  225 ppid:     2 flags:0x00004000   [72747.556268] Workqueue: writeback wb_workfn (flush-btrfs-1142)   [72747.556271] Call Trace:   [72747.556273]  __schedule+0x296/0x760   [72747.556277]  schedule+0x3c/0xa0   [72747.556279]  io_schedule+0x12/0x40   [72747.556284]  __lock_page+0x13c/0x280   [72747.556287]  ? generic_file_readonly_mmap+0x70/0x70   [72747.556325]  extent_write_cache_pages+0x22a/0x440 [btrfs]   [72747.556331]  ? __set_page_dirty_nobuffers+0xe7/0x160   [72747.556358]  ? set_extent_buffer_dirty+0x5e/0x80 [btrfs]   [72747.556362]  ? update_group_capacity+0x25/0x210   [72747.556366]  ? cpumask_next_and+0x1a/0x20   [72747.556391]  extent_writepages+0x44/0xa0 [btrfs]   [72747.556394]  do_writepages+0x41/0xd0   [72747.556398]  __writeback_single_inode+0x39/0x2a0   [72747.556403]  writeback_sb_inodes+0x1ea/0x440   [72747.556407]  __writeback_inodes_wb+0x5f/0xc0   [72747.556410]  wb_writeback+0x235/0x2b0   [72747.556414]  ? get_nr_inodes+0x35/0x50   [72747.556417]  wb_workfn+0x354/0x490   [72747.556420]  ? newidle_balance+0x2c5/0x3e0   [72747.556424]  process_one_work+0x1aa/0x340   [72747.556426]  worker_thread+0x30/0x390   [72747.556429]  ? create_worker+0x1a0/0x1a0   [72747.556432]  kthread+0x116/0x130   [72747.556435]  ? kthread_park+0x80/0x80   [72747.556438]  ret_from_fork+0x1f/0x30    [72747.566958] Workqueue: btrfs-flush_delalloc btrfs_work_helper [btrfs]   [72747.566961] Call Trace:   [72747.566964]  __schedule+0x296/0x760   [72747.566968]  ? finish_wait+0x80/0x80   [72747.566970]  schedule+0x3c/0xa0   [72747.566995]  wait_extent_bit.constprop.68+0x13b/0x1c0 [btrfs]   [72747.566999]  ? finish_wait+0x80/0x80   [72747.567024]  lock_extent_bits+0x37/0x90 [btrfs]   [72747.567047]  btrfs_invalidatepage+0x299/0x2c0 [btrfs]   [72747.567051]  ? find_get_pages_range_tag+0x2cd/0x380   [72747.567076]  __extent_writepage+0x203/0x320 [btrfs]   [72747.567102]  extent_write_cache_pages+0x2bb/0x440 [btrfs]   [72747.567106]  ? update_load_avg+0x7e/0x5f0   [72747.567109]  ? enqueue_entity+0xf4/0x6f0   [72747.567134]  extent_writepages+0x44/0xa0 [btrfs]   [72747.567137]  ? enqueue_task_fair+0x93/0x6f0   [72747.567140]  do_writepages+0x41/0xd0   [72747.567144]  __filemap_fdatawrite_range+0xc7/0x100   [72747.567167]  btrfs_run_delalloc_work+0x17/0x40 [btrfs]   [72747.567195]  btrfs_work_helper+0xc2/0x300 [btrfs]   [72747.567200]  process_one_work+0x1aa/0x340   [72747.567202]  worker_thread+0x30/0x390   [72747.567205]  ? create_worker+0x1a0/0x1a0   [72747.567208]  kthread+0x116/0x130   [72747.567211]  ? kthread_park+0x80/0x80   [72747.567214]  ret_from_fork+0x1f/0x30    [72747.569686] task:fsstress        state:D stack:     ---truncated---",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-46987",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u11",
            "vulnerability": "CVE-2023-23914",
            "namespace": "debian:11",
            "description": "A cleartext transmission of sensitive information vulnerability exists in curl \u003cv7.88.0 that could cause HSTS functionality fail when multiple URLs are requested serially. Using its HSTS support, curl can be instructed to use HTTPS instead of usingan insecure clear-text HTTP step even when HTTP is provided in the URL. ThisHSTS mechanism would however surprisingly be ignored by subsequent transferswhen done on the same command line because the state would not be properlycarried on.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-23914",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-23850",
            "namespace": "debian:11",
            "description": "In btrfs_get_root_ref in fs/btrfs/disk-io.c in the Linux kernel through 6.7.1, there can be an assertion failure and crash because a subvolume can be read out too soon after its root item is inserted upon subvolume creation.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-23850",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2010-5321",
            "namespace": "debian:11",
            "description": "Memory leak in drivers/media/video/videobuf-core.c in the videobuf subsystem in the Linux kernel 2.6.x through 4.x allows local users to cause a denial of service (memory consumption) by leveraging /dev/video access for a series of mmap calls that require new allocations, a different vulnerability than CVE-2007-6761.  NOTE: as of 2016-06-18, this affects only 11 drivers that have not been updated to use videobuf2 instead of videobuf.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2010-5321",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u11",
            "vulnerability": "CVE-2023-46219",
            "namespace": "debian:11",
            "description": "When saving HSTS data to an excessively long file name, curl could end up removing all contents, making subsequent requests using that file unaware of the HSTS status they should otherwise use.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-46219",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2014-9900",
            "namespace": "debian:11",
            "description": "The ethtool_get_wol function in net/core/ethtool.c in the Linux kernel through 4.7, as used in Android before 2016-08-05 on Nexus 5 and 7 (2013) devices, does not initialize a certain data structure, which allows local users to obtain sensitive information via a crafted application, aka Android internal bug 28803952 and Qualcomm internal bug CR570754.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2014-9900",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u11",
            "vulnerability": "CVE-2024-2379",
            "namespace": "debian:11",
            "description": "libcurl skips the certificate verification for a QUIC connection under certain conditions, when built to use wolfSSL. If told to use an unknown/bad cipher or curve, the error path accidentally skips the verification and returns OK, thus ignoring any certificate problems.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-2379",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-6546",
            "namespace": "debian:11",
            "description": "A race condition was found in the GSM 0710 tty multiplexor in the Linux kernel. This issue occurs when two threads execute the GSMIOC_SETCONF ioctl on the same tty file descriptor with the gsm line discipline enabled, and can lead to a use-after-free problem on a struct gsm_dlci while restarting the gsm mux. This could allow a local unprivileged user to escalate their privileges on the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-6546",
            "severity": "Negligible",
            "fixedby": "5.10.197-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52493",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  bus: mhi: host: Drop chan lock before queuing buffers  Ensure read and write locks for the channel are not taken in succession by dropping the read lock from parse_xfer_event() such that a callback given to client can potentially queue buffers and acquire the write lock in that process. Any queueing of buffers should be done without channel read lock acquired as it can result in multiple locks and a soft lockup.  [mani: added fixes tag and cc'ed stable]",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52493",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52573",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  net: rds: Fix possible NULL-pointer dereference  In rds_rdma_cm_event_handler_cmn() check, if conn pointer exists before dereferencing it as rdma_set_service_type() argument  Found by Linux Verification Center (linuxtesting.org) with SVACE.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52573",
            "severity": "Negligible",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2014-9892",
            "namespace": "debian:11",
            "description": "The snd_compr_tstamp function in sound/core/compress_offload.c in the Linux kernel through 4.7, as used in Android before 2016-08-05 on Nexus 5 and 7 (2013) devices, does not properly initialize a timestamp data structure, which allows attackers to obtain sensitive information via a crafted application, aka Android internal bug 28770164 and Qualcomm internal bug CR568717.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2014-9892",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2010-4563",
            "namespace": "debian:11",
            "description": "The Linux kernel, when using IPv6, allows remote attackers to determine whether a host is sniffing the network by sending an ICMPv6 Echo Request to a multicast address and determining whether an Echo Reply is sent, as demonstrated by thcping.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2010-4563",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-34256",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel before 6.3.3. There is an out-of-bounds read in crc16 in lib/crc16.c when called from fs/ext4/super.c because ext4_group_desc_csum does not properly check an offset. NOTE: this is disputed by third parties because the kernel is not intended to defend against attackers with the stated \"When modifying the block device while it is mounted by the filesystem\" access.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-34256",
            "severity": "Negligible",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-4134",
            "namespace": "debian:11",
            "description": "",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4134",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2021-4204",
            "namespace": "debian:11",
            "description": "An out-of-bounds (OOB) memory access flaw was found in the Linux kernel's eBPF due to an Improper Input Validation. This flaw allows a local attacker with a special privilege to crash the system or leak internal information.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-4204",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52447",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Defer the free of inner map when necessary  When updating or deleting an inner map in map array or map htab, the map may still be accessed by non-sleepable program or sleepable program. However bpf_map_fd_put_ptr() decreases the ref-counter of the inner map directly through bpf_map_put(), if the ref-counter is the last one (which is true for most cases), the inner map will be freed by ops-\u003emap_free() in a kworker. But for now, most .map_free() callbacks don't use synchronize_rcu() or its variants to wait for the elapse of a RCU grace period, so after the invocation of ops-\u003emap_free completes, the bpf program which is accessing the inner map may incur use-after-free problem.  Fix the free of inner map by invoking bpf_map_free_deferred() after both one RCU grace period and one tasks trace RCU grace period if the inner map has been removed from the outer map before. The deferment is accomplished by using call_rcu() or call_rcu_tasks_trace() when releasing the last ref-counter of bpf map. The newly-added rcu_head field in bpf_map shares the same storage space with work field to reduce the size of bpf_map.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52447",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-3610",
            "namespace": "debian:11",
            "description": "A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation.  Flaw in the error handling of bound chains causes a use-after-free in the abort path of NFT_MSG_NEWRULE. The vulnerability requires CAP_NET_ADMIN to be triggered.  We recommend upgrading past commit 4bedf9eee016286c835e3d8fa981ddece5338795.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3610",
            "severity": "Negligible",
            "fixedby": "5.10.179-3"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52610",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  net/sched: act_ct: fix skb leak and crash on ooo frags  act_ct adds skb-\u003eusers before defragmentation. If frags arrive in order, the last frag's reference is reset in:    inet_frag_reasm_prepare     skb_morph  which is not straightforward.  However when frags arrive out of order, nobody unref the last frag, and all frags are leaked. The situation is even worse, as initiating packet capture can lead to a crash[0] when skb has been cloned and shared at the same time.  Fix the issue by removing skb_get() before defragmentation. act_ct returns TC_ACT_CONSUMED when defrag failed or in progress.  [0]: [  843.804823] ------------[ cut here ]------------ [  843.809659] kernel BUG at net/core/skbuff.c:2091! [  843.814516] invalid opcode: 0000 [#1] PREEMPT SMP [  843.819296] CPU: 7 PID: 0 Comm: swapper/7 Kdump: loaded Tainted: G S 6.7.0-rc3 #2 [  843.824107] Hardware name: XFUSION 1288H V6/BC13MBSBD, BIOS 1.29 11/25/2022 [  843.828953] RIP: 0010:pskb_expand_head+0x2ac/0x300 [  843.833805] Code: 8b 70 28 48 85 f6 74 82 48 83 c6 08 bf 01 00 00 00 e8 38 bd ff ff 8b 83 c0 00 00 00 48 03 83 c8 00 00 00 e9 62 ff ff ff 0f 0b \u003c0f\u003e 0b e8 8d d0 ff ff e9 b3 fd ff ff 81 7c 24 14 40 01 00 00 4c 89 [  843.843698] RSP: 0018:ffffc9000cce07c0 EFLAGS: 00010202 [  843.848524] RAX: 0000000000000002 RBX: ffff88811a211d00 RCX: 0000000000000820 [  843.853299] RDX: 0000000000000640 RSI: 0000000000000000 RDI: ffff88811a211d00 [  843.857974] RBP: ffff888127d39518 R08: 00000000bee97314 R09: 0000000000000000 [  843.862584] R10: 0000000000000000 R11: ffff8881109f0000 R12: 0000000000000880 [  843.867147] R13: ffff888127d39580 R14: 0000000000000640 R15: ffff888170f7b900 [  843.871680] FS:  0000000000000000(0000) GS:ffff889ffffc0000(0000) knlGS:0000000000000000 [  843.876242] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [  843.880778] CR2: 00007fa42affcfb8 CR3: 000000011433a002 CR4: 0000000000770ef0 [  843.885336] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [  843.889809] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [  843.894229] PKRU: 55555554 [  843.898539] Call Trace: [  843.902772]  \u003cIRQ\u003e [  843.906922]  ? __die_body+0x1e/0x60 [  843.911032]  ? die+0x3c/0x60 [  843.915037]  ? do_trap+0xe2/0x110 [  843.918911]  ? pskb_expand_head+0x2ac/0x300 [  843.922687]  ? do_error_trap+0x65/0x80 [  843.926342]  ? pskb_expand_head+0x2ac/0x300 [  843.929905]  ? exc_invalid_op+0x50/0x60 [  843.933398]  ? pskb_expand_head+0x2ac/0x300 [  843.936835]  ? asm_exc_invalid_op+0x1a/0x20 [  843.940226]  ? pskb_expand_head+0x2ac/0x300 [  843.943580]  inet_frag_reasm_prepare+0xd1/0x240 [  843.946904]  ip_defrag+0x5d4/0x870 [  843.950132]  nf_ct_handle_fragments+0xec/0x130 [nf_conntrack] [  843.953334]  tcf_ct_act+0x252/0xd90 [act_ct] [  843.956473]  ? tcf_mirred_act+0x516/0x5a0 [act_mirred] [  843.959657]  tcf_action_exec+0xa1/0x160 [  843.962823]  fl_classify+0x1db/0x1f0 [cls_flower] [  843.966010]  ? skb_clone+0x53/0xc0 [  843.969173]  tcf_classify+0x24d/0x420 [  843.972333]  tc_run+0x8f/0xf0 [  843.975465]  __netif_receive_skb_core+0x67a/0x1080 [  843.978634]  ? dev_gro_receive+0x249/0x730 [  843.981759]  __netif_receive_skb_list_core+0x12d/0x260 [  843.984869]  netif_receive_skb_list_internal+0x1cb/0x2f0 [  843.987957]  ? mlx5e_handle_rx_cqe_mpwrq_rep+0xfa/0x1a0 [mlx5_core] [  843.991170]  napi_complete_done+0x72/0x1a0 [  843.994305]  mlx5e_napi_poll+0x28c/0x6d0 [mlx5_core] [  843.997501]  __napi_poll+0x25/0x1b0 [  844.000627]  net_rx_action+0x256/0x330 [  844.003705]  __do_softirq+0xb3/0x29b [  844.006718]  irq_exit_rcu+0x9e/0xc0 [  844.009672]  common_interrupt+0x86/0xa0 [  844.012537]  \u003c/IRQ\u003e [  844.015285]  \u003cTASK\u003e [  844.017937]  asm_common_interrupt+0x26/0x40 [  844.020591] RIP: 0010:acpi_safe_halt+0x1b/0x20 [  844.023247] Code: ff 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 65 48 8b 04 25 00 18 03 00 48 8b 00 a8 08 75 0c 66 90 0f 00 2d 81 d0 44 00 fb ---truncated---",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52610",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-0193",
            "namespace": "debian:11",
            "description": "A use-after-free flaw was found in the netfilter subsystem of the Linux kernel. If the catchall element is garbage-collected when the pipapo set is removed, the element can be deactivated twice. This can cause a use-after-free issue on an NFT_CHAIN object or NFT_OBJECT object, allowing a local unprivileged user with CAP_NET_ADMIN capability to escalate their privileges on the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-0193",
            "severity": "Negligible",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26610",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: iwlwifi: fix a memory corruption  iwl_fw_ini_trigger_tlv::data is a pointer to a __le32, which means that if we copy to iwl_fw_ini_trigger_tlv::data + offset while offset is in bytes, we'll write past the buffer.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26610",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "tar",
            "featureversion": "1.34+dfsg-1",
            "vulnerability": "CVE-2005-2541",
            "namespace": "debian:11",
            "description": "Tar 1.15.1 does not properly warn the user when extracting setuid or setgid files, which may allow local users or remote attackers to gain privileges.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2005-2541",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2019-16229",
            "namespace": "debian:11",
            "description": "drivers/gpu/drm/amd/amdkfd/kfd_interrupt.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference. NOTE: The security community disputes this issues as not being serious enough to be deserving a CVE id",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-16229",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-27672",
            "namespace": "debian:11",
            "description": "When SMT is enabled, certain AMD processors may speculatively execute instructions using a target from the sibling thread after an SMT mode switch potentially resulting in information disclosure.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-27672",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-22995",
            "namespace": "debian:11",
            "description": "In the Linux kernel before 5.17, an error path in dwc3_qcom_acpi_register_core in drivers/usb/dwc3/dwc3-qcom.c lacks certain platform_device_put and kfree calls.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-22995",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-2898",
            "namespace": "debian:11",
            "description": "There is a null-pointer-dereference flaw found in f2fs_write_end_io in fs/f2fs/data.c in the Linux kernel. This flaw allows a local privileged user to cause a denial of service problem.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-2898",
            "severity": "Negligible",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2021-3714",
            "namespace": "debian:11",
            "description": "A flaw was found in the Linux kernels memory deduplication mechanism. Previous work has shown that memory deduplication can be attacked via a local exploitation mechanism. The same technique can be used if an attacker can upload page sized files and detect the change in access time from a networked service to determine if the page has been merged.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-3714",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-44033",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 6.0.6. drivers/char/pcmcia/cm4040_cs.c has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling open(), aka a race condition between cm4040_open() and reader_detach().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-44033",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-41848",
            "namespace": "debian:11",
            "description": "drivers/char/pcmcia/synclink_cs.c in the Linux kernel through 5.19.12 has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling ioctl, aka a race condition between mgslpc_ioctl and mgslpc_detach.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-41848",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-1295",
            "namespace": "debian:11",
            "description": "A time-of-check to time-of-use issue exists in io_uring subsystem's IORING_OP_CLOSE operation in the Linux kernel's versions 5.6 - 5.11 (inclusive), which allows a local user to elevate their privileges to root. Introduced in b5dba59e0cf7e2cc4d3b3b1ac5fe81ddf21959eb, patched in 9eac1904d3364254d622bf2c771c4f85cd435fc2, backported to stable in 788d0824269bef539fe31a785b1517882eafed93.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1295",
            "severity": "Negligible",
            "fixedby": "5.10.162-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26593",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  i2c: i801: Fix block process call transactions  According to the Intel datasheets, software must reset the block buffer index twice for block process call transactions: once before writing the outgoing data to the buffer, and once again before reading the incoming data from the buffer.  The driver is currently missing the second reset, causing the wrong portion of the block buffer to be read.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26593",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2021-47094",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  KVM: x86/mmu: Don't advance iterator after restart due to yielding  After dropping mmu_lock in the TDP MMU, restart the iterator during tdp_iter_next() and do not advance the iterator.  Advancing the iterator results in skipping the top-level SPTE and all its children, which is fatal if any of the skipped SPTEs were not visited before yielding.  When zapping all SPTEs, i.e. when min_level == root_level, restarting the iter and then invoking tdp_iter_next() is always fatal if the current gfn has as a valid SPTE, as advancing the iterator results in try_step_side() skipping the current gfn, which wasn't visited before yielding.  Sprinkle WARNs on iter-\u003eyielded being true in various helpers that are often used in conjunction with yielding, and tag the helper with __must_check to reduce the probabily of improper usage.  Failing to zap a top-level SPTE manifests in one of two ways.  If a valid SPTE is skipped by both kvm_tdp_mmu_zap_all() and kvm_tdp_mmu_put_root(), the shadow page will be leaked and KVM will WARN accordingly.    WARNING: CPU: 1 PID: 3509 at arch/x86/kvm/mmu/tdp_mmu.c:46 [kvm]   RIP: 0010:kvm_mmu_uninit_tdp_mmu+0x3e/0x50 [kvm]   Call Trace:    \u003cTASK\u003e    kvm_arch_destroy_vm+0x130/0x1b0 [kvm]    kvm_destroy_vm+0x162/0x2a0 [kvm]    kvm_vcpu_release+0x34/0x60 [kvm]    __fput+0x82/0x240    task_work_run+0x5c/0x90    do_exit+0x364/0xa10    ? futex_unqueue+0x38/0x60    do_group_exit+0x33/0xa0    get_signal+0x155/0x850    arch_do_signal_or_restart+0xed/0x750    exit_to_user_mode_prepare+0xc5/0x120    syscall_exit_to_user_mode+0x1d/0x40    do_syscall_64+0x48/0xc0    entry_SYSCALL_64_after_hwframe+0x44/0xae  If kvm_tdp_mmu_zap_all() skips a gfn/SPTE but that SPTE is then zapped by kvm_tdp_mmu_put_root(), KVM triggers a use-after-free in the form of marking a struct page as dirty/accessed after it has been put back on the free list.  This directly triggers a WARN due to encountering a page with page_count() == 0, but it can also lead to data corruption and additional errors in the kernel.    WARNING: CPU: 7 PID: 1995658 at arch/x86/kvm/../../../virt/kvm/kvm_main.c:171   RIP: 0010:kvm_is_zone_device_pfn.part.0+0x9e/0xd0 [kvm]   Call Trace:    \u003cTASK\u003e    kvm_set_pfn_dirty+0x120/0x1d0 [kvm]    __handle_changed_spte+0x92e/0xca0 [kvm]    __handle_changed_spte+0x63c/0xca0 [kvm]    __handle_changed_spte+0x63c/0xca0 [kvm]    __handle_changed_spte+0x63c/0xca0 [kvm]    zap_gfn_range+0x549/0x620 [kvm]    kvm_tdp_mmu_put_root+0x1b6/0x270 [kvm]    mmu_free_root_page+0x219/0x2c0 [kvm]    kvm_mmu_free_roots+0x1b4/0x4e0 [kvm]    kvm_mmu_unload+0x1c/0xa0 [kvm]    kvm_arch_destroy_vm+0x1f2/0x5c0 [kvm]    kvm_put_kvm+0x3b1/0x8b0 [kvm]    kvm_vcpu_release+0x4e/0x70 [kvm]    __fput+0x1f7/0x8c0    task_work_run+0xf8/0x1a0    do_exit+0x97b/0x2230    do_group_exit+0xda/0x2a0    get_signal+0x3be/0x1e50    arch_do_signal_or_restart+0x244/0x17f0    exit_to_user_mode_prepare+0xcb/0x120    syscall_exit_to_user_mode+0x1d/0x40    do_syscall_64+0x4d/0x90    entry_SYSCALL_64_after_hwframe+0x44/0xae  Note, the underlying bug existed even before commit 1af4a96025b3 (\"KVM: x86/mmu: Yield in TDU MMU iter even if no SPTES changed\") moved calls to tdp_mmu_iter_cond_resched() to the beginning of loops, as KVM could still incorrectly advance past a top-level entry when yielding on a lower-level entry.  But with respect to leaking shadow pages, the bug was introduced by yielding before processing the current gfn.  Alternatively, tdp_mmu_iter_cond_resched() could simply fall through, or callers could jump to their \"retry\" label.  The downside of that approach is that tdp_mmu_iter_cond_resched() _must_ be called before anything else in the loop, and there's no easy way to enfornce that requirement.  Ideally, KVM would handling the cond_resched() fully within the iterator macro (the code is actually quite clean) and avoid this entire class of bugs, but that is extremely difficult do wh ---truncated---",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-47094",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-0841",
            "namespace": "debian:11",
            "description": "A null pointer dereference flaw was found in the hugetlbfs_fill_super function in the Linux kernel hugetlbfs (HugeTLB pages) functionality. This issue may allow a local user to crash the system or potentially escalate their privileges on the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-0841",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-46862",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 6.5.9. During a race with SQ thread exit, an io_uring/fdinfo.c io_uring_show_fdinfo NULL pointer dereference can occur.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-46862",
            "severity": "Negligible",
            "fixedby": "5.10.205-2"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-31085",
            "namespace": "debian:11",
            "description": "An issue was discovered in drivers/mtd/ubi/cdev.c in the Linux kernel 6.2. There is a divide-by-zero error in do_div(sz,mtd-\u003eerasesize), used indirectly by ctrl_cdev_ioctl, when mtd-\u003eerasesize is 0.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-31085",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-4273",
            "namespace": "debian:11",
            "description": "A flaw was found in the exFAT driver of the Linux kernel. The vulnerability exists in the implementation of the file name reconstruction function, which is responsible for reading file name entries from a directory index and merging file name parts belonging to one file into a single long file name. Since the file name characters are copied into a stack variable, a local privileged attacker could use this flaw to overflow the kernel stack.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4273",
            "severity": "Negligible",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-28746",
            "namespace": "debian:11",
            "description": "Information exposure through microarchitectural state after transient execution from some register files for some Intel(R) Atom(R) Processors may allow an authenticated user to potentially enable information disclosure via local access.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-28746",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2017-13694",
            "namespace": "debian:11",
            "description": "The acpi_ps_complete_final_op() function in drivers/acpi/acpica/psobject.c in the Linux kernel through 4.12.9 does not flush the node and node_ext caches and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2017-13694",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2011-4917",
            "namespace": "debian:11",
            "description": "In the Linux kernel through 3.1 there is an information disclosure issue via /proc/stat.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2011-4917",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52462",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: fix check for attempt to corrupt spilled pointer  When register is spilled onto a stack as a 1/2/4-byte register, we set slot_type[BPF_REG_SIZE - 1] (plus potentially few more below it, depending on actual spill size). So to check if some stack slot has spilled register we need to consult slot_type[7], not slot_type[0].  To avoid the need to remember and double-check this in the future, just use is_spilled_reg() helper.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52462",
            "severity": "Negligible",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2008-2544",
            "namespace": "debian:11",
            "description": "Mounting /proc filesystem via chroot command silently mounts it in read-write mode. The user could bypass the chroot environment and gain write access to files, he would never have otherwise.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2008-2544",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "openssl",
            "featureversion": "1.1.1n-0+deb11u3",
            "vulnerability": "CVE-2007-6755",
            "namespace": "debian:11",
            "description": "The NIST SP 800-90A default statement of the Dual Elliptic Curve Deterministic Random Bit Generation (Dual_EC_DRBG) algorithm contains point Q constants with a possible relationship to certain \"skeleton key\" values, which might allow context-dependent attackers to defeat cryptographic protection mechanisms by leveraging knowledge of those values.  NOTE: this is a preliminary CVE for Dual_EC_DRBG; future research may provide additional details about point Q and associated attacks, and could potentially lead to a RECAST or REJECT of this CVE.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2007-6755",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52454",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  nvmet-tcp: Fix a kernel panic when host sends an invalid H2C PDU length  If the host sends an H2CData command with an invalid DATAL, the kernel may crash in nvmet_tcp_build_pdu_iovec().  Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000 lr : nvmet_tcp_io_work+0x6ac/0x718 [nvmet_tcp] Call trace:   process_one_work+0x174/0x3c8   worker_thread+0x2d0/0x3e8   kthread+0x104/0x110  Fix the bug by raising a fatal error if DATAL isn't coherent with the packet size. Also, the PDU length should never exceed the MAXH2CDATA parameter which has been communicated to the host in nvmet_tcp_handle_icreq().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52454",
            "severity": "Negligible",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "tar",
            "featureversion": "1.34+dfsg-1",
            "vulnerability": "CVE-2022-48303",
            "namespace": "debian:11",
            "description": "GNU Tar through 1.34 has a one-byte out-of-bounds read that results in use of uninitialized memory for a conditional jump. Exploitation to change the flow of control has not been demonstrated. The issue occurs in from_header in list.c via a V7 archive in which mtime has approximately 11 whitespace characters.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-48303",
            "severity": "Negligible",
            "fixedby": "1.34+dfsg-1+deb11u1"
        },
        {
            "featurename": "openssl",
            "featureversion": "1.1.1n-0+deb11u3",
            "vulnerability": "CVE-2010-0928",
            "namespace": "debian:11",
            "description": "OpenSSL 0.9.8i on the Gaisler Research LEON3 SoC on the Xilinx Virtex-II Pro FPGA uses a Fixed Width Exponentiation (FWE) algorithm for certain signature calculations, and does not verify the signature before providing it to a caller, which makes it easier for physically proximate attackers to determine the private key via a modified supply voltage for the microprocessor, related to a \"fault-based attack.\"",
            "link": "https://security-tracker.debian.org/tracker/CVE-2010-0928",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-2166",
            "namespace": "debian:11",
            "description": "A null pointer dereference issue was found in can protocol in net/can/af_can.c in the Linux before Linux. ml_priv may not be initialized in the receive path of CAN frames. A local user could use this flaw to crash the system or potentially cause a denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-2166",
            "severity": "Negligible",
            "fixedby": "5.10.162-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-3114",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 5.16-rc6. imx_register_uart_clocks in drivers/clk/imx/clk.c lacks check of the return value of kcalloc() and will cause the null pointer dereference.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-3114",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2021-26934",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel 4.18 through 5.10.16, as used by Xen. The backend allocation (aka be-alloc) mode of the drm_xen_front drivers was not meant to be a supported configuration, but this wasn't stated accordingly in its support status entry.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-26934",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26639",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  mm, kmsan: fix infinite recursion due to RCU critical section  Alexander Potapenko writes in [1]: \"For every memory access in the code instrumented by KMSAN we call kmsan_get_metadata() to obtain the metadata for the memory being accessed.  For virtual memory the metadata pointers are stored in the corresponding `struct page`, therefore we need to call virt_to_page() to get them.  According to the comment in arch/x86/include/asm/page.h, virt_to_page(kaddr) returns a valid pointer iff virt_addr_valid(kaddr) is true, so KMSAN needs to call virt_addr_valid() as well.  To avoid recursion, kmsan_get_metadata() must not call instrumented code, therefore ./arch/x86/include/asm/kmsan.h forks parts of arch/x86/mm/physaddr.c to check whether a virtual address is valid or not.  But the introduction of rcu_read_lock() to pfn_valid() added instrumented RCU API calls to virt_to_page_or_null(), which is called by kmsan_get_metadata(), so there is an infinite recursion now.  I do not think it is correct to stop that recursion by doing kmsan_enter_runtime()/kmsan_exit_runtime() in kmsan_get_metadata(): that would prevent instrumented functions called from within the runtime from tracking the shadow values, which might introduce false positives.\"  Fix the issue by switching pfn_valid() to the _sched() variant of rcu_read_lock/unlock(), which does not require calling into RCU.  Given the critical section in pfn_valid() is very small, this is a reasonable trade-off (with preemptible RCU).  KMSAN further needs to be careful to suppress calls into the scheduler, which would be another source of recursion.  This can be done by wrapping the call to pfn_valid() into preempt_disable/enable_no_resched().  The downside is that this sacrifices breaking scheduling guarantees; however, a kernel compiled with KMSAN has already given up any performance guarantees due to being heavily instrumented.  Note, KMSAN code already disables tracing via Makefile, and since mmzone.h is included, it is not necessary to use the notrace variant, which is generally preferred in all other cases.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26639",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2019-16233",
            "namespace": "debian:11",
            "description": "drivers/scsi/qla2xxx/qla_os.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-16233",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "libarchive",
            "featureversion": "3.4.3-2+deb11u1",
            "vulnerability": "CVE-2021-36976",
            "namespace": "debian:11",
            "description": "libarchive 3.4.1 through 3.5.1 has a use-after-free in copy_string (called from do_uncompress_block and process_block).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-36976",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-6610",
            "namespace": "debian:11",
            "description": "An out-of-bounds read vulnerability was found in smb2_dump_detail in fs/smb/client/smb2ops.c in the Linux Kernel. This issue could allow a local attacker to crash the system or leak internal kernel information.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-6610",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26589",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Reject variable offset alu on PTR_TO_FLOW_KEYS  For PTR_TO_FLOW_KEYS, check_flow_keys_access() only uses fixed off for validation. However, variable offset ptr alu is not prohibited for this ptr kind. So the variable offset is not checked.  The following prog is accepted:    func#0 @0   0: R1=ctx() R10=fp0   0: (bf) r6 = r1                       ; R1=ctx() R6_w=ctx()   1: (79) r7 = *(u64 *)(r6 +144)        ; R6_w=ctx() R7_w=flow_keys()   2: (b7) r8 = 1024                     ; R8_w=1024   3: (37) r8 /= 1                       ; R8_w=scalar()   4: (57) r8 \u0026= 1024                    ; R8_w=scalar(smin=smin32=0,   smax=umax=smax32=umax32=1024,var_off=(0x0; 0x400))   5: (0f) r7 += r8   mark_precise: frame0: last_idx 5 first_idx 0 subseq_idx -1   mark_precise: frame0: regs=r8 stack= before 4: (57) r8 \u0026= 1024   mark_precise: frame0: regs=r8 stack= before 3: (37) r8 /= 1   mark_precise: frame0: regs=r8 stack= before 2: (b7) r8 = 1024   6: R7_w=flow_keys(smin=smin32=0,smax=umax=smax32=umax32=1024,var_off   =(0x0; 0x400)) R8_w=scalar(smin=smin32=0,smax=umax=smax32=umax32=1024,   var_off=(0x0; 0x400))   6: (79) r0 = *(u64 *)(r7 +0)          ; R0_w=scalar()   7: (95) exit  This prog loads flow_keys to r7, and adds the variable offset r8 to r7, and finally causes out-of-bounds access:    BUG: unable to handle page fault for address: ffffc90014c80038   [...]   Call Trace:    \u003cTASK\u003e    bpf_dispatcher_nop_func include/linux/bpf.h:1231 [inline]    __bpf_prog_run include/linux/filter.h:651 [inline]    bpf_prog_run include/linux/filter.h:658 [inline]    bpf_prog_run_pin_on_cpu include/linux/filter.h:675 [inline]    bpf_flow_dissect+0x15f/0x350 net/core/flow_dissector.c:991    bpf_prog_test_run_flow_dissector+0x39d/0x620 net/bpf/test_run.c:1359    bpf_prog_test_run kernel/bpf/syscall.c:4107 [inline]    __sys_bpf+0xf8f/0x4560 kernel/bpf/syscall.c:5475    __do_sys_bpf kernel/bpf/syscall.c:5561 [inline]    __se_sys_bpf kernel/bpf/syscall.c:5559 [inline]    __x64_sys_bpf+0x73/0xb0 kernel/bpf/syscall.c:5559    do_syscall_x64 arch/x86/entry/common.c:52 [inline]    do_syscall_64+0x3f/0x110 arch/x86/entry/common.c:83    entry_SYSCALL_64_after_hwframe+0x63/0x6b  Fix this by rejecting ptr alu with variable offset on flow_keys. Applying the patch rejects the program with \"R7 pointer arithmetic on flow_keys prohibited\".",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26589",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52575",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  x86/srso: Fix SBPB enablement for spec_rstack_overflow=off  If the user has requested no SRSO mitigation, other mitigations can use the lighter-weight SBPB instead of IBPB.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52575",
            "severity": "Negligible",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-23000",
            "namespace": "debian:11",
            "description": "In the Linux kernel before 5.17, drivers/phy/tegra/xusb.c mishandles the tegra_xusb_find_port_node return value. Callers expect NULL in the error case, but an error pointer is used.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-23000",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52448",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  gfs2: Fix kernel NULL pointer dereference in gfs2_rgrp_dump  Syzkaller has reported a NULL pointer dereference when accessing rgd-\u003erd_rgl in gfs2_rgrp_dump().  This can happen when creating rgd-\u003erd_gl fails in read_rindex_entry().  Add a NULL pointer check in gfs2_rgrp_dump() to prevent that.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52448",
            "severity": "Negligible",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "libarchive",
            "featureversion": "3.4.3-2+deb11u1",
            "vulnerability": "CVE-2022-26280",
            "namespace": "debian:11",
            "description": "Libarchive v3.6.0 was discovered to contain an out-of-bounds read via the component zipx_lzma_alone_init.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-26280",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26581",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  netfilter: nft_set_rbtree: skip end interval element from gc  rbtree lazy gc on insert might collect an end interval element that has been just added in this transactions, skip end interval elements that are not yet active.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26581",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-40133",
            "namespace": "debian:11",
            "description": "A use-after-free(UAF) vulnerability was found in function 'vmw_execbuf_tie_context' in drivers/gpu/vmxgfx/vmxgfx_execbuf.c in Linux kernel's vmwgfx driver with device file '/dev/dri/renderD128 (or Dxxx)'. This flaw allows a local attacker with a user account on the system to gain privilege, causing a denial of service(DoS).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-40133",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-3424",
            "namespace": "debian:11",
            "description": "A use-after-free flaw was found in the Linux kernel’s SGI GRU driver in the way the first gru_file_unlocked_ioctl function is called by the user, where a fail pass occurs in the gru_check_chiplet_assignment function. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-3424",
            "severity": "Negligible",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-31081",
            "namespace": "debian:11",
            "description": "An issue was discovered in drivers/media/test-drivers/vidtv/vidtv_bridge.c in the Linux kernel 6.2. There is a NULL pointer dereference in vidtv_mux_stop_thread. In vidtv_stop_streaming, after dvb-\u003emux=NULL occurs, it executes vidtv_mux_stop_thread(dvb-\u003emux).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-31081",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2018-1121",
            "namespace": "debian:11",
            "description": "procps-ng, procps is vulnerable to a process hiding through race condition. Since the kernel's proc_pid_readdir() returns PID entries in ascending numeric order, a process occupying a high PID can use inotify events to determine when the process list is being scanned, and fork/exec to obtain a lower PID, thus avoiding enumeration. An unprivileged attacker can hide a process from procps-ng's utilities by exploiting a race condition in reading /proc/PID entries. This vulnerability affects procps and procps-ng up to version 3.3.15, newer versions might be affected also.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2018-1121",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2015-2877",
            "namespace": "debian:11",
            "description": "Kernel Samepage Merging (KSM) in the Linux kernel 2.6.32 through 4.x does not prevent use of a write-timing side channel, which allows guest OS users to defeat the ASLR protection mechanism on other guest OS instances via a Cross-VM ASL INtrospection (CAIN) attack.  NOTE: the vendor states \"Basically if you care about this attack vector, disable deduplication.\" Share-until-written approaches for memory conservation among mutually untrusting tenants are inherently detectable for information disclosure, and can be classified as potentially misunderstood behaviors rather than vulnerabilities",
            "link": "https://security-tracker.debian.org/tracker/CVE-2015-2877",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-28327",
            "namespace": "debian:11",
            "description": "A NULL pointer dereference flaw was found in the UNIX protocol in net/unix/diag.c In unix_diag_get_exact in the Linux Kernel. The newly allocated skb does not have sk, leading to a NULL pointer. This flaw allows a local user to crash or potentially cause a denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-28327",
            "severity": "Negligible",
            "fixedby": "5.10.162-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-3773",
            "namespace": "debian:11",
            "description": "A flaw was found in the Linux kernel’s IP framework for transforming packets (XFRM subsystem). This issue may allow a malicious user with CAP_NET_ADMIN privileges to cause a 4 byte out-of-bounds read of XFRMA_MTIMER_THRESH when parsing netlink attributes, leading to potential leakage of sensitive heap data to userspace.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3773",
            "severity": "Negligible",
            "fixedby": "5.10.197-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-23003",
            "namespace": "debian:11",
            "description": "In the Linux kernel before 5.16, tools/perf/util/expr.c lacks a check for the hashmap__new return value.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-23003",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-0400",
            "namespace": "debian:11",
            "description": "An out-of-bounds read vulnerability was discovered in linux kernel in the smc protocol stack, causing remote dos.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-0400",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-4696",
            "namespace": "debian:11",
            "description": "There exists a use-after-free vulnerability in the Linux kernel through io_uring and the IORING_OP_SPLICE operation. If IORING_OP_SPLICE is missing the IO_WQ_WORK_FILES flag, which signals that the operation won't use current-\u003ensproxy, so its reference counter is not increased. This assumption is not always true as calling io_splice on specific files will call the get_uts function which will use current-\u003ensproxy leading to invalidly decreasing its reference counter later causing the use-after-free vulnerability. We recommend upgrading to version 5.10.160 or above",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-4696",
            "severity": "Negligible",
            "fixedby": "5.10.162-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2021-47105",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  ice: xsk: return xsk buffers back to pool when cleaning the ring  Currently we only NULL the xdp_buff pointer in the internal SW ring but we never give it back to the xsk buffer pool. This means that buffers can be leaked out of the buff pool and never be used again.  Add missing xsk_buff_free() call to the routine that is supposed to clean the entries that are left in the ring so that these buffers in the umem can be used by other sockets.  Also, only go through the space that is actually left to be cleaned instead of a whole ring.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-47105",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-30772",
            "namespace": "debian:11",
            "description": "The Linux kernel before 6.2.9 has a race condition and resultant use-after-free in drivers/power/supply/da9150-charger.c if a physically proximate attacker unplugs a device.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-30772",
            "severity": "Negligible",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26583",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  tls: fix race between async notify and socket close  The submitting thread (one which called recvmsg/sendmsg) may exit as soon as the async crypto handler calls complete() so any code past that point risks touching already freed data.  Try to avoid the locking and extra flags altogether. Have the main thread hold an extra reference, this way we can depend solely on the atomic ref counter for synchronization.  Don't futz with reiniting the completion, either, we are now tightly controlling when completion fires.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26583",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2019-19070",
            "namespace": "debian:11",
            "description": "A memory leak in the spi_gpio_probe() function in drivers/spi/spi-gpio.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering devm_add_action_or_reset() failures, aka CID-d3b0ffa1d75d. NOTE: third parties dispute the relevance of this because the system must have already been out of memory before the probe began",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-19070",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-0641",
            "namespace": "debian:11",
            "description": "A denial of service vulnerability was found in tipc_crypto_key_revoke in net/tipc/crypto.c in the Linux kernel’s TIPC subsystem. This flaw allows guests with local user privileges to trigger a deadlock and potentially crash the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-0641",
            "severity": "Negligible",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-23586",
            "namespace": "debian:11",
            "description": "Due to a vulnerability in the io_uring subsystem, it is possible to leak kernel memory information to the user process. timens_install calls current_is_single_threaded to determine if the current process is single-threaded, but this call does not consider io_uring's io_worker threads, thus it is possible to insert a time namespace's vvar page to process's memory space via a page fault. When this time namespace is destroyed, the vvar page is also freed, but not removed from the process' memory, and a next page allocated by the kernel will be still available from the user-space process and can leak memory contents via this (read-only) use-after-free vulnerability. We recommend upgrading past version 5.10.161 or commit  788d0824269bef539fe31a785b1517882eafed93 https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/io_uring",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-23586",
            "severity": "Negligible",
            "fixedby": "5.10.162-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-35829",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel before 6.3.2. A use-after-free was found in rkvdec_remove in drivers/staging/media/rkvdec/rkvdec.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-35829",
            "severity": "Negligible",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-21102",
            "namespace": "debian:11",
            "description": "In __efi_rt_asm_wrapper of efi-rt-wrapper.S, there is a possible bypass of shadow stack protection due to a logic error in the code. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-260821414References: Upstream kernel",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-21102",
            "severity": "Negligible",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52497",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  erofs: fix lz4 inplace decompression  Currently EROFS can map another compressed buffer for inplace decompression, that was used to handle the cases that some pages of compressed data are actually not in-place I/O.  However, like most simple LZ77 algorithms, LZ4 expects the compressed data is arranged at the end of the decompressed buffer and it explicitly uses memmove() to handle overlapping:   __________________________________________________________  |_ direction of decompression --\u003e ____ |_ compressed data _|  Although EROFS arranges compressed data like this, it typically maps two individual virtual buffers so the relative order is uncertain. Previously, it was hardly observed since LZ4 only uses memmove() for short overlapped literals and x86/arm64 memmove implementations seem to completely cover it up and they don't have this issue.  Juhyung reported that EROFS data corruption can be found on a new Intel x86 processor. After some analysis, it seems that recent x86 processors with the new FSRM feature expose this issue with \"rep movsb\".  Let's strictly use the decompressed buffer for lz4 inplace decompression for now.  Later, as an useful improvement, we could try to tie up these two buffers together in the correct order.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52497",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-31248",
            "namespace": "debian:11",
            "description": "Linux Kernel nftables Use-After-Free Local Privilege Escalation Vulnerability; `nft_chain_lookup_byid()` failed to check whether a chain was active and CAP_NET_ADMIN is in any user or network namespace",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-31248",
            "severity": "Negligible",
            "fixedby": "5.10.179-2"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52438",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  binder: fix use-after-free in shinker's callback  The mmap read lock is used during the shrinker's callback, which means that using alloc-\u003evma pointer isn't safe as it can race with munmap(). As of commit dd2283f2605e (\"mm: mmap: zap pages with read mmap_sem in munmap\") the mmap lock is downgraded after the vma has been isolated.  I was able to reproduce this issue by manually adding some delays and triggering page reclaiming through the shrinker's debug sysfs. The following KASAN report confirms the UAF:    ==================================================================   BUG: KASAN: slab-use-after-free in zap_page_range_single+0x470/0x4b8   Read of size 8 at addr ffff356ed50e50f0 by task bash/478    CPU: 1 PID: 478 Comm: bash Not tainted 6.6.0-rc5-00055-g1c8b86a3799f-dirty #70   Hardware name: linux,dummy-virt (DT)   Call trace:    zap_page_range_single+0x470/0x4b8    binder_alloc_free_page+0x608/0xadc    __list_lru_walk_one+0x130/0x3b0    list_lru_walk_node+0xc4/0x22c    binder_shrink_scan+0x108/0x1dc    shrinker_debugfs_scan_write+0x2b4/0x500    full_proxy_write+0xd4/0x140    vfs_write+0x1ac/0x758    ksys_write+0xf0/0x1dc    __arm64_sys_write+0x6c/0x9c    Allocated by task 492:    kmem_cache_alloc+0x130/0x368    vm_area_alloc+0x2c/0x190    mmap_region+0x258/0x18bc    do_mmap+0x694/0xa60    vm_mmap_pgoff+0x170/0x29c    ksys_mmap_pgoff+0x290/0x3a0    __arm64_sys_mmap+0xcc/0x144    Freed by task 491:    kmem_cache_free+0x17c/0x3c8    vm_area_free_rcu_cb+0x74/0x98    rcu_core+0xa38/0x26d4    rcu_core_si+0x10/0x1c    __do_softirq+0x2fc/0xd24    Last potentially related work creation:    __call_rcu_common.constprop.0+0x6c/0xba0    call_rcu+0x10/0x1c    vm_area_free+0x18/0x24    remove_vma+0xe4/0x118    do_vmi_align_munmap.isra.0+0x718/0xb5c    do_vmi_munmap+0xdc/0x1fc    __vm_munmap+0x10c/0x278    __arm64_sys_munmap+0x58/0x7c  Fix this issue by performing instead a vma_lookup() which will fail to find the vma that was isolated before the mmap lock downgrade. Note that this option has better performance than upgrading to a mmap write lock which would increase contention. Plus, mmap_write_trylock() has been recently removed anyway.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52438",
            "severity": "Negligible",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-25265",
            "namespace": "debian:11",
            "description": "In the Linux kernel through 5.16.10, certain binary files may have the exec-all attribute if they were built in approximately 2003 (e.g., with GCC 3.2.2 and Linux kernel 2.4.20). This can cause execution of bytes located in supposedly non-executable regions of a file.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-25265",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-1611",
            "namespace": "debian:11",
            "description": "A use-after-free flaw was found in btrfs_search_slot in fs/btrfs/ctree.c in btrfs in the Linux Kernel.This flaw allows an attacker to crash the system and possibly cause a kernel information lea",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1611",
            "severity": "Negligible",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2019-16234",
            "namespace": "debian:11",
            "description": "drivers/net/wireless/intel/iwlwifi/pcie/trans.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-16234",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-5197",
            "namespace": "debian:11",
            "description": "A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation.  Addition and removal of rules from chain bindings within the same transaction causes leads to use-after-free.  We recommend upgrading past commit f15f29fd4779be8a418b66e9d52979bb6d6c2325.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-5197",
            "severity": "Negligible",
            "fixedby": "5.10.205-2"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-0179",
            "namespace": "debian:11",
            "description": "A buffer overflow vulnerability was found in the Netfilter subsystem in the Linux Kernel. This issue could allow the leakage of both stack and heap addresses, and potentially allow Local Privilege Escalation to the root user via arbitrary code execution.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-0179",
            "severity": "Negligible",
            "fixedby": "5.10.162-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-3141",
            "namespace": "debian:11",
            "description": "A use-after-free flaw was found in r592_remove in drivers/memstick/host/r592.c in media access in the Linux Kernel. This flaw allows a local attacker to crash the system at device disconnect, possibly leading to a kernel information leak.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3141",
            "severity": "Negligible",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2021-47070",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  uio_hv_generic: Fix another memory leak in error handling paths  Memory allocated by 'vmbus_alloc_ring()' at the beginning of the probe function is never freed in the error handling path.  Add the missing 'vmbus_free_ring()' call.  Note that it is already freed in the .remove function.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-47070",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52494",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  bus: mhi: host: Add alignment check for event ring read pointer  Though we do check the event ring read pointer by \"is_valid_ring_ptr\" to make sure it is in the buffer range, but there is another risk the pointer may be not aligned.  Since we are expecting event ring elements are 128 bits(struct mhi_ring_element) aligned, an unaligned read pointer could lead to multiple issues like DoS or ring buffer memory corruption.  So add a alignment check for event ring read pointer.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52494",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2019-16230",
            "namespace": "debian:11",
            "description": "drivers/gpu/drm/radeon/radeon_display.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference. NOTE: A third-party software maintainer states that the work queue allocation is happening during device initialization, which for a graphics card occurs during boot. It is not attacker controllable and OOM at that time is highly unlikely",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-16230",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-6531",
            "namespace": "debian:11",
            "description": "A use-after-free flaw was found in the Linux Kernel due to a race problem in the unix garbage collector's deletion of SKB races with unix_stream_read_generic() on the socket that the SKB is queued on.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-6531",
            "severity": "Negligible",
            "fixedby": "5.10.205-2"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26607",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/bridge: sii902x: Fix probing race issue  A null pointer dereference crash has been observed rarely on TI platforms using sii9022 bridge:  [   53.271356]  sii902x_get_edid+0x34/0x70 [sii902x] [   53.276066]  sii902x_bridge_get_edid+0x14/0x20 [sii902x] [   53.281381]  drm_bridge_get_edid+0x20/0x34 [drm] [   53.286305]  drm_bridge_connector_get_modes+0x8c/0xcc [drm_kms_helper] [   53.292955]  drm_helper_probe_single_connector_modes+0x190/0x538 [drm_kms_helper] [   53.300510]  drm_client_modeset_probe+0x1f0/0xbd4 [drm] [   53.305958]  __drm_fb_helper_initial_config_and_unlock+0x50/0x510 [drm_kms_helper] [   53.313611]  drm_fb_helper_initial_config+0x48/0x58 [drm_kms_helper] [   53.320039]  drm_fbdev_dma_client_hotplug+0x84/0xd4 [drm_dma_helper] [   53.326401]  drm_client_register+0x5c/0xa0 [drm] [   53.331216]  drm_fbdev_dma_setup+0xc8/0x13c [drm_dma_helper] [   53.336881]  tidss_probe+0x128/0x264 [tidss] [   53.341174]  platform_probe+0x68/0xc4 [   53.344841]  really_probe+0x188/0x3c4 [   53.348501]  __driver_probe_device+0x7c/0x16c [   53.352854]  driver_probe_device+0x3c/0x10c [   53.357033]  __device_attach_driver+0xbc/0x158 [   53.361472]  bus_for_each_drv+0x88/0xe8 [   53.365303]  __device_attach+0xa0/0x1b4 [   53.369135]  device_initial_probe+0x14/0x20 [   53.373314]  bus_probe_device+0xb0/0xb4 [   53.377145]  deferred_probe_work_func+0xcc/0x124 [   53.381757]  process_one_work+0x1f0/0x518 [   53.385770]  worker_thread+0x1e8/0x3dc [   53.389519]  kthread+0x11c/0x120 [   53.392750]  ret_from_fork+0x10/0x20  The issue here is as follows:  - tidss probes, but is deferred as sii902x is still missing. - sii902x starts probing and enters sii902x_init(). - sii902x calls drm_bridge_add(). Now the sii902x bridge is ready from   DRM's perspective. - sii902x calls sii902x_audio_codec_init() and   platform_device_register_data() - The registration of the audio platform device causes probing of the   deferred devices. - tidss probes, which eventually causes sii902x_bridge_get_edid() to be   called. - sii902x_bridge_get_edid() tries to use the i2c to read the edid.   However, the sii902x driver has not set up the i2c part yet, leading   to the crash.  Fix this by moving the drm_bridge_add() to the end of the sii902x_init(), which is also at the very end of sii902x_probe().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26607",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-1075",
            "namespace": "debian:11",
            "description": "A flaw was found in the Linux Kernel. The tls_is_tx_ready() incorrectly checks for list emptiness, potentially accessing a type confused entry to the list_head, leaking the last byte of the confused field that overlaps with rec-\u003etx_ready.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1075",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-45919",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 6.0.10. In drivers/media/dvb-core/dvb_ca_en50221.c, a use-after-free can occur is there is a disconnect after an open, because of the lack of a wait_event.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-45919",
            "severity": "Negligible",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-1192",
            "namespace": "debian:11",
            "description": "A use-after-free flaw was found in smb2_is_status_io_timeout() in CIFS in the Linux Kernel. After CIFS transfers response data to a system call, there are still local variable points to the memory region, and if the system call frees it faster than CIFS uses it, CIFS will access a free memory region, leading to a denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1192",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52457",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  serial: 8250: omap: Don't skip resource freeing if pm_runtime_resume_and_get() failed  Returning an error code from .remove() makes the driver core emit the little helpful error message:  \tremove callback returned a non-zero value. This will be ignored.  and then remove the device anyhow. So all resources that were not freed are leaked in this case. Skipping serial8250_unregister_port() has the potential to keep enough of the UART around to trigger a use-after-free.  So replace the error return (and with it the little helpful error message) by a more useful error message and continue to cleanup.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52457",
            "severity": "Negligible",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26643",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  netfilter: nf_tables: mark set as dead when unbinding anonymous set with timeout  While the rhashtable set gc runs asynchronously, a race allows it to collect elements from anonymous sets with timeouts while it is being released from the commit path.  Mingi Cho originally reported this issue in a different path in 6.1.x with a pipapo set with low timeouts which is not possible upstream since 7395dfacfff6 (\"netfilter: nf_tables: use timestamp to check for set element timeout\").  Fix this by setting on the dead flag for anonymous sets to skip async gc in this case.  According to 08e4c8c5919f (\"netfilter: nf_tables: mark newset as dead on transaction abort\"), Florian plans to accelerate abort path by releasing objects via workqueue, therefore, this sets on the dead flag for abort path too.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26643",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52569",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: remove BUG() after failure to insert delayed dir index item  Instead of calling BUG() when we fail to insert a delayed dir index item into the delayed node's tree, we can just release all the resources we have allocated/acquired before and return the error to the caller. This is fine because all existing call chains undo anything they have done before calling btrfs_insert_delayed_dir_index() or BUG_ON (when creating pending snapshots in the transaction commit path).  So remove the BUG() call and do proper error handling.  This relates to a syzbot report linked below, but does not fix it because it only prevents hitting a BUG(), it does not fix the issue where somehow we attempt to use twice the same index number for different index items.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52569",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-39193",
            "namespace": "debian:11",
            "description": "A flaw was found in the Netfilter subsystem in the Linux kernel. The sctp_mt_check did not validate the flag_count field. This flaw allows a local privileged (CAP_NET_ADMIN) attacker to trigger an out-of-bounds read, leading to a crash or information disclosure.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-39193",
            "severity": "Unknown",
            "fixedby": "5.10.197-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-3567",
            "namespace": "debian:11",
            "description": "A vulnerability has been found in Linux Kernel and classified as problematic. This vulnerability affects the function inet6_stream_ops/inet6_dgram_ops of the component IPv6 Handler. The manipulation leads to race condition. It is recommended to apply a patch to fix this issue. VDB-211090 is the identifier assigned to this vulnerability.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-3567",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52578",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  net: bridge: use DEV_STATS_INC()  syzbot/KCSAN reported data-races in br_handle_frame_finish() [1] This function can run from multiple cpus without mutual exclusion.  Adopt SMP safe DEV_STATS_INC() to update dev-\u003estats fields.  Handles updates to dev-\u003estats.tx_dropped while we are at it.  [1] BUG: KCSAN: data-race in br_handle_frame_finish / br_handle_frame_finish  read-write to 0xffff8881374b2178 of 8 bytes by interrupt on cpu 1: br_handle_frame_finish+0xd4f/0xef0 net/bridge/br_input.c:189 br_nf_hook_thresh+0x1ed/0x220 br_nf_pre_routing_finish_ipv6+0x50f/0x540 NF_HOOK include/linux/netfilter.h:304 [inline] br_nf_pre_routing_ipv6+0x1e3/0x2a0 net/bridge/br_netfilter_ipv6.c:178 br_nf_pre_routing+0x526/0xba0 net/bridge/br_netfilter_hooks.c:508 nf_hook_entry_hookfn include/linux/netfilter.h:144 [inline] nf_hook_bridge_pre net/bridge/br_input.c:272 [inline] br_handle_frame+0x4c9/0x940 net/bridge/br_input.c:417 __netif_receive_skb_core+0xa8a/0x21e0 net/core/dev.c:5417 __netif_receive_skb_one_core net/core/dev.c:5521 [inline] __netif_receive_skb+0x57/0x1b0 net/core/dev.c:5637 process_backlog+0x21f/0x380 net/core/dev.c:5965 __napi_poll+0x60/0x3b0 net/core/dev.c:6527 napi_poll net/core/dev.c:6594 [inline] net_rx_action+0x32b/0x750 net/core/dev.c:6727 __do_softirq+0xc1/0x265 kernel/softirq.c:553 run_ksoftirqd+0x17/0x20 kernel/softirq.c:921 smpboot_thread_fn+0x30a/0x4a0 kernel/smpboot.c:164 kthread+0x1d7/0x210 kernel/kthread.c:388 ret_from_fork+0x48/0x60 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:304  read-write to 0xffff8881374b2178 of 8 bytes by interrupt on cpu 0: br_handle_frame_finish+0xd4f/0xef0 net/bridge/br_input.c:189 br_nf_hook_thresh+0x1ed/0x220 br_nf_pre_routing_finish_ipv6+0x50f/0x540 NF_HOOK include/linux/netfilter.h:304 [inline] br_nf_pre_routing_ipv6+0x1e3/0x2a0 net/bridge/br_netfilter_ipv6.c:178 br_nf_pre_routing+0x526/0xba0 net/bridge/br_netfilter_hooks.c:508 nf_hook_entry_hookfn include/linux/netfilter.h:144 [inline] nf_hook_bridge_pre net/bridge/br_input.c:272 [inline] br_handle_frame+0x4c9/0x940 net/bridge/br_input.c:417 __netif_receive_skb_core+0xa8a/0x21e0 net/core/dev.c:5417 __netif_receive_skb_one_core net/core/dev.c:5521 [inline] __netif_receive_skb+0x57/0x1b0 net/core/dev.c:5637 process_backlog+0x21f/0x380 net/core/dev.c:5965 __napi_poll+0x60/0x3b0 net/core/dev.c:6527 napi_poll net/core/dev.c:6594 [inline] net_rx_action+0x32b/0x750 net/core/dev.c:6727 __do_softirq+0xc1/0x265 kernel/softirq.c:553 do_softirq+0x5e/0x90 kernel/softirq.c:454 __local_bh_enable_ip+0x64/0x70 kernel/softirq.c:381 __raw_spin_unlock_bh include/linux/spinlock_api_smp.h:167 [inline] _raw_spin_unlock_bh+0x36/0x40 kernel/locking/spinlock.c:210 spin_unlock_bh include/linux/spinlock.h:396 [inline] batadv_tt_local_purge+0x1a8/0x1f0 net/batman-adv/translation-table.c:1356 batadv_tt_purge+0x2b/0x630 net/batman-adv/translation-table.c:3560 process_one_work kernel/workqueue.c:2630 [inline] process_scheduled_works+0x5b8/0xa30 kernel/workqueue.c:2703 worker_thread+0x525/0x730 kernel/workqueue.c:2784 kthread+0x1d7/0x210 kernel/kthread.c:388 ret_from_fork+0x48/0x60 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:304  value changed: 0x00000000000d7190 -\u003e 0x00000000000d7191  Reported by Kernel Concurrency Sanitizer on: CPU: 0 PID: 14848 Comm: kworker/u4:11 Not tainted 6.6.0-rc1-syzkaller-00236-gad8a69f361b9 #0",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52578",
            "severity": "Unknown",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-1078",
            "namespace": "debian:11",
            "description": "A flaw was found in the Linux Kernel in RDS (Reliable Datagram Sockets) protocol. The rds_rm_zerocopy_callback() uses list_entry() on the head of a list causing a type confusion. Local user can trigger this with rds_message_put(). Type confusion leads to `struct rds_msg_zcopy_info *info` actually points to something else that is potentially controlled by local user. It is known how to trigger this, which causes an out of bounds access, and a lock corruption.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1078",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52501",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  ring-buffer: Do not attempt to read past \"commit\"  When iterating over the ring buffer while the ring buffer is active, the writer can corrupt the reader. There's barriers to help detect this and handle it, but that code missed the case where the last event was at the very end of the page and has only 4 bytes left.  The checks to detect the corruption by the writer to reads needs to see the length of the event. If the length in the first 4 bytes is zero then the length is stored in the second 4 bytes. But if the writer is in the process of updating that code, there's a small window where the length in the first 4 bytes could be zero even though the length is only 4 bytes. That will cause rb_event_length() to read the next 4 bytes which could happen to be off the allocated page.  To protect against this, fail immediately if the next event pointer is less than 8 bytes from the end of the commit (last byte of data), as all events must be a minimum of 8 bytes anyway.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52501",
            "severity": "Unknown",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26602",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  sched/membarrier: reduce the ability to hammer on sys_membarrier  On some systems, sys_membarrier can be very expensive, causing overall slowdowns for everything.  So put a lock on the path in order to serialize the accesses to prevent the ability for this to be called at too high of a frequency and saturate the machine.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26602",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-1859",
            "namespace": "debian:11",
            "description": "A use-after-free flaw was found in xen_9pfs_front_removet in net/9p/trans_xen.c in Xen transport for 9pfs in the Linux Kernel. This flaw could allow a local attacker to crash the system due to a race problem, possibly leading to a kernel information leak.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1859",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-40982",
            "namespace": "debian:11",
            "description": "Information exposure through microarchitectural state after transient execution in certain vector execution units for some Intel(R) Processors may allow an authenticated user to potentially enable information disclosure via local access.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-40982",
            "severity": "Unknown",
            "fixedby": "5.10.179-5"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-24858",
            "namespace": "debian:11",
            "description": "A race condition was found in the Linux kernel's net/bluetooth in {conn,adv}_{min,max}_interval_set() function. This can result in I2cap connection or broadcast abnormality issue, possibly leading to denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-24858",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26615",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  net/smc: fix illegal rmb_desc access in SMC-D connection dump  A crash was found when dumping SMC-D connections. It can be reproduced by following steps:  - run nginx/wrk test:   smc_run nginx   smc_run wrk -t 16 -c 1000 -d \u003cduration\u003e -H 'Connection: Close' \u003cURL\u003e  - continuously dump SMC-D connections in parallel:   watch -n 1 'smcss -D'   BUG: kernel NULL pointer dereference, address: 0000000000000030  CPU: 2 PID: 7204 Comm: smcss Kdump: loaded Tainted: G\tE      6.7.0+ #55  RIP: 0010:__smc_diag_dump.constprop.0+0x5e5/0x620 [smc_diag]  Call Trace:   \u003cTASK\u003e   ? __die+0x24/0x70   ? page_fault_oops+0x66/0x150   ? exc_page_fault+0x69/0x140   ? asm_exc_page_fault+0x26/0x30   ? __smc_diag_dump.constprop.0+0x5e5/0x620 [smc_diag]   ? __kmalloc_node_track_caller+0x35d/0x430   ? __alloc_skb+0x77/0x170   smc_diag_dump_proto+0xd0/0xf0 [smc_diag]   smc_diag_dump+0x26/0x60 [smc_diag]   netlink_dump+0x19f/0x320   __netlink_dump_start+0x1dc/0x300   smc_diag_handler_dump+0x6a/0x80 [smc_diag]   ? __pfx_smc_diag_dump+0x10/0x10 [smc_diag]   sock_diag_rcv_msg+0x121/0x140   ? __pfx_sock_diag_rcv_msg+0x10/0x10   netlink_rcv_skb+0x5a/0x110   sock_diag_rcv+0x28/0x40   netlink_unicast+0x22a/0x330   netlink_sendmsg+0x1f8/0x420   __sock_sendmsg+0xb0/0xc0   ____sys_sendmsg+0x24e/0x300   ? copy_msghdr_from_user+0x62/0x80   ___sys_sendmsg+0x7c/0xd0   ? __do_fault+0x34/0x160   ? do_read_fault+0x5f/0x100   ? do_fault+0xb0/0x110   ? __handle_mm_fault+0x2b0/0x6c0   __sys_sendmsg+0x4d/0x80   do_syscall_64+0x69/0x180   entry_SYSCALL_64_after_hwframe+0x6e/0x76  It is possible that the connection is in process of being established when we dump it. Assumed that the connection has been registered in a link group by smc_conn_create() but the rmb_desc has not yet been initialized by smc_buf_create(), thus causing the illegal access to conn-\u003ermb_desc. So fix it by checking before dump.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26615",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-4133",
            "namespace": "debian:11",
            "description": "A use-after-free vulnerability was found in the cxgb4 driver in the Linux kernel. The bug occurs when the cxgb4 device is detaching due to a possible rearming of the flower_stats_timer from the work queue. This flaw allows a local user to crash the system, causing a denial of service condition.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4133",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26584",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  net: tls: handle backlogging of crypto requests  Since we're setting the CRYPTO_TFM_REQ_MAY_BACKLOG flag on our requests to the crypto API, crypto_aead_{encrypt,decrypt} can return  -EBUSY instead of -EINPROGRESS in valid situations. For example, when the cryptd queue for AESNI is full (easy to trigger with an artificially low cryptd.cryptd_max_cpu_qlen), requests will be enqueued to the backlog but still processed. In that case, the async callback will also be called twice: first with err == -EINPROGRESS, which it seems we can just ignore, then with err == 0.  Compared to Sabrina's original patch this version uses the new tls_*crypt_async_wait() helpers and converts the EBUSY to EINPROGRESS to avoid having to modify all the error handling paths. The handling is identical.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26584",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-1989",
            "namespace": "debian:11",
            "description": "A use-after-free flaw was found in btsdio_remove in drivers\\bluetooth\\btsdio.c in the Linux Kernel. In this flaw, a call to btsdio_remove with an unfinished job, may cause a race problem leading to a UAF on hdev devices.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1989",
            "severity": "Unknown",
            "fixedby": "5.10.197-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-0386",
            "namespace": "debian:11",
            "description": "A flaw was found in the Linux kernel, where unauthorized access to the execution of the setuid file with capabilities was found in the Linux kernel’s OverlayFS subsystem in how a user copies a capable file from a nosuid mount into another mount. This uid mapping bug allows a local user to escalate their privileges on the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-0386",
            "severity": "Unknown",
            "fixedby": "5.10.179-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-1513",
            "namespace": "debian:11",
            "description": "A flaw was found in KVM. When calling the KVM_GET_DEBUGREGS ioctl, on 32-bit systems, there might be some uninitialized portions of the kvm_debugregs structure that could be copied to userspace, causing an information leak.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1513",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52619",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  pstore/ram: Fix crash when setting number of cpus to an odd number  When the number of cpu cores is adjusted to 7 or other odd numbers, the zone size will become an odd number. The address of the zone will become:     addr of zone0 = BASE     addr of zone1 = BASE + zone_size     addr of zone2 = BASE + zone_size*2     ... The address of zone1/3/5/7 will be mapped to non-alignment va. Eventually crashes will occur when accessing these va.  So, use ALIGN_DOWN() to make sure the zone size is even to avoid this bug.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52619",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52469",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  drivers/amd/pm: fix a use-after-free in kv_parse_power_table  When ps allocated by kzalloc equals to NULL, kv_parse_power_table frees adev-\u003epm.dpm.ps that allocated before. However, after the control flow goes through the following call chains:  kv_parse_power_table   |-\u003e kv_dpm_init         |-\u003e kv_dpm_sw_init \t      |-\u003e kv_dpm_fini  The adev-\u003epm.dpm.ps is used in the for loop of kv_dpm_fini after its first free in kv_parse_power_table and causes a use-after-free bug.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52469",
            "severity": "Unknown",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-25740",
            "namespace": "debian:11",
            "description": "A memory leak flaw was found in the UBI driver in drivers/mtd/ubi/attach.c in the Linux kernel through 6.7.4 for UBI_IOCATT, because kobj-\u003ename is not released.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-25740",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-23848",
            "namespace": "debian:11",
            "description": "In the Linux kernel through 6.7.1, there is a use-after-free in cec_queue_msg_fh, related to drivers/media/cec/core/cec-adap.c and drivers/media/cec/core/cec-api.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-23848",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-24855",
            "namespace": "debian:11",
            "description": "A race condition was found in the Linux kernel's scsi device driver in lpfc_unregister_fcf_rescan() function. This can result in a null pointer dereference issue, possibly leading to a kernel panic or denial of service issue.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-24855",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52434",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  smb: client: fix potential OOBs in smb2_parse_contexts()  Validate offsets and lengths before dereferencing create contexts in smb2_parse_contexts().  This fixes following oops when accessing invalid create contexts from server:    BUG: unable to handle page fault for address: ffff8881178d8cc3   #PF: supervisor read access in kernel mode   #PF: error_code(0x0000) - not-present page   PGD 4a01067 P4D 4a01067 PUD 0   Oops: 0000 [#1] PREEMPT SMP NOPTI   CPU: 3 PID: 1736 Comm: mount.cifs Not tainted 6.7.0-rc4 #1   Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS   rel-1.16.2-3-gd478f380-rebuilt.opensuse.org 04/01/2014   RIP: 0010:smb2_parse_contexts+0xa0/0x3a0 [cifs]   Code: f8 10 75 13 48 b8 93 ad 25 50 9c b4 11 e7 49 39 06 0f 84 d2 00   00 00 8b 45 00 85 c0 74 61 41 29 c5 48 01 c5 41 83 fd 0f 76 55 \u003c0f\u003e b7   7d 04 0f b7 45 06 4c 8d 74 3d 00 66 83 f8 04 75 bc ba 04 00   RSP: 0018:ffffc900007939e0 EFLAGS: 00010216   RAX: ffffc90000793c78 RBX: ffff8880180cc000 RCX: ffffc90000793c90   RDX: ffffc90000793cc0 RSI: ffff8880178d8cc0 RDI: ffff8880180cc000   RBP: ffff8881178d8cbf R08: ffffc90000793c22 R09: 0000000000000000   R10: ffff8880180cc000 R11: 0000000000000024 R12: 0000000000000000   R13: 0000000000000020 R14: 0000000000000000 R15: ffffc90000793c22   FS: 00007f873753cbc0(0000) GS:ffff88806bc00000(0000)   knlGS:0000000000000000   CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033   CR2: ffff8881178d8cc3 CR3: 00000000181ca000 CR4: 0000000000750ef0   PKRU: 55555554   Call Trace:    \u003cTASK\u003e    ? __die+0x23/0x70    ? page_fault_oops+0x181/0x480    ? search_module_extables+0x19/0x60    ? srso_alias_return_thunk+0x5/0xfbef5    ? exc_page_fault+0x1b6/0x1c0    ? asm_exc_page_fault+0x26/0x30    ? smb2_parse_contexts+0xa0/0x3a0 [cifs]    SMB2_open+0x38d/0x5f0 [cifs]    ? smb2_is_path_accessible+0x138/0x260 [cifs]    smb2_is_path_accessible+0x138/0x260 [cifs]    cifs_is_path_remote+0x8d/0x230 [cifs]    cifs_mount+0x7e/0x350 [cifs]    cifs_smb3_do_mount+0x128/0x780 [cifs]    smb3_get_tree+0xd9/0x290 [cifs]    vfs_get_tree+0x2c/0x100    ? capable+0x37/0x70    path_mount+0x2d7/0xb80    ? srso_alias_return_thunk+0x5/0xfbef5    ? _raw_spin_unlock_irqrestore+0x44/0x60    __x64_sys_mount+0x11a/0x150    do_syscall_64+0x47/0xf0    entry_SYSCALL_64_after_hwframe+0x6f/0x77   RIP: 0033:0x7f8737657b1e",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52434",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52525",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: mwifiex: Fix oob check condition in mwifiex_process_rx_packet  Only skip the code path trying to access the rfc1042 headers when the buffer is too small, so the driver can still process packets without rfc1042 headers.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52525",
            "severity": "Unknown",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-4206",
            "namespace": "debian:11",
            "description": "A use-after-free vulnerability in the Linux kernel's net/sched: cls_route component can be exploited to achieve local privilege escalation.  When route4_change() is called on an existing filter, the whole tcf_result struct is always copied into the new instance of the filter. This causes a problem when updating a filter bound to a class, as tcf_unbind_filter() is always called on the old instance in the success path, decreasing filter_cnt of the still referenced class and allowing it to be deleted, leading to a use-after-free.  We recommend upgrading past commit b80b829e9e2c1b3f7aae34855e04d8f6ecaf13c8.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4206",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2020-36694",
            "namespace": "debian:11",
            "description": "An issue was discovered in netfilter in the Linux kernel before 5.10. There can be a use-after-free in the packet processing context, because the per-CPU sequence count is mishandled during concurrent iptables rules replacement. This could be exploited with the CAP_NET_ADMIN capability in an unprivileged namespace. NOTE: cc00bca was reverted in 5.12.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-36694",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2021-47101",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  asix: fix uninit-value in asix_mdio_read()  asix_read_cmd() may read less than sizeof(smsr) bytes and in this case smsr will be uninitialized.  Fail log: BUG: KMSAN: uninit-value in asix_check_host_enable drivers/net/usb/asix_common.c:82 [inline] BUG: KMSAN: uninit-value in asix_check_host_enable drivers/net/usb/asix_common.c:82 [inline] drivers/net/usb/asix_common.c:497 BUG: KMSAN: uninit-value in asix_mdio_read+0x3c1/0xb00 drivers/net/usb/asix_common.c:497 drivers/net/usb/asix_common.c:497  asix_check_host_enable drivers/net/usb/asix_common.c:82 [inline]  asix_check_host_enable drivers/net/usb/asix_common.c:82 [inline] drivers/net/usb/asix_common.c:497  asix_mdio_read+0x3c1/0xb00 drivers/net/usb/asix_common.c:497 drivers/net/usb/asix_common.c:497",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-47101",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52603",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  UBSAN: array-index-out-of-bounds in dtSplitRoot  Syzkaller reported the following issue:  oop0: detected capacity change from 0 to 32768  UBSAN: array-index-out-of-bounds in fs/jfs/jfs_dtree.c:1971:9 index -2 is out of range for type 'struct dtslot [128]' CPU: 0 PID: 3613 Comm: syz-executor270 Not tainted 6.0.0-syzkaller-09423-g493ffd6605b2 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/22/2022 Call Trace:  \u003cTASK\u003e  __dump_stack lib/dump_stack.c:88 [inline]  dump_stack_lvl+0x1b1/0x28e lib/dump_stack.c:106  ubsan_epilogue lib/ubsan.c:151 [inline]  __ubsan_handle_out_of_bounds+0xdb/0x130 lib/ubsan.c:283  dtSplitRoot+0x8d8/0x1900 fs/jfs/jfs_dtree.c:1971  dtSplitUp fs/jfs/jfs_dtree.c:985 [inline]  dtInsert+0x1189/0x6b80 fs/jfs/jfs_dtree.c:863  jfs_mkdir+0x757/0xb00 fs/jfs/namei.c:270  vfs_mkdir+0x3b3/0x590 fs/namei.c:4013  do_mkdirat+0x279/0x550 fs/namei.c:4038  __do_sys_mkdirat fs/namei.c:4053 [inline]  __se_sys_mkdirat fs/namei.c:4051 [inline]  __x64_sys_mkdirat+0x85/0x90 fs/namei.c:4051  do_syscall_x64 arch/x86/entry/common.c:50 [inline]  do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80  entry_SYSCALL_64_after_hwframe+0x63/0xcd RIP: 0033:0x7fcdc0113fd9 Code: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 \u003c48\u003e 3d 01 f0 ff ff 73 01 c3 48 c7 c1 c0 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007ffeb8bc67d8 EFLAGS: 00000246 ORIG_RAX: 0000000000000102 RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fcdc0113fd9 RDX: 0000000000000000 RSI: 0000000020000340 RDI: 0000000000000003 RBP: 00007fcdc00d37a0 R08: 0000000000000000 R09: 00007fcdc00d37a0 R10: 00005555559a72c0 R11: 0000000000000246 R12: 00000000f8008000 R13: 0000000000000000 R14: 00083878000000f8 R15: 0000000000000000  \u003c/TASK\u003e  The issue is caused when the value of fsi becomes less than -1. The check to break the loop when fsi value becomes -1 is present but syzbot was able to produce value less than -1 which cause the error. This patch simply add the change for the values less than 0.  The patch is tested via syzbot.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52603",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-2124",
            "namespace": "debian:11",
            "description": "An out-of-bounds memory access flaw was found in the Linux kernel’s XFS file system in how a user restores an XFS image after failure (with a dirty log journal). This flaw allows a local user to crash or potentially escalate their privileges on the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-2124",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52577",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  dccp: fix dccp_v4_err()/dccp_v6_err() again  dh-\u003edccph_x is the 9th byte (offset 8) in \"struct dccp_hdr\", not in the \"byte 7\" as Jann claimed.  We need to make sure the ICMP messages are big enough, using more standard ways (no more assumptions).  syzbot reported: BUG: KMSAN: uninit-value in pskb_may_pull_reason include/linux/skbuff.h:2667 [inline] BUG: KMSAN: uninit-value in pskb_may_pull include/linux/skbuff.h:2681 [inline] BUG: KMSAN: uninit-value in dccp_v6_err+0x426/0x1aa0 net/dccp/ipv6.c:94 pskb_may_pull_reason include/linux/skbuff.h:2667 [inline] pskb_may_pull include/linux/skbuff.h:2681 [inline] dccp_v6_err+0x426/0x1aa0 net/dccp/ipv6.c:94 icmpv6_notify+0x4c7/0x880 net/ipv6/icmp.c:867 icmpv6_rcv+0x19d5/0x30d0 ip6_protocol_deliver_rcu+0xda6/0x2a60 net/ipv6/ip6_input.c:438 ip6_input_finish net/ipv6/ip6_input.c:483 [inline] NF_HOOK include/linux/netfilter.h:304 [inline] ip6_input+0x15d/0x430 net/ipv6/ip6_input.c:492 ip6_mc_input+0xa7e/0xc80 net/ipv6/ip6_input.c:586 dst_input include/net/dst.h:468 [inline] ip6_rcv_finish+0x5db/0x870 net/ipv6/ip6_input.c:79 NF_HOOK include/linux/netfilter.h:304 [inline] ipv6_rcv+0xda/0x390 net/ipv6/ip6_input.c:310 __netif_receive_skb_one_core net/core/dev.c:5523 [inline] __netif_receive_skb+0x1a6/0x5a0 net/core/dev.c:5637 netif_receive_skb_internal net/core/dev.c:5723 [inline] netif_receive_skb+0x58/0x660 net/core/dev.c:5782 tun_rx_batched+0x83b/0x920 tun_get_user+0x564c/0x6940 drivers/net/tun.c:2002 tun_chr_write_iter+0x3af/0x5d0 drivers/net/tun.c:2048 call_write_iter include/linux/fs.h:1985 [inline] new_sync_write fs/read_write.c:491 [inline] vfs_write+0x8ef/0x15c0 fs/read_write.c:584 ksys_write+0x20f/0x4c0 fs/read_write.c:637 __do_sys_write fs/read_write.c:649 [inline] __se_sys_write fs/read_write.c:646 [inline] __x64_sys_write+0x93/0xd0 fs/read_write.c:646 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x41/0xc0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd  Uninit was created at: slab_post_alloc_hook+0x12f/0xb70 mm/slab.h:767 slab_alloc_node mm/slub.c:3478 [inline] kmem_cache_alloc_node+0x577/0xa80 mm/slub.c:3523 kmalloc_reserve+0x13d/0x4a0 net/core/skbuff.c:559 __alloc_skb+0x318/0x740 net/core/skbuff.c:650 alloc_skb include/linux/skbuff.h:1286 [inline] alloc_skb_with_frags+0xc8/0xbd0 net/core/skbuff.c:6313 sock_alloc_send_pskb+0xa80/0xbf0 net/core/sock.c:2795 tun_alloc_skb drivers/net/tun.c:1531 [inline] tun_get_user+0x23cf/0x6940 drivers/net/tun.c:1846 tun_chr_write_iter+0x3af/0x5d0 drivers/net/tun.c:2048 call_write_iter include/linux/fs.h:1985 [inline] new_sync_write fs/read_write.c:491 [inline] vfs_write+0x8ef/0x15c0 fs/read_write.c:584 ksys_write+0x20f/0x4c0 fs/read_write.c:637 __do_sys_write fs/read_write.c:649 [inline] __se_sys_write fs/read_write.c:646 [inline] __x64_sys_write+0x93/0xd0 fs/read_write.c:646 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x41/0xc0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd  CPU: 0 PID: 4995 Comm: syz-executor153 Not tainted 6.6.0-rc1-syzkaller-00014-ga747acc0b752 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/04/2023",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52577",
            "severity": "Unknown",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52510",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  ieee802154: ca8210: Fix a potential UAF in ca8210_probe  If of_clk_add_provider() fails in ca8210_register_ext_clock(), it calls clk_unregister() to release priv-\u003eclk and returns an error. However, the caller ca8210_probe() then calls ca8210_remove(), where priv-\u003eclk is freed again in ca8210_unregister_ext_clock(). In this case, a use-after-free may happen in the second time we call clk_unregister().  Fix this by removing the first clk_unregister(). Also, priv-\u003eclk could be an error code on failure of clk_register_fixed_rate(). Use IS_ERR_OR_NULL to catch this case in ca8210_unregister_ext_clock().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52510",
            "severity": "Unknown",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52530",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: mac80211: fix potential key use-after-free  When ieee80211_key_link() is called by ieee80211_gtk_rekey_add() but returns 0 due to KRACK protection (identical key reinstall), ieee80211_gtk_rekey_add() will still return a pointer into the key, in a potential use-after-free. This normally doesn't happen since it's only called by iwlwifi in case of WoWLAN rekey offload which has its own KRACK protection, but still better to fix, do that by returning an error code and converting that to success on the cfg80211 boundary only, leaving the error for bad callers of ieee80211_gtk_rekey_add().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52530",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-39197",
            "namespace": "debian:11",
            "description": "An out-of-bounds read vulnerability was found in Netfilter Connection Tracking (conntrack) in the Linux kernel. This flaw allows a remote user to disclose sensitive information via the DCCP protocol.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-39197",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-0480",
            "namespace": "debian:11",
            "description": "A flaw was found in the filelock_init in fs/locks.c function in the Linux kernel. This issue can lead to host memory exhaustion due to memcg not limiting the number of Portable Operating System Interface (POSIX) file locks.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-0480",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52601",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  jfs: fix array-index-out-of-bounds in dbAdjTree  Currently there is a bound check missing in the dbAdjTree while accessing the dmt_stree. To add the required check added the bool is_ctl which is required to determine the size as suggest in the following commit. https://lore.kernel.org/linux-kernel-mentees/f9475918-2186-49b8-b801-6f0f9e75f4fa@oracle.com/",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52601",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-31083",
            "namespace": "debian:11",
            "description": "An issue was discovered in drivers/bluetooth/hci_ldisc.c in the Linux kernel 6.2. In hci_uart_tty_ioctl, there is a race condition between HCIUARTSETPROTO and HCIUARTGETPROTO. HCI_UART_PROTO_SET is set before hu-\u003eproto is set. A NULL pointer dereference may occur.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-31083",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52602",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  jfs: fix slab-out-of-bounds Read in dtSearch  Currently while searching for current page in the sorted entry table of the page there is a out of bound access. Added a bound check to fix the error.  Dave: Set return code to -EIO",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52602",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52435",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  net: prevent mss overflow in skb_segment()  Once again syzbot is able to crash the kernel in skb_segment() [1]  GSO_BY_FRAGS is a forbidden value, but unfortunately the following computation in skb_segment() can reach it quite easily :  \tmss = mss * partial_segs;  65535 = 3 * 5 * 17 * 257, so many initial values of mss can lead to a bad final result.  Make sure to limit segmentation so that the new mss value is smaller than GSO_BY_FRAGS.  [1]  general protection fault, probably for non-canonical address 0xdffffc000000000e: 0000 [#1] PREEMPT SMP KASAN KASAN: null-ptr-deref in range [0x0000000000000070-0x0000000000000077] CPU: 1 PID: 5079 Comm: syz-executor993 Not tainted 6.7.0-rc4-syzkaller-00141-g1ae4cd3cbdd0 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 11/10/2023 RIP: 0010:skb_segment+0x181d/0x3f30 net/core/skbuff.c:4551 Code: 83 e3 02 e9 fb ed ff ff e8 90 68 1c f9 48 8b 84 24 f8 00 00 00 48 8d 78 70 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03 \u003c0f\u003e b6 04 02 84 c0 74 08 3c 03 0f 8e 8a 21 00 00 48 8b 84 24 f8 00 RSP: 0018:ffffc900043473d0 EFLAGS: 00010202 RAX: dffffc0000000000 RBX: 0000000000010046 RCX: ffffffff886b1597 RDX: 000000000000000e RSI: ffffffff886b2520 RDI: 0000000000000070 RBP: ffffc90004347578 R08: 0000000000000005 R09: 000000000000ffff R10: 000000000000ffff R11: 0000000000000002 R12: ffff888063202ac0 R13: 0000000000010000 R14: 000000000000ffff R15: 0000000000000046 FS: 0000555556e7e380(0000) GS:ffff8880b9900000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000020010000 CR3: 0000000027ee2000 CR4: 00000000003506f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: \u003cTASK\u003e udp6_ufo_fragment+0xa0e/0xd00 net/ipv6/udp_offload.c:109 ipv6_gso_segment+0x534/0x17e0 net/ipv6/ip6_offload.c:120 skb_mac_gso_segment+0x290/0x610 net/core/gso.c:53 __skb_gso_segment+0x339/0x710 net/core/gso.c:124 skb_gso_segment include/net/gso.h:83 [inline] validate_xmit_skb+0x36c/0xeb0 net/core/dev.c:3626 __dev_queue_xmit+0x6f3/0x3d60 net/core/dev.c:4338 dev_queue_xmit include/linux/netdevice.h:3134 [inline] packet_xmit+0x257/0x380 net/packet/af_packet.c:276 packet_snd net/packet/af_packet.c:3087 [inline] packet_sendmsg+0x24c6/0x5220 net/packet/af_packet.c:3119 sock_sendmsg_nosec net/socket.c:730 [inline] __sock_sendmsg+0xd5/0x180 net/socket.c:745 __sys_sendto+0x255/0x340 net/socket.c:2190 __do_sys_sendto net/socket.c:2202 [inline] __se_sys_sendto net/socket.c:2198 [inline] __x64_sys_sendto+0xe0/0x1b0 net/socket.c:2198 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0x40/0x110 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x63/0x6b RIP: 0033:0x7f8692032aa9 Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 d1 19 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 \u003c48\u003e 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007fff8d685418 EFLAGS: 00000246 ORIG_RAX: 000000000000002c RAX: ffffffffffffffda RBX: 0000000000000003 RCX: 00007f8692032aa9 RDX: 0000000000010048 RSI: 00000000200000c0 RDI: 0000000000000003 RBP: 00000000000f4240 R08: 0000000020000540 R09: 0000000000000014 R10: 0000000000000000 R11: 0000000000000246 R12: 00007fff8d685480 R13: 0000000000000001 R14: 00007fff8d685480 R15: 0000000000000003 \u003c/TASK\u003e Modules linked in: ---[ end trace 0000000000000000 ]--- RIP: 0010:skb_segment+0x181d/0x3f30 net/core/skbuff.c:4551 Code: 83 e3 02 e9 fb ed ff ff e8 90 68 1c f9 48 8b 84 24 f8 00 00 00 48 8d 78 70 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03 \u003c0f\u003e b6 04 02 84 c0 74 08 3c 03 0f 8e 8a 21 00 00 48 8b 84 24 f8 00 RSP: 0018:ffffc900043473d0 EFLAGS: 00010202 RAX: dffffc0000000000 RBX: 0000000000010046 RCX: ffffffff886b1597 RDX: 000000000000000e RSI: ffffffff886b2520 RDI: 0000000000000070 RBP: ffffc90004347578 R0 ---truncated---",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52435",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-2269",
            "namespace": "debian:11",
            "description": "A denial of service problem was found, due to a possible recursive locking scenario, resulting in a deadlock in table_clear in drivers/md/dm-ioctl.c in the Linux Kernel Device Mapper-Multipathing sub-component.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-2269",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52509",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  ravb: Fix use-after-free issue in ravb_tx_timeout_work()  The ravb_stop() should call cancel_work_sync(). Otherwise, ravb_tx_timeout_work() is possible to use the freed priv after ravb_remove() was called like below:  CPU0\t\t\tCPU1 \t\t\travb_tx_timeout() ravb_remove() unregister_netdev() free_netdev(ndev) // free priv \t\t\travb_tx_timeout_work() \t\t\t// use priv  unregister_netdev() will call .ndo_stop() so that ravb_stop() is called. And, after phy_stop() is called, netif_carrier_off() is also called. So that .ndo_tx_timeout() will not be called after phy_stop().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52509",
            "severity": "Unknown",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-3545",
            "namespace": "debian:11",
            "description": "A vulnerability has been found in Linux Kernel and classified as critical. Affected by this vulnerability is the function area_cache_get of the file drivers/net/ethernet/netronome/nfp/nfpcore/nfp_cppcore.c of the component IPsec. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier VDB-211045 was assigned to this vulnerability.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-3545",
            "severity": "Unknown",
            "fixedby": "5.10.162-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-24864",
            "namespace": "debian:11",
            "description": "A race condition was found in the Linux kernel's media/dvb-core in dvbdmx_write() function. This can result in a null pointer dereference issue, possibly leading to a kernel panic or denial of service issue.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-24864",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-1990",
            "namespace": "debian:11",
            "description": "A use-after-free flaw was found in ndlc_remove in drivers/nfc/st-nci/ndlc.c in the Linux Kernel. This flaw could allow an attacker to crash the system due to a race problem.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1990",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52445",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  media: pvrusb2: fix use after free on context disconnection  Upon module load, a kthread is created targeting the pvr2_context_thread_func function, which may call pvr2_context_destroy and thus call kfree() on the context object. However, that might happen before the usb hub_event handler is able to notify the driver. This patch adds a sanity check before the invalid read reported by syzbot, within the context disconnection call stack.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52445",
            "severity": "Unknown",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-3220",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 6.1-rc8. dpu_crtc_atomic_check in drivers/gpu/drm/msm/disp/dpu1/dpu_crtc.c lacks check of the return value of kzalloc() and will cause the NULL Pointer Dereference.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3220",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52585",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: Fix possible NULL dereference in amdgpu_ras_query_error_status_helper()  Return invalid error code -EINVAL for invalid block id.  Fixes the below:  drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c:1183 amdgpu_ras_query_error_status_helper() error: we previously assumed 'info' could be null (see line 1176)",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52585",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52617",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  PCI: switchtec: Fix stdev_release() crash after surprise hot remove  A PCI device hot removal may occur while stdev-\u003ecdev is held open. The call to stdev_release() then happens during close or exit, at a point way past switchtec_pci_remove(). Otherwise the last ref would vanish with the trailing put_device(), just before return.  At that later point in time, the devm cleanup has already removed the stdev-\u003emmio_mrpc mapping. Also, the stdev-\u003epdev reference was not a counted one. Therefore, in DMA mode, the iowrite32() in stdev_release() will cause a fatal page fault, and the subsequent dma_free_coherent(), if reached, would pass a stale \u0026stdev-\u003epdev-\u003edev pointer.  Fix by moving MRPC DMA shutdown into switchtec_pci_remove(), after stdev_kill(). Counting the stdev-\u003epdev ref is now optional, but may prevent future accidents.  Reproducible via the script at https://lore.kernel.org/r/20231113212150.96410-1-dns@arista.com",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52617",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-24859",
            "namespace": "debian:11",
            "description": "A race condition was found in the Linux kernel's net/bluetooth in sniff_{min,max}_interval_set() function. This can result in a bluetooth sniffing exception issue, possibly leading denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-24859",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52449",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  mtd: Fix gluebi NULL pointer dereference caused by ftl notifier  If both ftl.ko and gluebi.ko are loaded, the notifier of ftl triggers NULL pointer dereference when trying to access ‘gluebi-\u003edesc’ in gluebi_read().  ubi_gluebi_init   ubi_register_volume_notifier     ubi_enumerate_volumes       ubi_notify_all         gluebi_notify    nb-\u003enotifier_call()           gluebi_create             mtd_device_register               mtd_device_parse_register                 add_mtd_device                   blktrans_notify_add   not-\u003eadd()                     ftl_add_mtd         tr-\u003eadd_mtd()                       scan_header                         mtd_read                           mtd_read_oob                             mtd_read_oob_std                               gluebi_read   mtd-\u003eread()                                 gluebi-\u003edesc - NULL  Detailed reproduction information available at the Link [1],  In the normal case, obtain gluebi-\u003edesc in the gluebi_get_device(), and access gluebi-\u003edesc in the gluebi_read(). However, gluebi_get_device() is not executed in advance in the ftl_add_mtd() process, which leads to NULL pointer dereference.  The solution for the gluebi module is to run jffs2 on the UBI volume without considering working with ftl or mtdblock [2]. Therefore, this problem can be avoided by preventing gluebi from creating the mtdblock device after creating mtd partition of the type MTD_UBIVOLUME.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52449",
            "severity": "Unknown",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52522",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  net: fix possible store tearing in neigh_periodic_work()  While looking at a related syzbot report involving neigh_periodic_work(), I found that I forgot to add an annotation when deleting an RCU protected item from a list.  Readers use rcu_deference(*np), we need to use either rcu_assign_pointer() or WRITE_ONCE() on writer side to prevent store tearing.  I use rcu_assign_pointer() to have lockdep support, this was the choice made in neigh_flush_dev().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52522",
            "severity": "Unknown",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52607",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  powerpc/mm: Fix null-pointer dereference in pgtable_cache_add  kasprintf() returns a pointer to dynamically allocated memory which can be NULL upon failure. Ensure the allocation was successful by checking the pointer validity.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52607",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52439",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  uio: Fix use-after-free in uio_open  core-1\t\t\t\tcore-2 ------------------------------------------------------- uio_unregister_device\t\tuio_open \t\t\t\tidev = idr_find() device_unregister(\u0026idev-\u003edev) put_device(\u0026idev-\u003edev) uio_device_release \t\t\t\tget_device(\u0026idev-\u003edev) kfree(idev) uio_free_minor(minor) \t\t\t\tuio_release \t\t\t\tput_device(\u0026idev-\u003edev) \t\t\t\tkfree(idev) -------------------------------------------------------  In the core-1 uio_unregister_device(), the device_unregister will kfree idev when the idev-\u003edev kobject ref is 1. But after core-1 device_unregister, put_device and before doing kfree, the core-2 may get_device. Then: 1. After core-1 kfree idev, the core-2 will do use-after-free for idev. 2. When core-2 do uio_release and put_device, the idev will be double    freed.  To address this issue, we can get idev atomic \u0026 inc idev reference with minor_lock.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52439",
            "severity": "Unknown",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52531",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: iwlwifi: mvm: Fix a memory corruption issue  A few lines above, space is kzalloc()'ed for: \tsizeof(struct iwl_nvm_data) + \tsizeof(struct ieee80211_channel) + \tsizeof(struct ieee80211_rate)  'mvm-\u003envm_data' is a 'struct iwl_nvm_data', so it is fine.  At the end of this structure, there is the 'channels' flex array. Each element is of type 'struct ieee80211_channel'. So only 1 element is allocated in this array.  When doing:   mvm-\u003envm_data-\u003ebands[0].channels = mvm-\u003envm_data-\u003echannels; We point at the first element of the 'channels' flex array. So this is fine.  However, when doing:   mvm-\u003envm_data-\u003ebands[0].bitrates = \t\t\t(void *)((u8 *)mvm-\u003envm_data-\u003echannels + 1); because of the \"(u8 *)\" cast, we add only 1 to the address of the beginning of the flex array.  It is likely that we want point at the 'struct ieee80211_rate' allocated just after.  Remove the spurious casting so that the pointer arithmetic works as expected.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52531",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-1670",
            "namespace": "debian:11",
            "description": "A flaw use after free in the Linux kernel Xircom 16-bit PCMCIA (PC-card) Ethernet driver was found.A local user could use this flaw to crash the system or potentially escalate their privileges on the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1670",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-6536",
            "namespace": "debian:11",
            "description": "A flaw was found in the Linux kernel's NVMe driver. This issue may allow an unauthenticated malicious actor to send a set of crafted TCP packages when using NVMe over TCP, leading the NVMe driver to a NULL pointer dereference in the NVMe driver, causing kernel panic and a denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-6536",
            "severity": "Unknown",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-20593",
            "namespace": "debian:11",
            "description": "An issue in “Zen 2” CPUs, under specific microarchitectural circumstances, may allow an attacker to potentially access sensitive information.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-20593",
            "severity": "Unknown",
            "fixedby": "5.10.179-3"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-36280",
            "namespace": "debian:11",
            "description": "An out-of-bounds(OOB) memory access vulnerability was found in vmwgfx driver in drivers/gpu/vmxgfx/vmxgfx_kms.c in GPU component in the Linux kernel with device file '/dev/dri/renderD128 (or Dxxx)'. This flaw allows a local attacker with a user account on the system to gain privilege, causing a denial of service(DoS).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-36280",
            "severity": "Unknown",
            "fixedby": "5.10.162-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52476",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  perf/x86/lbr: Filter vsyscall addresses  We found that a panic can occur when a vsyscall is made while LBR sampling is active. If the vsyscall is interrupted (NMI) for perf sampling, this call sequence can occur (most recent at top):      __insn_get_emulate_prefix()     insn_get_emulate_prefix()     insn_get_prefixes()     insn_get_opcode()     decode_branch_type()     get_branch_type()     intel_pmu_lbr_filter()     intel_pmu_handle_irq()     perf_event_nmi_handler()  Within __insn_get_emulate_prefix() at frame 0, a macro is called:      peek_nbyte_next(insn_byte_t, insn, i)  Within this macro, this dereference occurs:      (insn)-\u003enext_byte  Inspecting registers at this point, the value of the next_byte field is the address of the vsyscall made, for example the location of the vsyscall version of gettimeofday() at 0xffffffffff600000. The access to an address in the vsyscall region will trigger an oops due to an unhandled page fault.  To fix the bug, filtering for vsyscalls can be done when determining the branch type. This patch will return a \"none\" branch if a kernel address if found to lie in the vsyscall region.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52476",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-42753",
            "namespace": "debian:11",
            "description": "An array indexing vulnerability was found in the netfilter subsystem of the Linux kernel. A missing macro could lead to a miscalculation of the `h-\u003enets` array offset, providing attackers with the primitive to arbitrarily increment/decrement a memory buffer out-of-bound. This issue may allow a local user to crash the system or potentially escalate their privileges on the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-42753",
            "severity": "Unknown",
            "fixedby": "5.10.197-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26640",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  tcp: add sanity checks to rx zerocopy  TCP rx zerocopy intent is to map pages initially allocated from NIC drivers, not pages owned by a fs.  This patch adds to can_map_frag() these additional checks:  - Page must not be a compound one. - page-\u003emapping must be NULL.  This fixes the panic reported by ZhangPeng.  syzbot was able to loopback packets built with sendfile(), mapping pages owned by an ext4 file to TCP rx zerocopy.  r3 = socket$inet_tcp(0x2, 0x1, 0x0) mmap(\u0026(0x7f0000ff9000/0x4000)=nil, 0x4000, 0x0, 0x12, r3, 0x0) r4 = socket$inet_tcp(0x2, 0x1, 0x0) bind$inet(r4, \u0026(0x7f0000000000)={0x2, 0x4e24, @multicast1}, 0x10) connect$inet(r4, \u0026(0x7f00000006c0)={0x2, 0x4e24, @empty}, 0x10) r5 = openat$dir(0xffffffffffffff9c, \u0026(0x7f00000000c0)='./file0\\x00',     0x181e42, 0x0) fallocate(r5, 0x0, 0x0, 0x85b8) sendfile(r4, r5, 0x0, 0x8ba0) getsockopt$inet_tcp_TCP_ZEROCOPY_RECEIVE(r4, 0x6, 0x23,     \u0026(0x7f00000001c0)={\u0026(0x7f0000ffb000/0x3000)=nil, 0x3000, 0x0, 0x0, 0x0,     0x0, 0x0, 0x0, 0x0}, \u0026(0x7f0000000440)=0x40) r6 = openat$dir(0xffffffffffffff9c, \u0026(0x7f00000000c0)='./file0\\x00',     0x181e42, 0x0)",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26640",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52596",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  sysctl: Fix out of bounds access for empty sysctl registers  When registering tables to the sysctl subsystem there is a check to see if header is a permanently empty directory (used for mounts). This check evaluates the first element of the ctl_table. This results in an out of bounds evaluation when registering empty directories.  The function register_sysctl_mount_point now passes a ctl_table of size 1 instead of size 0. It now relies solely on the type to identify a permanently empty register.  Make sure that the ctl_table has at least one element before testing for permanent emptiness.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52596",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-20569",
            "namespace": "debian:11",
            "description": "A side channel vulnerability on some of the AMD CPUs may allow an attacker to influence the return address prediction. This may result in speculative execution at an attacker-controlled address, potentially leading to information disclosure.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-20569",
            "severity": "Unknown",
            "fixedby": "5.10.179-5"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26636",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  llc: make llc_ui_sendmsg() more robust against bonding changes  syzbot was able to trick llc_ui_sendmsg(), allocating an skb with no headroom, but subsequently trying to push 14 bytes of Ethernet header [1]  Like some others, llc_ui_sendmsg() releases the socket lock before calling sock_alloc_send_skb(). Then it acquires it again, but does not redo all the sanity checks that were performed.  This fix:  - Uses LL_RESERVED_SPACE() to reserve space. - Check all conditions again after socket lock is held again. - Do not account Ethernet header for mtu limitation.  [1]  skbuff: skb_under_panic: text:ffff800088baa334 len:1514 put:14 head:ffff0000c9c37000 data:ffff0000c9c36ff2 tail:0x5dc end:0x6c0 dev:bond0   kernel BUG at net/core/skbuff.c:193 ! Internal error: Oops - BUG: 00000000f2000800 [#1] PREEMPT SMP Modules linked in: CPU: 0 PID: 6875 Comm: syz-executor.0 Not tainted 6.7.0-rc8-syzkaller-00101-g0802e17d9aca-dirty #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 11/17/2023 pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)  pc : skb_panic net/core/skbuff.c:189 [inline]  pc : skb_under_panic+0x13c/0x140 net/core/skbuff.c:203  lr : skb_panic net/core/skbuff.c:189 [inline]  lr : skb_under_panic+0x13c/0x140 net/core/skbuff.c:203 sp : ffff800096f97000 x29: ffff800096f97010 x28: ffff80008cc8d668 x27: dfff800000000000 x26: ffff0000cb970c90 x25: 00000000000005dc x24: ffff0000c9c36ff2 x23: ffff0000c9c37000 x22: 00000000000005ea x21: 00000000000006c0 x20: 000000000000000e x19: ffff800088baa334 x18: 1fffe000368261ce x17: ffff80008e4ed000 x16: ffff80008a8310f8 x15: 0000000000000001 x14: 1ffff00012df2d58 x13: 0000000000000000 x12: 0000000000000000 x11: 0000000000000001 x10: 0000000000ff0100 x9 : e28a51f1087e8400 x8 : e28a51f1087e8400 x7 : ffff80008028f8d0 x6 : 0000000000000000 x5 : 0000000000000001 x4 : 0000000000000001 x3 : ffff800082b78714 x2 : 0000000000000001 x1 : 0000000100000000 x0 : 0000000000000089 Call trace:   skb_panic net/core/skbuff.c:189 [inline]   skb_under_panic+0x13c/0x140 net/core/skbuff.c:203   skb_push+0xf0/0x108 net/core/skbuff.c:2451   eth_header+0x44/0x1f8 net/ethernet/eth.c:83   dev_hard_header include/linux/netdevice.h:3188 [inline]   llc_mac_hdr_init+0x110/0x17c net/llc/llc_output.c:33   llc_sap_action_send_xid_c+0x170/0x344 net/llc/llc_s_ac.c:85   llc_exec_sap_trans_actions net/llc/llc_sap.c:153 [inline]   llc_sap_next_state net/llc/llc_sap.c:182 [inline]   llc_sap_state_process+0x1ec/0x774 net/llc/llc_sap.c:209   llc_build_and_send_xid_pkt+0x12c/0x1c0 net/llc/llc_sap.c:270   llc_ui_sendmsg+0x7bc/0xb1c net/llc/af_llc.c:997   sock_sendmsg_nosec net/socket.c:730 [inline]   __sock_sendmsg net/socket.c:745 [inline]   sock_sendmsg+0x194/0x274 net/socket.c:767   splice_to_socket+0x7cc/0xd58 fs/splice.c:881   do_splice_from fs/splice.c:933 [inline]   direct_splice_actor+0xe4/0x1c0 fs/splice.c:1142   splice_direct_to_actor+0x2a0/0x7e4 fs/splice.c:1088   do_splice_direct+0x20c/0x348 fs/splice.c:1194   do_sendfile+0x4bc/0xc70 fs/read_write.c:1254   __do_sys_sendfile64 fs/read_write.c:1322 [inline]   __se_sys_sendfile64 fs/read_write.c:1308 [inline]   __arm64_sys_sendfile64+0x160/0x3b4 fs/read_write.c:1308   __invoke_syscall arch/arm64/kernel/syscall.c:37 [inline]   invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:51   el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:136   do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:155   el0_svc+0x54/0x158 arch/arm64/kernel/entry-common.c:678   el0t_64_sync_handler+0x84/0xfc arch/arm64/kernel/entry-common.c:696   el0t_64_sync+0x190/0x194 arch/arm64/kernel/entry.S:595 Code: aa1803e6 aa1903e7 a90023f5 94792f6a (d4210000)",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26636",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-48626",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  moxart: fix potential use-after-free on remove path  It was reported that the mmc host structure could be accessed after it was freed in moxart_remove(), so fix this by saving the base register of the device and using it instead of the pointer dereference.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-48626",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-0775",
            "namespace": "debian:11",
            "description": "A use-after-free flaw was found in the __ext4_remount in fs/ext4/super.c in ext4 in the Linux kernel. This flaw allows a local user to cause an information leak problem while freeing the old quota file names before a potential failure, leading to a use-after-free.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-0775",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-51043",
            "namespace": "debian:11",
            "description": "In the Linux kernel before 6.4.5, drivers/gpu/drm/drm_atomic.c has a use-after-free during a race condition between a nonblocking atomic commit and a driver unload.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-51043",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-32233",
            "namespace": "debian:11",
            "description": "In the Linux kernel through 6.3.1, a use-after-free in Netfilter nf_tables when processing batch requests can be abused to perform arbitrary read and write operations on kernel memory. Unprivileged local users can obtain root privileges. This occurs because anonymous sets are mishandled.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-32233",
            "severity": "Unknown",
            "fixedby": "5.10.179-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2021-47076",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  RDMA/rxe: Return CQE error if invalid lkey was supplied  RXE is missing update of WQE status in LOCAL_WRITE failures.  This caused the following kernel panic if someone sent an atomic operation with an explicitly wrong lkey.  [leonro@vm ~]$ mkt test test_atomic_invalid_lkey (tests.test_atomic.AtomicTest) ...  WARNING: CPU: 5 PID: 263 at drivers/infiniband/sw/rxe/rxe_comp.c:740 rxe_completer+0x1a6d/0x2e30 [rdma_rxe]  Modules linked in: crc32_generic rdma_rxe ip6_udp_tunnel udp_tunnel rdma_ucm rdma_cm ib_umad ib_ipoib iw_cm ib_cm mlx5_ib ib_uverbs ib_core mlx5_core ptp pps_core  CPU: 5 PID: 263 Comm: python3 Not tainted 5.13.0-rc1+ #2936  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014  RIP: 0010:rxe_completer+0x1a6d/0x2e30 [rdma_rxe]  Code: 03 0f 8e 65 0e 00 00 3b 93 10 06 00 00 0f 84 82 0a 00 00 4c 89 ff 4c 89 44 24 38 e8 2d 74 a9 e1 4c 8b 44 24 38 e9 1c f5 ff ff \u003c0f\u003e 0b e9 0c e8 ff ff b8 05 00 00 00 41 bf 05 00 00 00 e9 ab e7 ff  RSP: 0018:ffff8880158af090 EFLAGS: 00010246  RAX: 0000000000000000 RBX: ffff888016a78000 RCX: ffffffffa0cf1652  RDX: 1ffff9200004b442 RSI: 0000000000000004 RDI: ffffc9000025a210  RBP: dffffc0000000000 R08: 00000000ffffffea R09: ffff88801617740b  R10: ffffed1002c2ee81 R11: 0000000000000007 R12: ffff88800f3b63e8  R13: ffff888016a78008 R14: ffffc9000025a180 R15: 000000000000000c  FS:  00007f88b622a740(0000) GS:ffff88806d540000(0000) knlGS:0000000000000000  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033  CR2: 00007f88b5a1fa10 CR3: 000000000d848004 CR4: 0000000000370ea0  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400  Call Trace:   rxe_do_task+0x130/0x230 [rdma_rxe]   rxe_rcv+0xb11/0x1df0 [rdma_rxe]   rxe_loopback+0x157/0x1e0 [rdma_rxe]   rxe_responder+0x5532/0x7620 [rdma_rxe]   rxe_do_task+0x130/0x230 [rdma_rxe]   rxe_rcv+0x9c8/0x1df0 [rdma_rxe]   rxe_loopback+0x157/0x1e0 [rdma_rxe]   rxe_requester+0x1efd/0x58c0 [rdma_rxe]   rxe_do_task+0x130/0x230 [rdma_rxe]   rxe_post_send+0x998/0x1860 [rdma_rxe]   ib_uverbs_post_send+0xd5f/0x1220 [ib_uverbs]   ib_uverbs_write+0x847/0xc80 [ib_uverbs]   vfs_write+0x1c5/0x840   ksys_write+0x176/0x1d0   do_syscall_64+0x3f/0x80   entry_SYSCALL_64_after_hwframe+0x44/0xae",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-47076",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-28328",
            "namespace": "debian:11",
            "description": "A NULL pointer dereference flaw was found in the az6027 driver in drivers/media/usb/dev-usb/az6027.c in the Linux Kernel. The message from user space is not checked properly before transferring into the device. This flaw allows a local user to crash the system or potentially cause a denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-28328",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52600",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  jfs: fix uaf in jfs_evict_inode  When the execution of diMount(ipimap) fails, the object ipimap that has been released may be accessed in diFreeSpecial(). Asynchronous ipimap release occurs when rcu_core() calls jfs_free_node().  Therefore, when diMount(ipimap) fails, sbi-\u003eipimap should not be initialized as ipimap.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52600",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-32269",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel before 6.1.11. In net/netrom/af_netrom.c, there is a use-after-free because accept is also allowed for a successfully connected AF_NETROM socket. However, in order for an attacker to exploit this, the system must have netrom routing configured or the attacker must have the CAP_NET_ADMIN capability.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-32269",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52614",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  PM / devfreq: Fix buffer overflow in trans_stat_show  Fix buffer overflow in trans_stat_show().  Convert simple snprintf to the more secure scnprintf with size of PAGE_SIZE.  Add condition checking if we are exceeding PAGE_SIZE and exit early from loop. Also add at the end a warning that we exceeded PAGE_SIZE and that stats is disabled.  Return -EFBIG in the case where we don't have enough space to write the full transition table.  Also document in the ABI that this function can return -EFBIG error.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52614",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-0160",
            "namespace": "debian:11",
            "description": "A deadlock flaw was found in the Linux kernel’s BPF subsystem. This flaw allows a local user to potentially crash the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-0160",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52572",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  cifs: Fix UAF in cifs_demultiplex_thread()  There is a UAF when xfstests on cifs:    BUG: KASAN: use-after-free in smb2_is_network_name_deleted+0x27/0x160   Read of size 4 at addr ffff88810103fc08 by task cifsd/923    CPU: 1 PID: 923 Comm: cifsd Not tainted 6.1.0-rc4+ #45   ...   Call Trace:    \u003cTASK\u003e    dump_stack_lvl+0x34/0x44    print_report+0x171/0x472    kasan_report+0xad/0x130    kasan_check_range+0x145/0x1a0    smb2_is_network_name_deleted+0x27/0x160    cifs_demultiplex_thread.cold+0x172/0x5a4    kthread+0x165/0x1a0    ret_from_fork+0x1f/0x30    \u003c/TASK\u003e    Allocated by task 923:    kasan_save_stack+0x1e/0x40    kasan_set_track+0x21/0x30    __kasan_slab_alloc+0x54/0x60    kmem_cache_alloc+0x147/0x320    mempool_alloc+0xe1/0x260    cifs_small_buf_get+0x24/0x60    allocate_buffers+0xa1/0x1c0    cifs_demultiplex_thread+0x199/0x10d0    kthread+0x165/0x1a0    ret_from_fork+0x1f/0x30    Freed by task 921:    kasan_save_stack+0x1e/0x40    kasan_set_track+0x21/0x30    kasan_save_free_info+0x2a/0x40    ____kasan_slab_free+0x143/0x1b0    kmem_cache_free+0xe3/0x4d0    cifs_small_buf_release+0x29/0x90    SMB2_negotiate+0x8b7/0x1c60    smb2_negotiate+0x51/0x70    cifs_negotiate_protocol+0xf0/0x160    cifs_get_smb_ses+0x5fa/0x13c0    mount_get_conns+0x7a/0x750    cifs_mount+0x103/0xd00    cifs_smb3_do_mount+0x1dd/0xcb0    smb3_get_tree+0x1d5/0x300    vfs_get_tree+0x41/0xf0    path_mount+0x9b3/0xdd0    __x64_sys_mount+0x190/0x1d0    do_syscall_64+0x35/0x80    entry_SYSCALL_64_after_hwframe+0x46/0xb0  The UAF is because:   mount(pid: 921)               | cifsd(pid: 923) -------------------------------|-------------------------------                                | cifs_demultiplex_thread SMB2_negotiate                 |  cifs_send_recv                |   compound_send_recv           |    smb_send_rqst               |     wait_for_response          |      wait_event_state      [1] |                                |  standard_receive3                                |   cifs_handle_standard                                |    handle_mid                                |     mid-\u003eresp_buf = buf;  [2]                                |     dequeue_mid           [3]      KILL the process      [4] |     resp_iov[i].iov_base = buf |  free_rsp_buf              [5] |                                |   is_network_name_deleted [6]                                |   callback  1. After send request to server, wait the response until     mid-\u003emid_state != SUBMITTED; 2. Receive response from server, and set it to mid; 3. Set the mid state to RECEIVED; 4. Kill the process, the mid state already RECEIVED, get 0; 5. Handle and release the negotiate response; 6. UAF.  It can be easily reproduce with add some delay in [3] - [6].  Only sync call has the problem since async call's callback is executed in cifsd process.  Add an extra state to mark the mid state to READY before wakeup the waitter, then it can get the resp safely.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52572",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52590",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  ocfs2: Avoid touching renamed directory if parent does not change  The VFS will not be locking moved directory if its parent does not change. Change ocfs2 rename code to avoid touching renamed directory if its parent does not change as without locking that can corrupt the filesystem.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52590",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52584",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  spmi: mediatek: Fix UAF on device remove  The pmif driver data that contains the clocks is allocated along with spmi_controller. On device remove, spmi_controller will be freed first, and then devres , including the clocks, will be cleanup. This leads to UAF because putting the clocks will access the clocks in the pmif driver data, which is already freed along with spmi_controller.  This can be reproduced by enabling DEBUG_TEST_DRIVER_REMOVE and building the kernel with KASAN.  Fix the UAF issue by using unmanaged clk_bulk_get() and putting the clocks before freeing spmi_controller.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52584",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-5717",
            "namespace": "debian:11",
            "description": "A heap out-of-bounds write vulnerability in the Linux kernel's Linux Kernel Performance Events (perf) component can be exploited to achieve local privilege escalation.  If perf_read_group() is called while an event's sibling_list is smaller than its child's sibling_list, it can increment or write to memory locations outside of the allocated buffer.  We recommend upgrading past commit 32671e3799ca2e4590773fd0e63aaa4229e50c06.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-5717",
            "severity": "Unknown",
            "fixedby": "5.10.205-2"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-3390",
            "namespace": "debian:11",
            "description": "A use-after-free vulnerability was found in the Linux kernel's netfilter subsystem in net/netfilter/nf_tables_api.c.  Mishandled error handling with NFT_MSG_NEWRULE makes it possible to use a dangling pointer in the same transaction causing a use-after-free vulnerability. This flaw allows a local attacker with user access to cause a privilege escalation issue.  We recommend upgrading past commit 1240eb93f0616b21c675416516ff3d74798fdc97.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3390",
            "severity": "Unknown",
            "fixedby": "5.10.179-3"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26597",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  net: qualcomm: rmnet: fix global oob in rmnet_policy  The variable rmnet_link_ops assign a *bigger* maxtype which leads to a global out-of-bounds read when parsing the netlink attributes. See bug trace below:  ================================================================== BUG: KASAN: global-out-of-bounds in validate_nla lib/nlattr.c:386 [inline] BUG: KASAN: global-out-of-bounds in __nla_validate_parse+0x24af/0x2750 lib/nlattr.c:600 Read of size 1 at addr ffffffff92c438d0 by task syz-executor.6/84207  CPU: 0 PID: 84207 Comm: syz-executor.6 Tainted: G                 N 6.1.0 #3 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014 Call Trace:  \u003cTASK\u003e  __dump_stack lib/dump_stack.c:88 [inline]  dump_stack_lvl+0x8b/0xb3 lib/dump_stack.c:106  print_address_description mm/kasan/report.c:284 [inline]  print_report+0x172/0x475 mm/kasan/report.c:395  kasan_report+0xbb/0x1c0 mm/kasan/report.c:495  validate_nla lib/nlattr.c:386 [inline]  __nla_validate_parse+0x24af/0x2750 lib/nlattr.c:600  __nla_parse+0x3e/0x50 lib/nlattr.c:697  nla_parse_nested_deprecated include/net/netlink.h:1248 [inline]  __rtnl_newlink+0x50a/0x1880 net/core/rtnetlink.c:3485  rtnl_newlink+0x64/0xa0 net/core/rtnetlink.c:3594  rtnetlink_rcv_msg+0x43c/0xd70 net/core/rtnetlink.c:6091  netlink_rcv_skb+0x14f/0x410 net/netlink/af_netlink.c:2540  netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline]  netlink_unicast+0x54e/0x800 net/netlink/af_netlink.c:1345  netlink_sendmsg+0x930/0xe50 net/netlink/af_netlink.c:1921  sock_sendmsg_nosec net/socket.c:714 [inline]  sock_sendmsg+0x154/0x190 net/socket.c:734  ____sys_sendmsg+0x6df/0x840 net/socket.c:2482  ___sys_sendmsg+0x110/0x1b0 net/socket.c:2536  __sys_sendmsg+0xf3/0x1c0 net/socket.c:2565  do_syscall_x64 arch/x86/entry/common.c:50 [inline]  do_syscall_64+0x3b/0x90 arch/x86/entry/common.c:80  entry_SYSCALL_64_after_hwframe+0x63/0xcd RIP: 0033:0x7fdcf2072359 Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 f1 19 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 \u003c48\u003e 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007fdcf13e3168 EFLAGS: 00000246 ORIG_RAX: 000000000000002e RAX: ffffffffffffffda RBX: 00007fdcf219ff80 RCX: 00007fdcf2072359 RDX: 0000000000000000 RSI: 0000000020000200 RDI: 0000000000000003 RBP: 00007fdcf20bd493 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000 R13: 00007fffbb8d7bdf R14: 00007fdcf13e3300 R15: 0000000000022000  \u003c/TASK\u003e  The buggy address belongs to the variable:  rmnet_policy+0x30/0xe0  The buggy address belongs to the physical page: page:0000000065bdeb3c refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x155243 flags: 0x200000000001000(reserved|node=0|zone=2) raw: 0200000000001000 ffffea00055490c8 ffffea00055490c8 0000000000000000 raw: 0000000000000000 0000000000000000 00000001ffffffff 0000000000000000 page dumped because: kasan: bad access detected  Memory state around the buggy address:  ffffffff92c43780: f9 f9 f9 f9 00 00 00 02 f9 f9 f9 f9 00 00 00 07  ffffffff92c43800: f9 f9 f9 f9 00 00 00 05 f9 f9 f9 f9 06 f9 f9 f9 \u003effffffff92c43880: f9 f9 f9 f9 00 00 00 00 00 00 f9 f9 f9 f9 f9 f9                                                  ^  ffffffff92c43900: 00 00 00 00 00 00 00 00 07 f9 f9 f9 f9 f9 f9 f9  ffffffff92c43980: 00 00 00 07 f9 f9 f9 f9 00 00 00 05 f9 f9 f9 f9  According to the comment of `nla_parse_nested_deprecated`, the maxtype should be len(destination array) - 1. Hence use `IFLA_RMNET_MAX` here.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26597",
            "severity": "Unknown",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-4543",
            "namespace": "debian:11",
            "description": "A flaw named \"EntryBleed\" was found in the Linux Kernel Page Table Isolation (KPTI). This issue could allow a local attacker to leak KASLR base via prefetch side-channels based on TLB timing for Intel systems.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-4543",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52500",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: pm80xx: Avoid leaking tags when processing OPC_INB_SET_CONTROLLER_CONFIG command  Tags allocated for OPC_INB_SET_CONTROLLER_CONFIG command need to be freed when we receive the response.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52500",
            "severity": "Unknown",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52451",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  powerpc/pseries/memhp: Fix access beyond end of drmem array  dlpar_memory_remove_by_index() may access beyond the bounds of the drmem lmb array when the LMB lookup fails to match an entry with the given DRC index. When the search fails, the cursor is left pointing to \u0026drmem_info-\u003elmbs[drmem_info-\u003en_lmbs], which is one element past the last valid entry in the array. The debug message at the end of the function then dereferences this pointer:          pr_debug(\"Failed to hot-remove memory at %llx\\n\",                  lmb-\u003ebase_addr);  This was found by inspection and confirmed with KASAN:    pseries-hotplug-mem: Attempting to hot-remove LMB, drc index 1234   ==================================================================   BUG: KASAN: slab-out-of-bounds in dlpar_memory+0x298/0x1658   Read of size 8 at addr c000000364e97fd0 by task bash/949    dump_stack_lvl+0xa4/0xfc (unreliable)   print_report+0x214/0x63c   kasan_report+0x140/0x2e0   __asan_load8+0xa8/0xe0   dlpar_memory+0x298/0x1658   handle_dlpar_errorlog+0x130/0x1d0   dlpar_store+0x18c/0x3e0   kobj_attr_store+0x68/0xa0   sysfs_kf_write+0xc4/0x110   kernfs_fop_write_iter+0x26c/0x390   vfs_write+0x2d4/0x4e0   ksys_write+0xac/0x1a0   system_call_exception+0x268/0x530   system_call_vectored_common+0x15c/0x2ec    Allocated by task 1:    kasan_save_stack+0x48/0x80    kasan_set_track+0x34/0x50    kasan_save_alloc_info+0x34/0x50    __kasan_kmalloc+0xd0/0x120    __kmalloc+0x8c/0x320    kmalloc_array.constprop.0+0x48/0x5c    drmem_init+0x2a0/0x41c    do_one_initcall+0xe0/0x5c0    kernel_init_freeable+0x4ec/0x5a0    kernel_init+0x30/0x1e0    ret_from_kernel_user_thread+0x14/0x1c    The buggy address belongs to the object at c000000364e80000    which belongs to the cache kmalloc-128k of size 131072   The buggy address is located 0 bytes to the right of    allocated 98256-byte region [c000000364e80000, c000000364e97fd0)    ==================================================================   pseries-hotplug-mem: Failed to hot-remove memory at 0  Log failed lookups with a separate message and dereference the cursor only when it points to a valid entry.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52451",
            "severity": "Unknown",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-0565",
            "namespace": "debian:11",
            "description": "An out-of-bounds memory read flaw was found in receive_encrypted_standard in fs/smb/client/smb2ops.c in the SMB Client sub-component in the Linux Kernel. This issue occurs due to integer underflow on the memcpy length, leading to a denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-0565",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-39192",
            "namespace": "debian:11",
            "description": "A flaw was found in the Netfilter subsystem in the Linux kernel. The xt_u32 module did not validate the fields in the xt_u32 structure. This flaw allows a local privileged attacker to trigger an out-of-bounds read by setting the size fields with a value beyond the array boundaries, leading to a crash or information disclosure.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-39192",
            "severity": "Unknown",
            "fixedby": "5.10.197-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-34319",
            "namespace": "debian:11",
            "description": "The fix for XSA-423 added logic to Linux'es netback driver to deal with a frontend splitting a packet in a way such that not all of the headers would come in one piece.  Unfortunately the logic introduced there didn't account for the extreme case of the entire packet being split into as many pieces as permitted by the protocol, yet still being smaller than the area that's specially dealt with to keep all (possible) headers together.  Such an unusual packet would therefore trigger a buffer overrun in the driver.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-34319",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-4208",
            "namespace": "debian:11",
            "description": "A use-after-free vulnerability in the Linux kernel's net/sched: cls_u32 component can be exploited to achieve local privilege escalation.  When u32_change() is called on an existing filter, the whole tcf_result struct is always copied into the new instance of the filter. This causes a problem when updating a filter bound to a class, as tcf_unbind_filter() is always called on the old instance in the success path, decreasing filter_cnt of the still referenced class and allowing it to be deleted, leading to a use-after-free.  We recommend upgrading past commit 3044b16e7c6fe5d24b1cdbcf1bd0a9d92d1ebd81.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4208",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52482",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  x86/srso: Add SRSO mitigation for Hygon processors  Add mitigation for the speculative return stack overflow vulnerability which exists on Hygon processors too.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52482",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-6931",
            "namespace": "debian:11",
            "description": "A heap out-of-bounds write vulnerability in the Linux kernel's Performance Events system component can be exploited to achieve local privilege escalation.  A perf_event's read_size can overflow, leading to an heap out-of-bounds increment or write in perf_read_group().  We recommend upgrading past commit 382c27f4ed28f803b1f1473ac2d8db0afc795a1b.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-6931",
            "severity": "Unknown",
            "fixedby": "5.10.205-2"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52618",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  block/rnbd-srv: Check for unlikely string overflow  Since \"dev_search_path\" can technically be as large as PATH_MAX, there was a risk of truncation when copying it and a second string into \"full_path\" since it was also PATH_MAX sized. The W=1 builds were reporting this warning:  drivers/block/rnbd/rnbd-srv.c: In function 'process_msg_open.isra': drivers/block/rnbd/rnbd-srv.c:616:51: warning: '%s' directive output may be truncated writing up to 254 bytes into a region of size between 0 and 4095 [-Wformat-truncation=]   616 |                 snprintf(full_path, PATH_MAX, \"%s/%s\",       |                                                   ^~ In function 'rnbd_srv_get_full_path',     inlined from 'process_msg_open.isra' at drivers/block/rnbd/rnbd-srv.c:721:14: drivers/block/rnbd/rnbd-srv.c:616:17: note: 'snprintf' output between 2 and 4351 bytes into a destination of size 4096   616 |                 snprintf(full_path, PATH_MAX, \"%s/%s\",       |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   617 |                          dev_search_path, dev_name);       |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~  To fix this, unconditionally check for truncation (as was already done for the case where \"%SESSNAME%\" was present).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52618",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-6356",
            "namespace": "debian:11",
            "description": "A flaw was found in the Linux kernel's NVMe driver. This issue may allow an unauthenticated malicious actor to send a set of crafted TCP packages when using NVMe over TCP, leading the NVMe driver to a NULL pointer dereference in the NVMe driver and causing kernel panic and a denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-6356",
            "severity": "Unknown",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52478",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  HID: logitech-hidpp: Fix kernel crash on receiver USB disconnect  hidpp_connect_event() has *four* time-of-check vs time-of-use (TOCTOU) races when it races with itself.  hidpp_connect_event() primarily runs from a workqueue but it also runs on probe() and if a \"device-connected\" packet is received by the hw when the thread running hidpp_connect_event() from probe() is waiting on the hw, then a second thread running hidpp_connect_event() will be started from the workqueue.  This opens the following races (note the below code is simplified):  1. Retrieving + printing the protocol (harmless race):  \tif (!hidpp-\u003eprotocol_major) { \t\thidpp_root_get_protocol_version() \t\thidpp-\u003eprotocol_major = response.rap.params[0]; \t}  We can actually see this race hit in the dmesg in the abrt output attached to rhbz#2227968:  [ 3064.624215] logitech-hidpp-device 0003:046D:4071.0049: HID++ 4.5 device connected. [ 3064.658184] logitech-hidpp-device 0003:046D:4071.0049: HID++ 4.5 device connected.  Testing with extra logging added has shown that after this the 2 threads take turn grabbing the hw access mutex (send_mutex) so they ping-pong through all the other TOCTOU cases managing to hit all of them:  2. Updating the name to the HIDPP name (harmless race):  \tif (hidpp-\u003ename == hdev-\u003ename) { \t\t... \t\thidpp-\u003ename = new_name; \t}  3. Initializing the power_supply class for the battery (problematic!):  hidpp_initialize_battery() {         if (hidpp-\u003ebattery.ps)                 return 0;  \tprobe_battery(); /* Blocks, threads take turns executing this */  \thidpp-\u003ebattery.desc.properties = \t\tdevm_kmemdup(dev, hidpp_battery_props, cnt, GFP_KERNEL);  \thidpp-\u003ebattery.ps = \t\tdevm_power_supply_register(\u0026hidpp-\u003ehid_dev-\u003edev, \t\t\t\t\t   \u0026hidpp-\u003ebattery.desc, cfg); }  4. Creating delayed input_device (potentially problematic):  \tif (hidpp-\u003edelayed_input) \t\treturn;  \thidpp-\u003edelayed_input = hidpp_allocate_input(hdev);  The really big problem here is 3. Hitting the race leads to the following sequence:  \thidpp-\u003ebattery.desc.properties = \t\tdevm_kmemdup(dev, hidpp_battery_props, cnt, GFP_KERNEL);  \thidpp-\u003ebattery.ps = \t\tdevm_power_supply_register(\u0026hidpp-\u003ehid_dev-\u003edev, \t\t\t\t\t   \u0026hidpp-\u003ebattery.desc, cfg);  \t...  \thidpp-\u003ebattery.desc.properties = \t\tdevm_kmemdup(dev, hidpp_battery_props, cnt, GFP_KERNEL);  \thidpp-\u003ebattery.ps = \t\tdevm_power_supply_register(\u0026hidpp-\u003ehid_dev-\u003edev, \t\t\t\t\t   \u0026hidpp-\u003ebattery.desc, cfg);  So now we have registered 2 power supplies for the same battery, which looks a bit weird from userspace's pov but this is not even the really big problem.  Notice how:  1. This is all devm-maganaged 2. The hidpp-\u003ebattery.desc struct is shared between the 2 power supplies 3. hidpp-\u003ebattery.desc.properties points to the result from the second    devm_kmemdup()  This causes a use after free scenario on USB disconnect of the receiver: 1. The last registered power supply class device gets unregistered 2. The memory from the last devm_kmemdup() call gets freed,    hidpp-\u003ebattery.desc.properties now points to freed memory 3. The first registered power supply class device gets unregistered,    this involves sending a remove uevent to userspace which invokes    power_supply_uevent() to fill the uevent data 4. power_supply_uevent() uses hidpp-\u003ebattery.desc.properties which    now points to freed memory leading to backtraces like this one:  Sep 22 20:01:35 eric kernel: BUG: unable to handle page fault for address: ffffb2140e017f08 ... Sep 22 20:01:35 eric kernel: Workqueue: usb_hub_wq hub_event Sep 22 20:01:35 eric kernel: RIP: 0010:power_supply_uevent+0xee/0x1d0 ... Sep 22 20:01:35 eric kernel:  ? asm_exc_page_fault+0x26/0x30 Sep 22 20:01:35 eric kernel:  ? power_supply_uevent+0xee/0x1d0 Sep 22 20:01:35 eric kernel:  ? power_supply_uevent+0x10d/0x1d0 Sep 22 20:01:35 eric kernel:  dev_uevent+0x10f/0x2d0 Sep 22 20:01:35 eric kernel:  kobject_uevent_env+0x291/0x680 Sep 22 20:01:35 eric kernel:   ---truncated---",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52478",
            "severity": "Unknown",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-6270",
            "namespace": "debian:11",
            "description": "A flaw was found in the ATA over Ethernet (AoE) driver in the Linux kernel. The aoecmd_cfg_pkts() function improperly updates the refcnt on `struct net_device`, and a use-after-free can be triggered by racing between the free on the struct and the access through the `skbtxq` global queue. This could lead to a denial of service condition or potential code execution.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-6270",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2021-3864",
            "namespace": "debian:11",
            "description": "A flaw was found in the way the dumpable flag setting was handled when certain SUID binaries executed its descendants. The prerequisite is a SUID binary that sets real UID equal to effective UID, and real GID equal to effective GID. The descendant will then have a dumpable value set to 1. As a result, if the descendant process crashes and core_pattern is set to a relative value, its core dump is stored in the current directory with uid:gid permissions. An unprivileged local user with eligible root SUID binary could use this flaw to place core dumps into root-owned directories, potentially resulting in escalation of privileges.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-3864",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52591",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  reiserfs: Avoid touching renamed directory if parent does not change  The VFS will not be locking moved directory if its parent does not change. Change reiserfs rename code to avoid touching renamed directory if its parent does not change as without locking that can corrupt the filesystem.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52591",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-2985",
            "namespace": "debian:11",
            "description": "A use after free flaw was found in hfsplus_put_super in fs/hfsplus/super.c in the Linux Kernel. This flaw could allow a local user to cause a denial of service problem.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-2985",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-40283",
            "namespace": "debian:11",
            "description": "An issue was discovered in l2cap_sock_release in net/bluetooth/l2cap_sock.c in the Linux kernel before 6.4.10. There is a use-after-free because the children of an sk are mishandled.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-40283",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52464",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  EDAC/thunderx: Fix possible out-of-bounds string access  Enabling -Wstringop-overflow globally exposes a warning for a common bug in the usage of strncat():    drivers/edac/thunderx_edac.c: In function 'thunderx_ocx_com_threaded_isr':   drivers/edac/thunderx_edac.c:1136:17: error: 'strncat' specified bound 1024 equals destination size [-Werror=stringop-overflow=]    1136 |                 strncat(msg, other, OCX_MESSAGE_SIZE);         |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    ...    1145 |                                 strncat(msg, other, OCX_MESSAGE_SIZE);    ...    1150 |                                 strncat(msg, other, OCX_MESSAGE_SIZE);     ...  Apparently the author of this driver expected strncat() to behave the way that strlcat() does, which uses the size of the destination buffer as its third argument rather than the length of the source buffer. The result is that there is no check on the size of the allocated buffer.  Change it to strlcat().    [ bp: Trim compiler output, fixup commit message. ]",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52464",
            "severity": "Unknown",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-6915",
            "namespace": "debian:11",
            "description": "A Null pointer dereference problem was found in ida_free in lib/idr.c in the Linux Kernel. This issue may allow an attacker using this library to cause a denial of service problem due to a missing check at a function return.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-6915",
            "severity": "Unknown",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52502",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  net: nfc: fix races in nfc_llcp_sock_get() and nfc_llcp_sock_get_sn()  Sili Luo reported a race in nfc_llcp_sock_get(), leading to UAF.  Getting a reference on the socket found in a lookup while holding a lock should happen before releasing the lock.  nfc_llcp_sock_get_sn() has a similar problem.  Finally nfc_llcp_recv_snl() needs to make sure the socket found by nfc_llcp_sock_from_sn() does not disappear.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52502",
            "severity": "Unknown",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-22386",
            "namespace": "debian:11",
            "description": "A race condition was found in the Linux kernel's drm/exynos device driver in exynos_drm_crtc_atomic_disable() function. This can result in a null pointer dereference issue, possibly leading to a kernel panic or denial of service issue.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-22386",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52517",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  spi: sun6i: fix race between DMA RX transfer completion and RX FIFO drain  Previously the transfer complete IRQ immediately drained to RX FIFO to read any data remaining in FIFO to the RX buffer. This behaviour is correct when dealing with SPI in interrupt mode. However in DMA mode the transfer complete interrupt still fires as soon as all bytes to be transferred have been stored in the FIFO. At that point data in the FIFO still needs to be picked up by the DMA engine. Thus the drain procedure and DMA engine end up racing to read from RX FIFO, corrupting any data read. Additionally the RX buffer pointer is never adjusted according to DMA progress in DMA mode, thus calling the RX FIFO drain procedure in DMA mode is a bug. Fix corruptions in DMA RX mode by draining RX FIFO only in interrupt mode. Also wait for completion of RX DMA when in DMA mode before returning to ensure all data has been copied to the supplied memory buffer.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52517",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-23849",
            "namespace": "debian:11",
            "description": "In rds_recv_track_latency in net/rds/af_rds.c in the Linux kernel through 6.7.1, there is an off-by-one error for an RDS_MSG_RX_DGRAM_TRACE_MAX comparison, resulting in out-of-bounds access.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-23849",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-45863",
            "namespace": "debian:11",
            "description": "An issue was discovered in lib/kobject.c in the Linux kernel before 6.2.3. With root access, an attacker can trigger a race condition that results in a fill_kobj_path out-of-bounds write.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-45863",
            "severity": "Unknown",
            "fixedby": "5.10.205-2"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26600",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  phy: ti: phy-omap-usb2: Fix NULL pointer dereference for SRP  If the external phy working together with phy-omap-usb2 does not implement send_srp(), we may still attempt to call it. This can happen on an idle Ethernet gadget triggering a wakeup for example:  configfs-gadget.g1 gadget.0: ECM Suspend configfs-gadget.g1 gadget.0: Port suspended. Triggering wakeup ... Unable to handle kernel NULL pointer dereference at virtual address 00000000 when execute ... PC is at 0x0 LR is at musb_gadget_wakeup+0x1d4/0x254 [musb_hdrc] ... musb_gadget_wakeup [musb_hdrc] from usb_gadget_wakeup+0x1c/0x3c [udc_core] usb_gadget_wakeup [udc_core] from eth_start_xmit+0x3b0/0x3d4 [u_ether] eth_start_xmit [u_ether] from dev_hard_start_xmit+0x94/0x24c dev_hard_start_xmit from sch_direct_xmit+0x104/0x2e4 sch_direct_xmit from __dev_queue_xmit+0x334/0xd88 __dev_queue_xmit from arp_solicit+0xf0/0x268 arp_solicit from neigh_probe+0x54/0x7c neigh_probe from __neigh_event_send+0x22c/0x47c __neigh_event_send from neigh_resolve_output+0x14c/0x1c0 neigh_resolve_output from ip_finish_output2+0x1c8/0x628 ip_finish_output2 from ip_send_skb+0x40/0xd8 ip_send_skb from udp_send_skb+0x124/0x340 udp_send_skb from udp_sendmsg+0x780/0x984 udp_sendmsg from __sys_sendto+0xd8/0x158 __sys_sendto from ret_fast_syscall+0x0/0x58  Let's fix the issue by checking for send_srp() and set_vbus() before calling them. For USB peripheral only cases these both could be NULL.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26600",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-47233",
            "namespace": "debian:11",
            "description": "The brcm80211 component in the Linux kernel through 6.5.10 has a brcmf_cfg80211_detach use-after-free in the device unplugging (disconnect the USB by hotplug) code. For physically proximate attackers with local access, this \"could be exploited in a real world scenario.\" This is related to brcmf_cfg80211_escan_timeout_worker in drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-47233",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52443",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  apparmor: avoid crash when parsed profile name is empty  When processing a packed profile in unpack_profile() described like   \"profile :ns::samba-dcerpcd /usr/lib*/samba/{,samba/}samba-dcerpcd {...}\"  a string \":samba-dcerpcd\" is unpacked as a fully-qualified name and then passed to aa_splitn_fqname().  aa_splitn_fqname() treats \":samba-dcerpcd\" as only containing a namespace. Thus it returns NULL for tmpname, meanwhile tmpns is non-NULL. Later aa_alloc_profile() crashes as the new profile name is NULL now.  general protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN NOPTI KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007] CPU: 6 PID: 1657 Comm: apparmor_parser Not tainted 6.7.0-rc2-dirty #16 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.2-3-gd478f380-rebuilt.opensuse.org 04/01/2014 RIP: 0010:strlen+0x1e/0xa0 Call Trace:  \u003cTASK\u003e  ? strlen+0x1e/0xa0  aa_policy_init+0x1bb/0x230  aa_alloc_profile+0xb1/0x480  unpack_profile+0x3bc/0x4960  aa_unpack+0x309/0x15e0  aa_replace_profiles+0x213/0x33c0  policy_update+0x261/0x370  profile_replace+0x20e/0x2a0  vfs_write+0x2af/0xe00  ksys_write+0x126/0x250  do_syscall_64+0x46/0xf0  entry_SYSCALL_64_after_hwframe+0x6e/0x76  \u003c/TASK\u003e ---[ end trace 0000000000000000 ]--- RIP: 0010:strlen+0x1e/0xa0  It seems such behaviour of aa_splitn_fqname() is expected and checked in other places where it is called (e.g. aa_remove_profiles). Well, there is an explicit comment \"a ns name without a following profile is allowed\" inside.  AFAICS, nothing can prevent unpacked \"name\" to be in form like \":samba-dcerpcd\" - it is passed from userspace.  Deny the whole profile set replacement in such case and inform user with EPROTO and an explaining message.  Found by Linux Verification Center (linuxtesting.org).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52443",
            "severity": "Unknown",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52498",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  PM: sleep: Fix possible deadlocks in core system-wide PM code  It is reported that in low-memory situations the system-wide resume core code deadlocks, because async_schedule_dev() executes its argument function synchronously if it cannot allocate memory (and not only in that case) and that function attempts to acquire a mutex that is already held.  Executing the argument function synchronously from within dpm_async_fn() may also be problematic for ordering reasons (it may cause a consumer device's resume callback to be invoked before a requisite supplier device's one, for example).  Address this by changing the code in question to use async_schedule_dev_nocall() for scheduling the asynchronous execution of device suspend and resume functions and to directly run them synchronously if async_schedule_dev_nocall() returns false.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52498",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52484",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  iommu/arm-smmu-v3: Fix soft lockup triggered by arm_smmu_mm_invalidate_range  When running an SVA case, the following soft lockup is triggered: -------------------------------------------------------------------- watchdog: BUG: soft lockup - CPU#244 stuck for 26s! pstate: 83400009 (Nzcv daif +PAN -UAO +TCO +DIT -SSBS BTYPE=--) pc : arm_smmu_cmdq_issue_cmdlist+0x178/0xa50 lr : arm_smmu_cmdq_issue_cmdlist+0x150/0xa50 sp : ffff8000d83ef290 x29: ffff8000d83ef290 x28: 000000003b9aca00 x27: 0000000000000000 x26: ffff8000d83ef3c0 x25: da86c0812194a0e8 x24: 0000000000000000 x23: 0000000000000040 x22: ffff8000d83ef340 x21: ffff0000c63980c0 x20: 0000000000000001 x19: ffff0000c6398080 x18: 0000000000000000 x17: 0000000000000000 x16: 0000000000000000 x15: ffff3000b4a3bbb0 x14: ffff3000b4a30888 x13: ffff3000b4a3cf60 x12: 0000000000000000 x11: 0000000000000000 x10: 0000000000000000 x9 : ffffc08120e4d6bc x8 : 0000000000000000 x7 : 0000000000000000 x6 : 0000000000048cfa x5 : 0000000000000000 x4 : 0000000000000001 x3 : 000000000000000a x2 : 0000000080000000 x1 : 0000000000000000 x0 : 0000000000000001 Call trace:  arm_smmu_cmdq_issue_cmdlist+0x178/0xa50  __arm_smmu_tlb_inv_range+0x118/0x254  arm_smmu_tlb_inv_range_asid+0x6c/0x130  arm_smmu_mm_invalidate_range+0xa0/0xa4  __mmu_notifier_invalidate_range_end+0x88/0x120  unmap_vmas+0x194/0x1e0  unmap_region+0xb4/0x144  do_mas_align_munmap+0x290/0x490  do_mas_munmap+0xbc/0x124  __vm_munmap+0xa8/0x19c  __arm64_sys_munmap+0x28/0x50  invoke_syscall+0x78/0x11c  el0_svc_common.constprop.0+0x58/0x1c0  do_el0_svc+0x34/0x60  el0_svc+0x2c/0xd4  el0t_64_sync_handler+0x114/0x140  el0t_64_sync+0x1a4/0x1a8 --------------------------------------------------------------------  Note that since 6.6-rc1 the arm_smmu_mm_invalidate_range above is renamed to \"arm_smmu_mm_arch_invalidate_secondary_tlbs\", yet the problem remains.  The commit 06ff87bae8d3 (\"arm64: mm: remove unused functions and variable protoypes\") fixed a similar lockup on the CPU MMU side. Yet, it can occur to SMMU too, since arm_smmu_mm_arch_invalidate_secondary_tlbs() is called typically next to MMU tlb flush function, e.g. \ttlb_flush_mmu_tlbonly { \t\ttlb_flush { \t\t\t__flush_tlb_range { \t\t\t\t// check MAX_TLBI_OPS \t\t\t} \t\t} \t\tmmu_notifier_arch_invalidate_secondary_tlbs { \t\t\tarm_smmu_mm_arch_invalidate_secondary_tlbs { \t\t\t\t// does not check MAX_TLBI_OPS \t\t\t} \t\t} \t}  Clone a CMDQ_MAX_TLBI_OPS from the MAX_TLBI_OPS in tlbflush.h, since in an SVA case SMMU uses the CPU page table, so it makes sense to align with the tlbflush code. Then, replace per-page TLBI commands with a single per-asid TLBI command, if the request size hits this threshold.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52484",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-2873",
            "namespace": "debian:11",
            "description": "An out-of-bounds memory access flaw was found in the Linux kernel Intel’s iSMT SMBus host controller driver in the way a user triggers the I2C_SMBUS_BLOCK_DATA (with the ioctl I2C_SMBUS) with malicious input data. This flaw allows a local user to crash the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-2873",
            "severity": "Unknown",
            "fixedby": "5.10.162-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26641",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  ip6_tunnel: make sure to pull inner header in __ip6_tnl_rcv()  syzbot found __ip6_tnl_rcv() could access unitiliazed data [1].  Call pskb_inet_may_pull() to fix this, and initialize ipv6h variable after this call as it can change skb-\u003ehead.  [1]  BUG: KMSAN: uninit-value in __INET_ECN_decapsulate include/net/inet_ecn.h:253 [inline]  BUG: KMSAN: uninit-value in INET_ECN_decapsulate include/net/inet_ecn.h:275 [inline]  BUG: KMSAN: uninit-value in IP6_ECN_decapsulate+0x7df/0x1e50 include/net/inet_ecn.h:321   __INET_ECN_decapsulate include/net/inet_ecn.h:253 [inline]   INET_ECN_decapsulate include/net/inet_ecn.h:275 [inline]   IP6_ECN_decapsulate+0x7df/0x1e50 include/net/inet_ecn.h:321   ip6ip6_dscp_ecn_decapsulate+0x178/0x1b0 net/ipv6/ip6_tunnel.c:727   __ip6_tnl_rcv+0xd4e/0x1590 net/ipv6/ip6_tunnel.c:845   ip6_tnl_rcv+0xce/0x100 net/ipv6/ip6_tunnel.c:888  gre_rcv+0x143f/0x1870   ip6_protocol_deliver_rcu+0xda6/0x2a60 net/ipv6/ip6_input.c:438   ip6_input_finish net/ipv6/ip6_input.c:483 [inline]   NF_HOOK include/linux/netfilter.h:314 [inline]   ip6_input+0x15d/0x430 net/ipv6/ip6_input.c:492   ip6_mc_input+0xa7e/0xc80 net/ipv6/ip6_input.c:586   dst_input include/net/dst.h:461 [inline]   ip6_rcv_finish+0x5db/0x870 net/ipv6/ip6_input.c:79   NF_HOOK include/linux/netfilter.h:314 [inline]   ipv6_rcv+0xda/0x390 net/ipv6/ip6_input.c:310   __netif_receive_skb_one_core net/core/dev.c:5532 [inline]   __netif_receive_skb+0x1a6/0x5a0 net/core/dev.c:5646   netif_receive_skb_internal net/core/dev.c:5732 [inline]   netif_receive_skb+0x58/0x660 net/core/dev.c:5791   tun_rx_batched+0x3ee/0x980 drivers/net/tun.c:1555   tun_get_user+0x53af/0x66d0 drivers/net/tun.c:2002   tun_chr_write_iter+0x3af/0x5d0 drivers/net/tun.c:2048   call_write_iter include/linux/fs.h:2084 [inline]   new_sync_write fs/read_write.c:497 [inline]   vfs_write+0x786/0x1200 fs/read_write.c:590   ksys_write+0x20f/0x4c0 fs/read_write.c:643   __do_sys_write fs/read_write.c:655 [inline]   __se_sys_write fs/read_write.c:652 [inline]   __x64_sys_write+0x93/0xd0 fs/read_write.c:652   do_syscall_x64 arch/x86/entry/common.c:52 [inline]   do_syscall_64+0x6d/0x140 arch/x86/entry/common.c:83  entry_SYSCALL_64_after_hwframe+0x63/0x6b  Uninit was created at:   slab_post_alloc_hook+0x129/0xa70 mm/slab.h:768   slab_alloc_node mm/slub.c:3478 [inline]   kmem_cache_alloc_node+0x5e9/0xb10 mm/slub.c:3523   kmalloc_reserve+0x13d/0x4a0 net/core/skbuff.c:560   __alloc_skb+0x318/0x740 net/core/skbuff.c:651   alloc_skb include/linux/skbuff.h:1286 [inline]   alloc_skb_with_frags+0xc8/0xbd0 net/core/skbuff.c:6334   sock_alloc_send_pskb+0xa80/0xbf0 net/core/sock.c:2787   tun_alloc_skb drivers/net/tun.c:1531 [inline]   tun_get_user+0x1e8a/0x66d0 drivers/net/tun.c:1846   tun_chr_write_iter+0x3af/0x5d0 drivers/net/tun.c:2048   call_write_iter include/linux/fs.h:2084 [inline]   new_sync_write fs/read_write.c:497 [inline]   vfs_write+0x786/0x1200 fs/read_write.c:590   ksys_write+0x20f/0x4c0 fs/read_write.c:643   __do_sys_write fs/read_write.c:655 [inline]   __se_sys_write fs/read_write.c:652 [inline]   __x64_sys_write+0x93/0xd0 fs/read_write.c:652   do_syscall_x64 arch/x86/entry/common.c:52 [inline]   do_syscall_64+0x6d/0x140 arch/x86/entry/common.c:83  entry_SYSCALL_64_after_hwframe+0x63/0x6b  CPU: 0 PID: 5034 Comm: syz-executor331 Not tainted 6.7.0-syzkaller-00562-g9f8413c4a66f #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 11/17/2023",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26641",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-26545",
            "namespace": "debian:11",
            "description": "In the Linux kernel before 6.1.13, there is a double free in net/mpls/af_mpls.c upon an allocation failure (for registering the sysctl table under a new location) during the renaming of a device.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-26545",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52458",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  block: add check that partition length needs to be aligned with block size  Before calling add partition or resize partition, there is no check on whether the length is aligned with the logical block size. If the logical block size of the disk is larger than 512 bytes, then the partition size maybe not the multiple of the logical block size, and when the last sector is read, bio_truncate() will adjust the bio size, resulting in an IO error if the size of the read command is smaller than the logical block size.If integrity data is supported, this will also result in a null pointer dereference when calling bio_integrity_free.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52458",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-3338",
            "namespace": "debian:11",
            "description": "A null pointer dereference flaw was found in the Linux kernel's DECnet networking protocol. This issue could allow a remote user to crash the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3338",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-51042",
            "namespace": "debian:11",
            "description": "In the Linux kernel before 6.4.12, amdgpu_cs_wait_all_fences in drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c has a fence use-after-free.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-51042",
            "severity": "Unknown",
            "fixedby": "5.10.197-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-24861",
            "namespace": "debian:11",
            "description": "A race condition was found in the Linux kernel's media/xc4000 device driver in xc4000 xc4000_get_frequency() function. This can result in return value overflow issue, possibly leading to malfunction or denial of service issue.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-24861",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-4623",
            "namespace": "debian:11",
            "description": "A use-after-free vulnerability in the Linux kernel's net/sched: sch_hfsc (HFSC qdisc traffic control) component can be exploited to achieve local privilege escalation.  If a class with a link-sharing curve (i.e. with the HFSC_FSC flag set) has a parent without a link-sharing curve, then init_vf() will call vttree_insert() on the parent, but vttree_remove() will be skipped in update_vf(). This leaves a dangling pointer that can cause a use-after-free.  We recommend upgrading past commit b3d26c5702c7d6c45456326e56d2ccf3f103e60f.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4623",
            "severity": "Unknown",
            "fixedby": "5.10.197-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52475",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  Input: powermate - fix use-after-free in powermate_config_complete  syzbot has found a use-after-free bug [1] in the powermate driver. This happens when the device is disconnected, which leads to a memory free from the powermate_device struct.  When an asynchronous control message completes after the kfree and its callback is invoked, the lock does not exist anymore and hence the bug.  Use usb_kill_urb() on pm-\u003econfig to cancel any in-progress requests upon device disconnection.  [1] https://syzkaller.appspot.com/bug?extid=0434ac83f907a1dbdd1e",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52475",
            "severity": "Unknown",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52604",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  FS:JFS:UBSAN:array-index-out-of-bounds in dbAdjTree  Syzkaller reported the following issue:  UBSAN: array-index-out-of-bounds in fs/jfs/jfs_dmap.c:2867:6 index 196694 is out of range for type 's8[1365]' (aka 'signed char[1365]') CPU: 1 PID: 109 Comm: jfsCommit Not tainted 6.6.0-rc3-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/04/2023 Call Trace:  \u003cTASK\u003e  __dump_stack lib/dump_stack.c:88 [inline]  dump_stack_lvl+0x1e7/0x2d0 lib/dump_stack.c:106  ubsan_epilogue lib/ubsan.c:217 [inline]  __ubsan_handle_out_of_bounds+0x11c/0x150 lib/ubsan.c:348  dbAdjTree+0x474/0x4f0 fs/jfs/jfs_dmap.c:2867  dbJoin+0x210/0x2d0 fs/jfs/jfs_dmap.c:2834  dbFreeBits+0x4eb/0xda0 fs/jfs/jfs_dmap.c:2331  dbFreeDmap fs/jfs/jfs_dmap.c:2080 [inline]  dbFree+0x343/0x650 fs/jfs/jfs_dmap.c:402  txFreeMap+0x798/0xd50 fs/jfs/jfs_txnmgr.c:2534  txUpdateMap+0x342/0x9e0  txLazyCommit fs/jfs/jfs_txnmgr.c:2664 [inline]  jfs_lazycommit+0x47a/0xb70 fs/jfs/jfs_txnmgr.c:2732  kthread+0x2d3/0x370 kernel/kthread.c:388  ret_from_fork+0x48/0x80 arch/x86/kernel/process.c:147  ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:304  \u003c/TASK\u003e ================================================================================ Kernel panic - not syncing: UBSAN: panic_on_warn set ... CPU: 1 PID: 109 Comm: jfsCommit Not tainted 6.6.0-rc3-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/04/2023 Call Trace:  \u003cTASK\u003e  __dump_stack lib/dump_stack.c:88 [inline]  dump_stack_lvl+0x1e7/0x2d0 lib/dump_stack.c:106  panic+0x30f/0x770 kernel/panic.c:340  check_panic_on_warn+0x82/0xa0 kernel/panic.c:236  ubsan_epilogue lib/ubsan.c:223 [inline]  __ubsan_handle_out_of_bounds+0x13c/0x150 lib/ubsan.c:348  dbAdjTree+0x474/0x4f0 fs/jfs/jfs_dmap.c:2867  dbJoin+0x210/0x2d0 fs/jfs/jfs_dmap.c:2834  dbFreeBits+0x4eb/0xda0 fs/jfs/jfs_dmap.c:2331  dbFreeDmap fs/jfs/jfs_dmap.c:2080 [inline]  dbFree+0x343/0x650 fs/jfs/jfs_dmap.c:402  txFreeMap+0x798/0xd50 fs/jfs/jfs_txnmgr.c:2534  txUpdateMap+0x342/0x9e0  txLazyCommit fs/jfs/jfs_txnmgr.c:2664 [inline]  jfs_lazycommit+0x47a/0xb70 fs/jfs/jfs_txnmgr.c:2732  kthread+0x2d3/0x370 kernel/kthread.c:388  ret_from_fork+0x48/0x80 arch/x86/kernel/process.c:147  ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:304  \u003c/TASK\u003e Kernel Offset: disabled Rebooting in 86400 seconds..  The issue is caused when the value of lp becomes greater than CTLTREESIZE which is the max size of stree. Adding a simple check solves this issue.  Dave: As the function returns a void, good error handling would require a more intrusive code reorganization, so I modified Osama's patch at use WARN_ON_ONCE for lack of a cleaner option.  The patch is tested via syzbot.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52604",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-34324",
            "namespace": "debian:11",
            "description": "Closing of an event channel in the Linux kernel can result in a deadlock. This happens when the close is being performed in parallel to an unrelated Xen console action and the handling of a Xen console interrupt in an unprivileged guest.  The closing of an event channel is e.g. triggered by removal of a paravirtual device on the other side. As this action will cause console messages to be issued on the other side quite often, the chance of triggering the deadlock is not neglectable.  Note that 32-bit Arm-guests are not affected, as the 32-bit Linux kernel on Arm doesn't use queued-RW-locks, which are required to trigger the issue (on Arm32 a waiting writer doesn't block further readers to get the lock).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-34324",
            "severity": "Unknown",
            "fixedby": "5.10.205-2"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-39194",
            "namespace": "debian:11",
            "description": "A flaw was found in the XFRM subsystem in the Linux kernel. The specific flaw exists within the processing of state filters, which can result in a read past the end of an allocated buffer. This flaw allows a local privileged (CAP_NET_ADMIN) attacker to trigger an out-of-bounds read, potentially leading to an information disclosure.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-39194",
            "severity": "Unknown",
            "fixedby": "5.10.197-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-33288",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel before 6.2.9. A use-after-free was found in bq24190_remove in drivers/power/supply/bq24190_charger.c. It could allow a local attacker to crash the system due to a race condition.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-33288",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-2002",
            "namespace": "debian:11",
            "description": "A vulnerability was found in the HCI sockets implementation due to a missing capability check in net/bluetooth/hci_sock.c in the Linux Kernel. This flaw allows an attacker to unauthorized execution of management commands, compromising the confidentiality, integrity, and availability of Bluetooth communication.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-2002",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-28466",
            "namespace": "debian:11",
            "description": "do_tls_getsockopt in net/tls/tls_main.c in the Linux kernel through 6.2.6 lacks a lock_sock call, leading to a race condition (with a resultant use-after-free or NULL pointer dereference).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-28466",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-45934",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 6.0.10. l2cap_config_req in net/bluetooth/l2cap_core.c has an integer wraparound via L2CAP_CONF_REQ packets.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-45934",
            "severity": "Unknown",
            "fixedby": "5.10.162-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-0639",
            "namespace": "debian:11",
            "description": "A denial of service vulnerability due to a deadlock was found in sctp_auto_asconf_init in net/sctp/socket.c in the Linux kernel’s SCTP subsystem. This flaw allows guests with local user privileges to trigger a deadlock and potentially crash the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-0639",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-30456",
            "namespace": "debian:11",
            "description": "An issue was discovered in arch/x86/kvm/vmx/nested.c in the Linux kernel before 6.2.8. nVMX on x86_64 lacks consistency checks for CR0 and CR4.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-30456",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-1086",
            "namespace": "debian:11",
            "description": "A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation.  The nft_verdict_init() function allows positive values as drop error within the hook verdict, and hence the nf_hook_slow() function can cause a double free vulnerability when NF_DROP is issued with a drop error which resembles NF_ACCEPT.  We recommend upgrading past commit f342de4e2f33e0e39165d8639387aa6c19dff660.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-1086",
            "severity": "Unknown",
            "fixedby": "5.10.209-2"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52566",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  nilfs2: fix potential use after free in nilfs_gccache_submit_read_data()  In nilfs_gccache_submit_read_data(), brelse(bh) is called to drop the reference count of bh when the call to nilfs_dat_translate() fails.  If the reference count hits 0 and its owner page gets unlocked, bh may be freed.  However, bh-\u003eb_page is dereferenced to put the page after that, which may result in a use-after-free bug.  This patch moves the release operation after unlocking and putting the page.  NOTE: The function in question is only called in GC, and in combination with current userland tools, address translation using DAT does not occur in that function, so the code path that causes this issue will not be executed.  However, it is possible to run that code path by intentionally modifying the userland GC library or by calling the GC ioctl directly.  [konishi.ryusuke@gmail.com: NOTE added to the commit log]",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52566",
            "severity": "Unknown",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-1076",
            "namespace": "debian:11",
            "description": "A flaw was found in the Linux Kernel. The tun/tap sockets have their socket UID hardcoded to 0 due to a type confusion in their initialization function. While it will be often correct, as tuntap devices require CAP_NET_ADMIN, it may not always be the case, e.g., a non-root user only having that capability. This would make tun/tap sockets being incorrectly treated in filtering/routing decisions, possibly bypassing network filters.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1076",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-4010",
            "namespace": "debian:11",
            "description": "A flaw was found in the USB Host Controller Driver framework in the Linux kernel. The usb_giveback_urb function has a logic loophole in its implementation. Due to the inappropriate judgment condition of the goto statement, the function cannot return under the input of a specific malformed descriptor file, so it falls into an endless loop, resulting in a denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4010",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-0340",
            "namespace": "debian:11",
            "description": "A vulnerability was found in vhost_new_msg in drivers/vhost/vhost.c in the Linux kernel, which does not properly initialize memory in messages passed between virtual guests and the host operating system in the vhost/vhost.c:vhost_new_msg() function. This issue can allow local privileged users to read some kernel memory contents when reading from the /dev/vhost-net device file.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-0340",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-0045",
            "namespace": "debian:11",
            "description": "The current implementation of the prctl syscall does not issue an IBPB immediately during the syscall. The ib_prctl_set  function updates the Thread Information Flags (TIFs) for the task and updates the SPEC_CTRL MSR on the function __speculation_ctrl_update, but the IBPB is only issued on the next schedule, when the TIF bits are checked. This leaves the victim vulnerable to values already injected on the BTB, prior to the prctl syscall.  The patch that added the support for the conditional mitigation via prctl (ib_prctl_set) dates back to the kernel 4.9.176.  We recommend upgrading past commit a664ec9158eeddd75121d39c9a0758016097fa96",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-0045",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52470",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/radeon: check the alloc_workqueue return value in radeon_crtc_init()  check the alloc_workqueue return value in radeon_crtc_init() to avoid null-ptr-deref.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52470",
            "severity": "Unknown",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-3772",
            "namespace": "debian:11",
            "description": "A flaw was found in the Linux kernel’s IP framework for transforming packets (XFRM subsystem). This issue may allow a malicious user with CAP_NET_ADMIN privileges to directly dereference a NULL pointer in xfrm_update_ae_params(), leading to a possible kernel crash and denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3772",
            "severity": "Unknown",
            "fixedby": "5.10.197-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-3161",
            "namespace": "debian:11",
            "description": "A flaw was found in the Framebuffer Console (fbcon) in the Linux Kernel. When providing font-\u003ewidth and font-\u003eheight greater than 32 to fbcon_set_font, since there are no checks in place, a shift-out-of-bounds occurs leading to undefined behavior and possible denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3161",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52593",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: wfx: fix possible NULL pointer dereference in wfx_set_mfp_ap()  Since 'ieee80211_beacon_get()' can return NULL, 'wfx_set_mfp_ap()' should check the return value before examining skb data. So convert the latter to return an appropriate error code and propagate it to return from 'wfx_start_ap()' as well. Compile tested only.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52593",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52508",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  nvme-fc: Prevent null pointer dereference in nvme_fc_io_getuuid()  The nvme_fc_fcp_op structure describing an AEN operation is initialized with a null request structure pointer. An FC LLDD may make a call to nvme_fc_io_getuuid passing a pointer to an nvmefc_fcp_req for an AEN operation.  Add validation of the request structure pointer before dereference.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52508",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-1151",
            "namespace": "debian:11",
            "description": "A vulnerability was reported in the Open vSwitch sub-component in the Linux Kernel. The flaw occurs when a recursive operation of code push recursively calls into the code block. The OVS module does not validate the stack depth, pushing too many frames and causing a stack overflow. As a result, this can lead to a crash or other related issues.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-1151",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-4244",
            "namespace": "debian:11",
            "description": "A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation.  Due to a race condition between nf_tables netlink control plane transaction and nft_set element garbage collection, it is possible to underflow the reference counter causing a use-after-free vulnerability.  We recommend upgrading past commit 3e91b0ebd994635df2346353322ac51ce84ce6d8.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4244",
            "severity": "Unknown",
            "fixedby": "5.10.197-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52598",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  s390/ptrace: handle setting of fpc register correctly  If the content of the floating point control (fpc) register of a traced process is modified with the ptrace interface the new value is tested for validity by temporarily loading it into the fpc register.  This may lead to corruption of the fpc register of the tracing process: if an interrupt happens while the value is temporarily loaded into the fpc register, and within interrupt context floating point or vector registers are used, the current fp/vx registers are saved with save_fpu_regs() assuming they belong to user space and will be loaded into fp/vx registers when returning to user space.  test_fp_ctl() restores the original user space fpc register value, however it will be discarded, when returning to user space.  In result the tracer will incorrectly continue to run with the value that was supposed to be used for the traced process.  Fix this by saving fpu register contents with save_fpu_regs() before using test_fp_ctl().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52598",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-0607",
            "namespace": "debian:11",
            "description": "A flaw was found in the Netfilter subsystem in the Linux kernel. The issue is in the nft_byteorder_eval() function, where the code iterates through a loop and writes to the `dst` array. On each iteration, 8 bytes are written, but `dst` is an array of u32, so each element only has space for 4 bytes. That means every iteration overwrites part of the previous element corrupting this array of u32. This flaw allows a local user to cause a denial of service or potentially break NetFilter functionality.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-0607",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52609",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  binder: fix race between mmput() and do_exit()  Task A calls binder_update_page_range() to allocate and insert pages on a remote address space from Task B. For this, Task A pins the remote mm via mmget_not_zero() first. This can race with Task B do_exit() and the final mmput() refcount decrement will come from Task A.    Task A            | Task B   ------------------+------------------   mmget_not_zero()  |                     |  do_exit()                     |    exit_mm()                     |      mmput()   mmput()           |     exit_mmap()     |       remove_vma()  |         fput()      |  In this case, the work of ____fput() from Task B is queued up in Task A as TWA_RESUME. So in theory, Task A returns to userspace and the cleanup work gets executed. However, Task A instead sleep, waiting for a reply from Task B that never comes (it's dead).  This means the binder_deferred_release() is blocked until an unrelated binder event forces Task A to go back to userspace. All the associated death notifications will also be delayed until then.  In order to fix this use mmput_async() that will schedule the work in the corresponding mm-\u003easync_put_work WQ instead of Task A.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52609",
            "severity": "Unknown",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26606",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  binder: signal epoll threads of self-work  In (e)poll mode, threads often depend on I/O events to determine when data is ready for consumption. Within binder, a thread may initiate a command via BINDER_WRITE_READ without a read buffer and then make use of epoll_wait() or similar to consume any responses afterwards.  It is then crucial that epoll threads are signaled via wakeup when they queue their own work. Otherwise, they risk waiting indefinitely for an event leaving their work unhandled. What is worse, subsequent commands won't trigger a wakeup either as the thread has pending work.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26606",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52481",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  arm64: errata: Add Cortex-A520 speculative unprivileged load workaround  Implement the workaround for ARM Cortex-A520 erratum 2966298. On an affected Cortex-A520 core, a speculatively executed unprivileged load might leak data from a privileged load via a cache side channel. The issue only exists for loads within a translation regime with the same translation (e.g. same ASID and VMID). Therefore, the issue only affects the return to EL0.  The workaround is to execute a TLBI before returning to EL0 after all loads of privileged data. A non-shareable TLBI to any address is sufficient.  The workaround isn't necessary if page table isolation (KPTI) is enabled, but for simplicity it will be. Page table isolation should normally be disabled for Cortex-A520 as it supports the CSV3 feature and the E0PD feature (used when KASLR is enabled).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52481",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-23307",
            "namespace": "debian:11",
            "description": "Integer Overflow or Wraparound vulnerability in Linux Linux kernel kernel on Linux, x86, ARM (md, raid, raid5 modules) allows Forced Integer Overflow.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-23307",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52485",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Wake DMCUB before sending a command  [Why] We can hang in place trying to send commands when the DMCUB isn't powered on.  [How] For functions that execute within a DC context or DC lock we can wrap the direct calls to dm_execute_dmub_cmd/list with code that exits idle power optimizations and reallows once we're done with the command submission on success.  For DM direct submissions the DM will need to manage the enter/exit sequencing manually.  We cannot invoke a DMCUB command directly within the DM execution helper or we can deadlock.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52485",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-46838",
            "namespace": "debian:11",
            "description": "Transmit requests in Xen's virtual network protocol can consist of multiple parts.  While not really useful, except for the initial part any of them may be of zero length, i.e. carry no data at all.  Besides a certain initial portion of the to be transferred data, these parts are directly translated into what Linux calls SKB fragments.  Such converted request parts can, when for a particular SKB they are all of length zero, lead to a de-reference of NULL in core networking code.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-46838",
            "severity": "Unknown",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26586",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  mlxsw: spectrum_acl_tcam: Fix stack corruption  When tc filters are first added to a net device, the corresponding local port gets bound to an ACL group in the device. The group contains a list of ACLs. In turn, each ACL points to a different TCAM region where the filters are stored. During forwarding, the ACLs are sequentially evaluated until a match is found.  One reason to place filters in different regions is when they are added with decreasing priorities and in an alternating order so that two consecutive filters can never fit in the same region because of their key usage.  In Spectrum-2 and newer ASICs the firmware started to report that the maximum number of ACLs in a group is more than 16, but the layout of the register that configures ACL groups (PAGT) was not updated to account for that. It is therefore possible to hit stack corruption [1] in the rare case where more than 16 ACLs in a group are required.  Fix by limiting the maximum ACL group size to the minimum between what the firmware reports and the maximum ACLs that fit in the PAGT register.  Add a test case to make sure the machine does not crash when this condition is hit.  [1] Kernel panic - not syncing: stack-protector: Kernel stack is corrupted in: mlxsw_sp_acl_tcam_group_update+0x116/0x120 [...]  dump_stack_lvl+0x36/0x50  panic+0x305/0x330  __stack_chk_fail+0x15/0x20  mlxsw_sp_acl_tcam_group_update+0x116/0x120  mlxsw_sp_acl_tcam_group_region_attach+0x69/0x110  mlxsw_sp_acl_tcam_vchunk_get+0x492/0xa20  mlxsw_sp_acl_tcam_ventry_add+0x25/0xe0  mlxsw_sp_acl_rule_add+0x47/0x240  mlxsw_sp_flower_replace+0x1a9/0x1d0  tc_setup_cb_add+0xdc/0x1c0  fl_hw_replace_filter+0x146/0x1f0  fl_change+0xc17/0x1360  tc_new_tfilter+0x472/0xb90  rtnetlink_rcv_msg+0x313/0x3b0  netlink_rcv_skb+0x58/0x100  netlink_unicast+0x244/0x390  netlink_sendmsg+0x1e4/0x440  ____sys_sendmsg+0x164/0x260  ___sys_sendmsg+0x9a/0xe0  __sys_sendmsg+0x7a/0xc0  do_syscall_64+0x40/0xe0  entry_SYSCALL_64_after_hwframe+0x63/0x6b",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26586",
            "severity": "Unknown",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-25741",
            "namespace": "debian:11",
            "description": "printer_write in drivers/usb/gadget/function/f_printer.c in the Linux kernel through 6.7.4 does not properly call usb_ep_queue, which might allow attackers to cause a denial of service or have unspecified other impact.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-25741",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-4622",
            "namespace": "debian:11",
            "description": "A use-after-free vulnerability in the Linux kernel's af_unix component can be exploited to achieve local privilege escalation.  The unix_stream_sendpage() function tries to add data to the last skb in the peer's recv queue without locking the queue. Thus there is a race where unix_stream_sendpage() could access an skb locklessly that is being released by garbage collection, resulting in use-after-free.  We recommend upgrading past commit 790c2f9d15b594350ae9bca7b236f2b1859de02c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4622",
            "severity": "Unknown",
            "fixedby": "5.10.197-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52516",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  dma-debug: don't call __dma_entry_alloc_check_leak() under free_entries_lock  __dma_entry_alloc_check_leak() calls into printk -\u003e serial console output (qcom geni) and grabs port-\u003elock under free_entries_lock spin lock, which is a reverse locking dependency chain as qcom_geni IRQ handler can call into dma-debug code and grab free_entries_lock under port-\u003elock.  Move __dma_entry_alloc_check_leak() call out of free_entries_lock scope so that we don't acquire serial console's port-\u003elock under it.  Trimmed-down lockdep splat:   The existing dependency chain (in reverse order) is:                 -\u003e #2 (free_entries_lock){-.-.}-{2:2}:         _raw_spin_lock_irqsave+0x60/0x80         dma_entry_alloc+0x38/0x110         debug_dma_map_page+0x60/0xf8         dma_map_page_attrs+0x1e0/0x230         dma_map_single_attrs.constprop.0+0x6c/0xc8         geni_se_rx_dma_prep+0x40/0xcc         qcom_geni_serial_isr+0x310/0x510         __handle_irq_event_percpu+0x110/0x244         handle_irq_event_percpu+0x20/0x54         handle_irq_event+0x50/0x88         handle_fasteoi_irq+0xa4/0xcc         handle_irq_desc+0x28/0x40         generic_handle_domain_irq+0x24/0x30         gic_handle_irq+0xc4/0x148         do_interrupt_handler+0xa4/0xb0         el1_interrupt+0x34/0x64         el1h_64_irq_handler+0x18/0x24         el1h_64_irq+0x64/0x68         arch_local_irq_enable+0x4/0x8         ____do_softirq+0x18/0x24         ...                 -\u003e #1 (\u0026port_lock_key){-.-.}-{2:2}:         _raw_spin_lock_irqsave+0x60/0x80         qcom_geni_serial_console_write+0x184/0x1dc         console_flush_all+0x344/0x454         console_unlock+0x94/0xf0         vprintk_emit+0x238/0x24c         vprintk_default+0x3c/0x48         vprintk+0xb4/0xbc         _printk+0x68/0x90         register_console+0x230/0x38c         uart_add_one_port+0x338/0x494         qcom_geni_serial_probe+0x390/0x424         platform_probe+0x70/0xc0         really_probe+0x148/0x280         __driver_probe_device+0xfc/0x114         driver_probe_device+0x44/0x100         __device_attach_driver+0x64/0xdc         bus_for_each_drv+0xb0/0xd8         __device_attach+0xe4/0x140         device_initial_probe+0x1c/0x28         bus_probe_device+0x44/0xb0         device_add+0x538/0x668         of_device_add+0x44/0x50         of_platform_device_create_pdata+0x94/0xc8         of_platform_bus_create+0x270/0x304         of_platform_populate+0xac/0xc4         devm_of_platform_populate+0x60/0xac         geni_se_probe+0x154/0x160         platform_probe+0x70/0xc0         ...                 -\u003e #0 (console_owner){-...}-{0:0}:         __lock_acquire+0xdf8/0x109c         lock_acquire+0x234/0x284         console_flush_all+0x330/0x454         console_unlock+0x94/0xf0         vprintk_emit+0x238/0x24c         vprintk_default+0x3c/0x48         vprintk+0xb4/0xbc         _printk+0x68/0x90         dma_entry_alloc+0xb4/0x110         debug_dma_map_sg+0xdc/0x2f8         __dma_map_sg_attrs+0xac/0xe4         dma_map_sgtable+0x30/0x4c         get_pages+0x1d4/0x1e4 [msm]         msm_gem_pin_pages_locked+0x38/0xac [msm]         msm_gem_pin_vma_locked+0x58/0x88 [msm]         msm_ioctl_gem_submit+0xde4/0x13ac [msm]         drm_ioctl_kernel+0xe0/0x15c         drm_ioctl+0x2e8/0x3f4         vfs_ioctl+0x30/0x50         ...   Chain exists of:    console_owner --\u003e \u0026port_lock_key --\u003e free_entries_lock    Possible unsafe locking scenario:          CPU0                    CPU1         ----                    ----    lock(free_entries_lock);                                 lock(\u0026port_lock_key);                                 lock(free_entries_lock);    lock(console_owner);                  *** DEADLOCK ***   Call trace:   dump_backtrace+0xb4/0xf0   show_stack+0x20/0x30   dump_stack_lvl+0x60/0x84   dump_stack+0x18/0x24   print_circular_bug+0x1cc/0x234   check_noncircular+0x78/0xac   __lock_acquire+0xdf8/0x109c   lock_acquire+0x234/0x284   console_flush_all+0x330/0x454   consol ---truncated---",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52516",
            "severity": "Unknown",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-23196",
            "namespace": "debian:11",
            "description": "A race condition was found in the Linux kernel's sound/hda  device driver in snd_hdac_regmap_sync() function. This can result in a null pointer dereference issue, possibly leading to a kernel panic or denial of service issue.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-23196",
            "severity": "Unknown",
            "fixedby": "5.10.197-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52606",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  powerpc/lib: Validate size for vector operations  Some of the fp/vmx code in sstep.c assume a certain maximum size for the instructions being emulated. The size of those operations however is determined separately in analyse_instr().  Add a check to validate the assumption on the maximum size of the operations, so as to prevent any unintended kernel stack corruption.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52606",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-1074",
            "namespace": "debian:11",
            "description": "A memory leak flaw was found in the Linux kernel's Stream Control Transmission Protocol. This issue may occur when a user starts a malicious networking service and someone connects to this service. This could allow a local user to starve resources, causing a denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1074",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52480",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix race condition between session lookup and expire   Thread A                        +  Thread B  ksmbd_session_lookup            |  smb2_sess_setup    sess = xa_load                |                                  |                                  |    xa_erase(\u0026conn-\u003esessions, sess-\u003eid);                                  |                                  |    ksmbd_session_destroy(sess) --\u003e kfree(sess)                                  |    // UAF!                       |    sess-\u003elast_active = jiffies   |                                  +  This patch add rwsem to fix race condition between ksmbd_session_lookup and ksmbd_expire_session.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52480",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-0266",
            "namespace": "debian:11",
            "description": "A use after free vulnerability exists in the ALSA PCM package in the Linux Kernel. SNDRV_CTL_IOCTL_ELEM_{READ|WRITE}32 is missing locks that can be used in a use-after-free that can result in a priviledge escalation to gain ring0 access from the system user. We recommend upgrading past commit 56b88b50565cd8b946a2d00b0c83927b7ebb055e",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-0266",
            "severity": "Unknown",
            "fixedby": "5.10.162-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-1380",
            "namespace": "debian:11",
            "description": "A slab-out-of-bound read problem was found in brcmf_get_assoc_ies in drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c in the Linux Kernel. This issue could occur when assoc_info-\u003ereq_len data is bigger than the size of the buffer, defined as WL_EXTRA_BUF_MAX, leading to a denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1380",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-1079",
            "namespace": "debian:11",
            "description": "A flaw was found in the Linux kernel. A use-after-free may be triggered in asus_kbd_backlight_set when plugging/disconnecting in a malicious USB device, which advertises itself as an Asus device. Similarly to the previous known CVE-2023-25012, but in asus devices, the work_struct may be scheduled by the LED controller while the device is disconnecting, triggering a use-after-free on the struct asus_kbd_leds *led structure. A malicious USB device may exploit the issue to cause memory corruption with controlled data.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1079",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-31082",
            "namespace": "debian:11",
            "description": "An issue was discovered in drivers/tty/n_gsm.c in the Linux kernel 6.2. There is a sleeping function called from an invalid context in gsmld_write, which will block the kernel.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-31082",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-2162",
            "namespace": "debian:11",
            "description": "A use-after-free vulnerability was found in iscsi_sw_tcp_session_create in drivers/scsi/iscsi_tcp.c in SCSI sub-component in the Linux Kernel. In this flaw an attacker could leak kernel internal information.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-2162",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-4569",
            "namespace": "debian:11",
            "description": "A memory leak flaw was found in nft_set_catchall_flush in net/netfilter/nf_tables_api.c in the Linux Kernel. This issue may allow a local attacker to cause double-deactivations of catchall elements, which can result in a memory leak.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4569",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-45862",
            "namespace": "debian:11",
            "description": "An issue was discovered in drivers/usb/storage/ene_ub6250.c for the ENE UB6250 reader driver in the Linux kernel before 6.2.5. An object could potentially extend beyond the end of an allocation.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-45862",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52527",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  ipv4, ipv6: Fix handling of transhdrlen in __ip{,6}_append_data()  Including the transhdrlen in length is a problem when the packet is partially filled (e.g. something like send(MSG_MORE) happened previously) when appending to an IPv4 or IPv6 packet as we don't want to repeat the transport header or account for it twice.  This can happen under some circumstances, such as splicing into an L2TP socket.  The symptom observed is a warning in __ip6_append_data():      WARNING: CPU: 1 PID: 5042 at net/ipv6/ip6_output.c:1800 __ip6_append_data.isra.0+0x1be8/0x47f0 net/ipv6/ip6_output.c:1800  that occurs when MSG_SPLICE_PAGES is used to append more data to an already partially occupied skbuff.  The warning occurs when 'copy' is larger than the amount of data in the message iterator.  This is because the requested length includes the transport header length when it shouldn't.  This can be triggered by, for example:          sfd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_L2TP);         bind(sfd, ...); // ::1         connect(sfd, ...); // ::1 port 7         send(sfd, buffer, 4100, MSG_MORE);         sendfile(sfd, dfd, NULL, 1024);  Fix this by only adding transhdrlen into the length if the write queue is empty in l2tp_ip6_sendmsg(), analogously to how UDP does things.  l2tp_ip_sendmsg() looks like it won't suffer from this problem as it builds the UDP packet itself.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52527",
            "severity": "Unknown",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52507",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  nfc: nci: assert requested protocol is valid  The protocol is used in a bit mask to determine if the protocol is supported. Assert the provided protocol is less than the maximum defined so it doesn't potentially perform a shift-out-of-bounds and provide a clearer error for undefined protocols vs unsupported ones.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52507",
            "severity": "Unknown",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-23455",
            "namespace": "debian:11",
            "description": "atm_tc_enqueue in net/sched/sch_atm.c in the Linux kernel through 6.1.4 allows attackers to cause a denial of service because of type confusion (non-negative numbers can sometimes indicate a TC_ACT_SHOT condition rather than valid classification results).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-23455",
            "severity": "Unknown",
            "fixedby": "5.10.162-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52615",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  hwrng: core - Fix page fault dead lock on mmap-ed hwrng  There is a dead-lock in the hwrng device read path.  This triggers when the user reads from /dev/hwrng into memory also mmap-ed from /dev/hwrng.  The resulting page fault triggers a recursive read which then dead-locks.  Fix this by using a stack buffer when calling copy_to_user.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52615",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52595",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: rt2x00: restart beacon queue when hardware reset  When a hardware reset is triggered, all registers are reset, so all queues are forced to stop in hardware interface. However, mac80211 will not automatically stop the queue. If we don't manually stop the beacon queue, the queue will be deadlocked and unable to start again. This patch fixes the issue where Apple devices cannot connect to the AP after calling ieee80211_restart_hw().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52595",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-23851",
            "namespace": "debian:11",
            "description": "copy_params in drivers/md/dm-ioctl.c in the Linux kernel through 6.7.1 can attempt to allocate more than INT_MAX bytes, and crash, because of a missing param_kernel-\u003edata_size check. This is related to ctl_ioctl.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-23851",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-3397",
            "namespace": "debian:11",
            "description": "A race condition occurred between the functions lmLogClose and txEnd in JFS, in the Linux Kernel, executed in different threads. This flaw allows a local attacker with normal user privileges to crash the system or leak internal kernel information.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3397",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2021-3669",
            "namespace": "debian:11",
            "description": "A flaw was found in the Linux kernel. Measuring usage of the shared memory does not scale with large shared memory segment counts which could lead to resource exhaustion and DoS.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-3669",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52620",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  netfilter: nf_tables: disallow timeout for anonymous sets  Never used from userspace, disallow these parameters.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52620",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52474",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  IB/hfi1: Fix bugs with non-PAGE_SIZE-end multi-iovec user SDMA requests  hfi1 user SDMA request processing has two bugs that can cause data corruption for user SDMA requests that have multiple payload iovecs where an iovec other than the tail iovec does not run up to the page boundary for the buffer pointed to by that iovec.a  Here are the specific bugs: 1. user_sdma_txadd() does not use struct user_sdma_iovec-\u003eiov.iov_len.    Rather, user_sdma_txadd() will add up to PAGE_SIZE bytes from iovec    to the packet, even if some of those bytes are past    iovec-\u003eiov.iov_len and are thus not intended to be in the packet. 2. user_sdma_txadd() and user_sdma_send_pkts() fail to advance to the    next iovec in user_sdma_request-\u003eiovs when the current iovec    is not PAGE_SIZE and does not contain enough data to complete the    packet. The transmitted packet will contain the wrong data from the    iovec pages.  This has not been an issue with SDMA packets from hfi1 Verbs or PSM2 because they only produce iovecs that end short of PAGE_SIZE as the tail iovec of an SDMA request.  Fixing these bugs exposes other bugs with the SDMA pin cache (struct mmu_rb_handler) that get in way of supporting user SDMA requests with multiple payload iovecs whose buffers do not end at PAGE_SIZE. So this commit fixes those issues as well.  Here are the mmu_rb_handler bugs that non-PAGE_SIZE-end multi-iovec payload user SDMA requests can hit: 1. Overlapping memory ranges in mmu_rb_handler will result in duplicate    pinnings. 2. When extending an existing mmu_rb_handler entry (struct mmu_rb_node),    the mmu_rb code (1) removes the existing entry under a lock, (2)    releases that lock, pins the new pages, (3) then reacquires the lock    to insert the extended mmu_rb_node.     If someone else comes in and inserts an overlapping entry between (2)    and (3), insert in (3) will fail.     The failure path code in this case unpins _all_ pages in either the    original mmu_rb_node or the new mmu_rb_node that was inserted between    (2) and (3). 3. In hfi1_mmu_rb_remove_unless_exact(), mmu_rb_node-\u003erefcount is    incremented outside of mmu_rb_handler-\u003elock. As a result, mmu_rb_node    could be evicted by another thread that gets mmu_rb_handler-\u003elock and    checks mmu_rb_node-\u003erefcount before mmu_rb_node-\u003erefcount is    incremented. 4. Related to #2 above, SDMA request submission failure path does not    check mmu_rb_node-\u003erefcount before freeing mmu_rb_node object.     If there are other SDMA requests in progress whose iovecs have    pointers to the now-freed mmu_rb_node(s), those pointers to the    now-freed mmu_rb nodes will be dereferenced when those SDMA requests    complete.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52474",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-0459",
            "namespace": "debian:11",
            "description": "Copy_from_user on 64-bit versions of the Linux kernel does not implement the __uaccess_begin_nospec allowing a user to bypass the \"access_ok\" check and pass a kernel pointer to copy_from_user(). This would allow an attacker to leak information. We recommend upgrading beyond commit 74e19ef0ff8061ef55957c3abd71614ef0f42f47",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-0459",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-1118",
            "namespace": "debian:11",
            "description": "A flaw use after free in the Linux kernel integrated infrared receiver/transceiver driver was found in the way user detaching rc device. A local user could use this flaw to crash the system or potentially escalate their privileges on the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1118",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-42755",
            "namespace": "debian:11",
            "description": "A flaw was found in the IPv4 Resource Reservation Protocol (RSVP) classifier in the Linux kernel. The xprt pointer may go beyond the linear part of the skb, leading to an out-of-bounds read in the `rsvp_classify` function. This issue may allow a local user to crash the system and cause a denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-42755",
            "severity": "Unknown",
            "fixedby": "5.10.197-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-3268",
            "namespace": "debian:11",
            "description": "An out of bounds (OOB) memory access flaw was found in the Linux kernel in relay_file_read_start_pos in kernel/relay.c in the relayfs. This flaw could allow a local attacker to crash the system or leak kernel internal information.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3268",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-25739",
            "namespace": "debian:11",
            "description": "create_empty_lvol in drivers/mtd/ubi/vtbl.c in the Linux kernel through 6.7.4 can attempt to allocate zero bytes, and crash, because of a missing check for ubi-\u003eleb_size.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-25739",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-6606",
            "namespace": "debian:11",
            "description": "An out-of-bounds read vulnerability was found in smbCalcSize in fs/smb/client/netmisc.c in the Linux Kernel. This issue could allow a local attacker to crash the system or leak internal kernel information.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-6606",
            "severity": "Unknown",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-35827",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 6.3.8. A use-after-free was found in ravb_remove in drivers/net/ethernet/renesas/ravb_main.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-35827",
            "severity": "Unknown",
            "fixedby": "5.10.205-2"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-0458",
            "namespace": "debian:11",
            "description": "A speculative pointer dereference problem exists in the Linux Kernel on the do_prlimit() function. The resource argument value is controlled and is used in pointer arithmetic for the 'rlim' variable and can be used to leak the contents. We recommend upgrading past version 6.1.8 or commit 739790605705ddcf18f21782b9c99ad7d53a8c11",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-0458",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-1206",
            "namespace": "debian:11",
            "description": "A hash collision flaw was found in the IPv6 connection lookup table in the Linux kernel’s IPv6 functionality when a user makes a new kind of SYN flood attack. A user located in the local network or with a high bandwidth connection can increase the CPU usage of the server that accepts IPV6 connections up to 95%.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1206",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52586",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/msm/dpu: Add mutex lock in control vblank irq  Add a mutex lock to control vblank irq to synchronize vblank enable/disable operations happening from different threads to prevent race conditions while registering/unregistering the vblank irq callback.  v4: -Removed vblank_ctl_lock from dpu_encoder_virt, so it is only a     parameter of dpu_encoder_phys.     -Switch from atomic refcnt to a simple int counter as mutex has     now been added v3: Mistakenly did not change wording in last version. It is done now. v2: Slightly changed wording of commit message  Patchwork: https://patchwork.freedesktop.org/patch/571854/",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52586",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-24857",
            "namespace": "debian:11",
            "description": "A race condition was found in the Linux kernel's net/bluetooth device driver in conn_info_{min,max}_age_set() function. This can result in integrity overflow issue, possibly leading to bluetooth connection abnormality or denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-24857",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-51779",
            "namespace": "debian:11",
            "description": "bt_sock_recvmsg in net/bluetooth/af_bluetooth.c in the Linux kernel through 6.6.8 has a use-after-free because of a bt_sock_ioctl race condition.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-51779",
            "severity": "Unknown",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-3776",
            "namespace": "debian:11",
            "description": "A use-after-free vulnerability in the Linux kernel's net/sched: cls_fw component can be exploited to achieve local privilege escalation.  If tcf_change_indev() fails, fw_set_parms() will immediately return an error after incrementing or decrementing the reference counter in tcf_bind_filter(). If an attacker can control the reference counter and set it to zero, they can cause the reference to be freed, leading to a use-after-free vulnerability.  We recommend upgrading past commit 0323bce598eea038714f941ce2b22541c46d488f.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3776",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-39189",
            "namespace": "debian:11",
            "description": "An issue was discovered the x86 KVM subsystem in the Linux kernel before 5.18.17. Unprivileged guest users can compromise the guest kernel because TLB flush operations are mishandled in certain KVM_VCPU_PREEMPTED situations.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-39189",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52589",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  media: rkisp1: Fix IRQ disable race issue  In rkisp1_isp_stop() and rkisp1_csi_disable() the driver masks the interrupts and then apparently assumes that the interrupt handler won't be running, and proceeds in the stop procedure. This is not the case, as the interrupt handler can already be running, which would lead to the ISP being disabled while the interrupt handler handling a captured frame.  This brings up two issues: 1) the ISP could be powered off while the interrupt handler is still running and accessing registers, leading to board lockup, and 2) the interrupt handler code and the code that disables the streaming might do things that conflict.  It is not clear to me if 2) causes a real issue, but 1) can be seen with a suitable delay (or printk in my case) in the interrupt handler, leading to board lockup.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52589",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26625",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  llc: call sock_orphan() at release time  syzbot reported an interesting trace [1] caused by a stale sk-\u003esk_wq pointer in a closed llc socket.  In commit ff7b11aa481f (\"net: socket: set sock-\u003esk to NULL after calling proto_ops::release()\") Eric Biggers hinted that some protocols are missing a sock_orphan(), we need to perform a full audit.  In net-next, I plan to clear sock-\u003esk from sock_orphan() and amend Eric patch to add a warning.  [1]  BUG: KASAN: slab-use-after-free in list_empty include/linux/list.h:373 [inline]  BUG: KASAN: slab-use-after-free in waitqueue_active include/linux/wait.h:127 [inline]  BUG: KASAN: slab-use-after-free in sock_def_write_space_wfree net/core/sock.c:3384 [inline]  BUG: KASAN: slab-use-after-free in sock_wfree+0x9a8/0x9d0 net/core/sock.c:2468 Read of size 8 at addr ffff88802f4fc880 by task ksoftirqd/1/27  CPU: 1 PID: 27 Comm: ksoftirqd/1 Not tainted 6.8.0-rc1-syzkaller-00049-g6098d87eaf31 #0 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.2-debian-1.16.2-1 04/01/2014 Call Trace:  \u003cTASK\u003e   __dump_stack lib/dump_stack.c:88 [inline]   dump_stack_lvl+0xd9/0x1b0 lib/dump_stack.c:106   print_address_description mm/kasan/report.c:377 [inline]   print_report+0xc4/0x620 mm/kasan/report.c:488   kasan_report+0xda/0x110 mm/kasan/report.c:601   list_empty include/linux/list.h:373 [inline]   waitqueue_active include/linux/wait.h:127 [inline]   sock_def_write_space_wfree net/core/sock.c:3384 [inline]   sock_wfree+0x9a8/0x9d0 net/core/sock.c:2468   skb_release_head_state+0xa3/0x2b0 net/core/skbuff.c:1080   skb_release_all net/core/skbuff.c:1092 [inline]   napi_consume_skb+0x119/0x2b0 net/core/skbuff.c:1404   e1000_unmap_and_free_tx_resource+0x144/0x200 drivers/net/ethernet/intel/e1000/e1000_main.c:1970   e1000_clean_tx_irq drivers/net/ethernet/intel/e1000/e1000_main.c:3860 [inline]   e1000_clean+0x4a1/0x26e0 drivers/net/ethernet/intel/e1000/e1000_main.c:3801   __napi_poll.constprop.0+0xb4/0x540 net/core/dev.c:6576   napi_poll net/core/dev.c:6645 [inline]   net_rx_action+0x956/0xe90 net/core/dev.c:6778   __do_softirq+0x21a/0x8de kernel/softirq.c:553   run_ksoftirqd kernel/softirq.c:921 [inline]   run_ksoftirqd+0x31/0x60 kernel/softirq.c:913   smpboot_thread_fn+0x660/0xa10 kernel/smpboot.c:164   kthread+0x2c6/0x3a0 kernel/kthread.c:388   ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:147   ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:242  \u003c/TASK\u003e  Allocated by task 5167:   kasan_save_stack+0x33/0x50 mm/kasan/common.c:47   kasan_save_track+0x14/0x30 mm/kasan/common.c:68   unpoison_slab_object mm/kasan/common.c:314 [inline]   __kasan_slab_alloc+0x81/0x90 mm/kasan/common.c:340   kasan_slab_alloc include/linux/kasan.h:201 [inline]   slab_post_alloc_hook mm/slub.c:3813 [inline]   slab_alloc_node mm/slub.c:3860 [inline]   kmem_cache_alloc_lru+0x142/0x6f0 mm/slub.c:3879   alloc_inode_sb include/linux/fs.h:3019 [inline]   sock_alloc_inode+0x25/0x1c0 net/socket.c:308   alloc_inode+0x5d/0x220 fs/inode.c:260   new_inode_pseudo+0x16/0x80 fs/inode.c:1005   sock_alloc+0x40/0x270 net/socket.c:634   __sock_create+0xbc/0x800 net/socket.c:1535   sock_create net/socket.c:1622 [inline]   __sys_socket_create net/socket.c:1659 [inline]   __sys_socket+0x14c/0x260 net/socket.c:1706   __do_sys_socket net/socket.c:1720 [inline]   __se_sys_socket net/socket.c:1718 [inline]   __x64_sys_socket+0x72/0xb0 net/socket.c:1718   do_syscall_x64 arch/x86/entry/common.c:52 [inline]   do_syscall_64+0xd3/0x250 arch/x86/entry/common.c:83  entry_SYSCALL_64_after_hwframe+0x63/0x6b  Freed by task 0:   kasan_save_stack+0x33/0x50 mm/kasan/common.c:47   kasan_save_track+0x14/0x30 mm/kasan/common.c:68   kasan_save_free_info+0x3f/0x60 mm/kasan/generic.c:640   poison_slab_object mm/kasan/common.c:241 [inline]   __kasan_slab_free+0x121/0x1b0 mm/kasan/common.c:257   kasan_slab_free include/linux/kasan.h:184 [inline]   slab_free_hook mm/slub.c:2121 [inlin ---truncated---",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26625",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52583",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  ceph: fix deadlock or deadcode of misusing dget()  The lock order is incorrect between denty and its parent, we should always make sure that the parent get the lock first.  But since this deadcode is never used and the parent dir will always be set from the callers, let's just remove it.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52583",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-3707",
            "namespace": "debian:11",
            "description": "A double-free memory flaw was found in the Linux kernel. The Intel GVT-g graphics driver triggers VGA card system resource overload, causing a fail in the intel_gvt_dma_map_guest_page function. This issue could allow a local user to crash the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-3707",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-3609",
            "namespace": "debian:11",
            "description": "A use-after-free vulnerability in the Linux kernel's net/sched: cls_u32 component can be exploited to achieve local privilege escalation.  If tcf_change_indev() fails, u32_set_parms() will immediately return an error after incrementing or decrementing the reference counter in tcf_bind_filter(). If an attacker can control the reference counter and set it to zero, they can cause the reference to be freed, leading to a use-after-free vulnerability.  We recommend upgrading past commit 04c55383fa5689357bcdd2c8036725a55ed632bc.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3609",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52612",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  crypto: scomp - fix req-\u003edst buffer overflow  The req-\u003edst buffer size should be checked before copying from the scomp_scratch-\u003edst to avoid req-\u003edst buffer overflow problem.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52612",
            "severity": "Unknown",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-4207",
            "namespace": "debian:11",
            "description": "A use-after-free vulnerability in the Linux kernel's net/sched: cls_fw component can be exploited to achieve local privilege escalation.  When fw_change() is called on an existing filter, the whole tcf_result struct is always copied into the new instance of the filter. This causes a problem when updating a filter bound to a class, as tcf_unbind_filter() is always called on the old instance in the success path, decreasing filter_cnt of the still referenced class and allowing it to be deleted, leading to a use-after-free.  We recommend upgrading past commit 76e42ae831991c828cffa8c37736ebfb831ad5ec.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4207",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52574",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  team: fix null-ptr-deref when team device type is changed  Get a null-ptr-deref bug as follows with reproducer [1].  BUG: kernel NULL pointer dereference, address: 0000000000000228 ... RIP: 0010:vlan_dev_hard_header+0x35/0x140 [8021q] ... Call Trace:  \u003cTASK\u003e  ? __die+0x24/0x70  ? page_fault_oops+0x82/0x150  ? exc_page_fault+0x69/0x150  ? asm_exc_page_fault+0x26/0x30  ? vlan_dev_hard_header+0x35/0x140 [8021q]  ? vlan_dev_hard_header+0x8e/0x140 [8021q]  neigh_connected_output+0xb2/0x100  ip6_finish_output2+0x1cb/0x520  ? nf_hook_slow+0x43/0xc0  ? ip6_mtu+0x46/0x80  ip6_finish_output+0x2a/0xb0  mld_sendpack+0x18f/0x250  mld_ifc_work+0x39/0x160  process_one_work+0x1e6/0x3f0  worker_thread+0x4d/0x2f0  ? __pfx_worker_thread+0x10/0x10  kthread+0xe5/0x120  ? __pfx_kthread+0x10/0x10  ret_from_fork+0x34/0x50  ? __pfx_kthread+0x10/0x10  ret_from_fork_asm+0x1b/0x30  [1] $ teamd -t team0 -d -c '{\"runner\": {\"name\": \"loadbalance\"}}' $ ip link add name t-dummy type dummy $ ip link add link t-dummy name t-dummy.100 type vlan id 100 $ ip link add name t-nlmon type nlmon $ ip link set t-nlmon master team0 $ ip link set t-nlmon nomaster $ ip link set t-dummy up $ ip link set team0 up $ ip link set t-dummy.100 down $ ip link set t-dummy.100 master team0  When enslave a vlan device to team device and team device type is changed from non-ether to ether, header_ops of team device is changed to vlan_header_ops. That is incorrect and will trigger null-ptr-deref for vlan-\u003ereal_dev in vlan_dev_hard_header() because team device is not a vlan device.  Cache eth_header_ops in team_setup(), then assign cached header_ops to header_ops of team net device when its type is changed from non-ether to ether to fix the bug.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52574",
            "severity": "Unknown",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52561",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  arm64: dts: qcom: sdm845-db845c: Mark cont splash memory region as reserved  Adding a reserved memory region for the framebuffer memory (the splash memory region set up by the bootloader).  It fixes a kernel panic (arm-smmu: Unhandled context fault at this particular memory region) reported on DB845c running v5.10.y.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52561",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-33203",
            "namespace": "debian:11",
            "description": "The Linux kernel before 6.2.9 has a race condition and resultant use-after-free in drivers/net/ethernet/qualcomm/emac/emac.c if a physically proximate attacker unplugs an emac based device.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-33203",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-1829",
            "namespace": "debian:11",
            "description": "A use-after-free vulnerability in the Linux Kernel traffic control index filter (tcindex) can be exploited to achieve local privilege escalation. The tcindex_delete function which does not properly deactivate filters in case of a perfect hashes while deleting the underlying structure which can later lead to double freeing the structure. A local attacker user can use this vulnerability to elevate its privileges to root. We recommend upgrading past commit 8c710f75256bb3cf05ac7b1672c82b92c43f3d28.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1829",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-25775",
            "namespace": "debian:11",
            "description": "Improper access control in the Intel(R) Ethernet Controller RDMA driver for linux before version 1.9.30 may allow an unauthenticated user to potentially enable escalation of privilege via network access.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-25775",
            "severity": "Unknown",
            "fixedby": "5.10.205-2"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-3111",
            "namespace": "debian:11",
            "description": "A use after free vulnerability was found in prepare_to_relocate in fs/btrfs/relocation.c in btrfs in the Linux Kernel. This possible flaw can be triggered by calling btrfs_ioctl_balance() before calling btrfs_ioctl_defrag().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3111",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-3212",
            "namespace": "debian:11",
            "description": "A NULL pointer dereference issue was found in the gfs2 file system in the Linux kernel. It occurs on corrupt gfs2 file systems when the evict code tries to reference the journal descriptor structure after it has been freed and set to NULL. A privileged local user could use this flaw to cause a kernel panic.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3212",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52486",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  drm: Don't unref the same fb many times by mistake due to deadlock handling  If we get a deadlock after the fb lookup in drm_mode_page_flip_ioctl() we proceed to unref the fb and then retry the whole thing from the top. But we forget to reset the fb pointer back to NULL, and so if we then get another error during the retry, before the fb lookup, we proceed the unref the same fb again without having gotten another reference. The end result is that the fb will (eventually) end up being freed while it's still in use.  Reset fb to NULL once we've unreffed it to avoid doing it again until we've done another fb lookup.  This turned out to be pretty easy to hit on a DG2 when doing async flips (and CONFIG_DEBUG_WW_MUTEX_SLOWPATH=y). The first symptom I saw that drm_closefb() simply got stuck in a busy loop while walking the framebuffer list. Fortunately I was able to convince it to oops instead, and from there it was easier to track down the culprit.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52486",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52599",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  jfs: fix array-index-out-of-bounds in diNewExt  [Syz report] UBSAN: array-index-out-of-bounds in fs/jfs/jfs_imap.c:2360:2 index -878706688 is out of range for type 'struct iagctl[128]' CPU: 1 PID: 5065 Comm: syz-executor282 Not tainted 6.7.0-rc4-syzkaller-00009-gbee0e7762ad2 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 11/10/2023 Call Trace:  \u003cTASK\u003e  __dump_stack lib/dump_stack.c:88 [inline]  dump_stack_lvl+0x1e7/0x2d0 lib/dump_stack.c:106  ubsan_epilogue lib/ubsan.c:217 [inline]  __ubsan_handle_out_of_bounds+0x11c/0x150 lib/ubsan.c:348  diNewExt+0x3cf3/0x4000 fs/jfs/jfs_imap.c:2360  diAllocExt fs/jfs/jfs_imap.c:1949 [inline]  diAllocAG+0xbe8/0x1e50 fs/jfs/jfs_imap.c:1666  diAlloc+0x1d3/0x1760 fs/jfs/jfs_imap.c:1587  ialloc+0x8f/0x900 fs/jfs/jfs_inode.c:56  jfs_mkdir+0x1c5/0xb90 fs/jfs/namei.c:225  vfs_mkdir+0x2f1/0x4b0 fs/namei.c:4106  do_mkdirat+0x264/0x3a0 fs/namei.c:4129  __do_sys_mkdir fs/namei.c:4149 [inline]  __se_sys_mkdir fs/namei.c:4147 [inline]  __x64_sys_mkdir+0x6e/0x80 fs/namei.c:4147  do_syscall_x64 arch/x86/entry/common.c:51 [inline]  do_syscall_64+0x45/0x110 arch/x86/entry/common.c:82  entry_SYSCALL_64_after_hwframe+0x63/0x6b RIP: 0033:0x7fcb7e6a0b57 Code: ff ff 77 07 31 c0 c3 0f 1f 40 00 48 c7 c2 b8 ff ff ff f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 b8 53 00 00 00 0f 05 \u003c48\u003e 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007ffd83023038 EFLAGS: 00000286 ORIG_RAX: 0000000000000053 RAX: ffffffffffffffda RBX: 00000000ffffffff RCX: 00007fcb7e6a0b57 RDX: 00000000000a1020 RSI: 00000000000001ff RDI: 0000000020000140 RBP: 0000000020000140 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000286 R12: 00007ffd830230d0 R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000  [Analysis] When the agstart is too large, it can cause agno overflow.  [Fix] After obtaining agno, if the value is invalid, exit the subsequent process.   Modified the test from agno \u003e MAXAG to agno \u003e= MAXAG based on linux-next report by kernel test robot (Dan Carpenter).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52599",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-6121",
            "namespace": "debian:11",
            "description": "An out-of-bounds read vulnerability was found in the NVMe-oF/TCP subsystem in the Linux kernel. This issue may allow a remote attacker to send a crafted TCP packet, triggering a heap-based buffer overflow that results in kmalloc data being printed and potentially leaked to the kernel ring buffer (dmesg).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-6121",
            "severity": "Unknown",
            "fixedby": "5.10.205-2"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-7192",
            "namespace": "debian:11",
            "description": "A memory leak problem was found in ctnetlink_create_conntrack in net/netfilter/nf_conntrack_netlink.c in the Linux Kernel. This issue may allow a local attacker with CAP_NET_ADMIN privileges to cause a denial of service (DoS) attack due to a refcount overflow.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-7192",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52511",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  spi: sun6i: reduce DMA RX transfer width to single byte  Through empirical testing it has been determined that sometimes RX SPI transfers with DMA enabled return corrupted data. This is down to single or even multiple bytes lost during DMA transfer from SPI peripheral to memory. It seems the RX FIFO within the SPI peripheral can become confused when performing bus read accesses wider than a single byte to it during an active SPI transfer.  This patch reduces the width of individual DMA read accesses to the RX FIFO to a single byte to mitigate that issue.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52511",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52479",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix uaf in smb20_oplock_break_ack  drop reference after use opinfo.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52479",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-0461",
            "namespace": "debian:11",
            "description": "There is a use-after-free vulnerability in the Linux Kernel which can be exploited to achieve local privilege escalation. To reach the vulnerability kernel configuration flag CONFIG_TLS or CONFIG_XFRM_ESPINTCP has to be configured, but the operation does not require any privilege.  There is a use-after-free bug of icsk_ulp_data of a struct inet_connection_sock.  When CONFIG_TLS is enabled, user can install a tls context (struct tls_context) on a connected tcp socket. The context is not cleared if this socket is disconnected and reused as a listener. If a new socket is created from the listener, the context is inherited and vulnerable.  The setsockopt TCP_ULP operation does not require any privilege.  We recommend upgrading past commit 2c02d41d71f90a5168391b6a5f2954112ba2307c",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-0461",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-31084",
            "namespace": "debian:11",
            "description": "An issue was discovered in drivers/media/dvb-core/dvb_frontend.c in the Linux kernel 6.2. There is a blocking operation when a task is in !TASK_RUNNING. In dvb_frontend_get_event, wait_event_interruptible is called; the condition is dvb_frontend_test_event(fepriv,events). In dvb_frontend_test_event, down(\u0026fepriv-\u003esem) is called. However, wait_event_interruptible would put the process to sleep, and down(\u0026fepriv-\u003esem) may block the process.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-31084",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-51782",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel before 6.6.8. rose_ioctl in net/rose/af_rose.c has a use-after-free because of a rose_accept race condition.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-51782",
            "severity": "Unknown",
            "fixedby": "5.10.205-2"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-43945",
            "namespace": "debian:11",
            "description": "The Linux kernel NFSD implementation prior to versions 5.19.17 and 6.0.2 are vulnerable to buffer overflow. NFSD tracks the number of pages held by each NFSD thread by combining the receive and send buffers of a remote procedure call (RPC) into a single array of pages. A client can force the send buffer to shrink by sending an RPC message over TCP with garbage data added at the end of the message. The RPC message with garbage data is still correctly formed according to the specification and is passed forward to handlers. Vulnerable code in NFSD is not expecting the oversized request and writes beyond the allocated buffer space. CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-43945",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-23454",
            "namespace": "debian:11",
            "description": "cbq_classify in net/sched/sch_cbq.c in the Linux kernel through 6.1.4 allows attackers to cause a denial of service (slab-out-of-bounds read) because of type confusion (non-negative numbers can sometimes indicate a TC_ACT_SHOT condition rather than valid classification results).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-23454",
            "severity": "Unknown",
            "fixedby": "5.10.162-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-41218",
            "namespace": "debian:11",
            "description": "In drivers/media/dvb-core/dmxdev.c in the Linux kernel through 5.19.10, there is a use-after-free caused by refcount races, affecting dvb_demux_open and dvb_dmxdev_release.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-41218",
            "severity": "Unknown",
            "fixedby": "5.10.162-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-2007",
            "namespace": "debian:11",
            "description": "The specific flaw exists within the DPT I2O Controller driver. The issue results from the lack of proper locking when performing operations on an object. An attacker can leverage this in conjunction with other vulnerabilities to escalate privileges and execute arbitrary code in the context of the kernel.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-2007",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26642",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  netfilter: nf_tables: disallow anonymous set with timeout flag  Anonymous sets are never used with timeout from userspace, reject this. Exception to this rule is NFT_SET_EVAL to ensure legacy meters still work.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26642",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-42754",
            "namespace": "debian:11",
            "description": "A NULL pointer dereference flaw was found in the Linux kernel ipv4 stack. The socket buffer (skb) was assumed to be associated with a device before calling __ip_options_compile, which is not always the case if the skb is re-routed by ipvs. This issue may allow a local user with CAP_NET_ADMIN privileges to crash the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-42754",
            "severity": "Unknown",
            "fixedby": "5.10.197-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-3523",
            "namespace": "debian:11",
            "description": "A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is an unknown function of the file mm/memory.c of the component Driver Handler. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211020.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-3523",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2021-46926",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  ALSA: hda: intel-sdw-acpi: harden detection of controller  The existing code currently sets a pointer to an ACPI handle before checking that it's actually a SoundWire controller. This can lead to issues where the graph walk continues and eventually fails, but the pointer was set already.  This patch changes the logic so that the information provided to the caller is set when a controller is found.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-46926",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-3567",
            "namespace": "debian:11",
            "description": "A use-after-free flaw was found in vcs_read in drivers/tty/vt/vc_screen.c in vc_screen in the Linux Kernel. This issue may allow an attacker with local user access to cause a system crash or leak internal kernel information.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3567",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26624",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  af_unix: fix lockdep positive in sk_diag_dump_icons()  syzbot reported a lockdep splat [1].  Blamed commit hinted about the possible lockdep violation, and code used unix_state_lock_nested() in an attempt to silence lockdep.  It is not sufficient, because unix_state_lock_nested() is already used from unix_state_double_lock().  We need to use a separate subclass.  This patch adds a distinct enumeration to make things more explicit.  Also use swap() in unix_state_double_lock() as a clean up.  v2: add a missing inline keyword to unix_state_lock_nested()  [1] WARNING: possible circular locking dependency detected 6.8.0-rc1-syzkaller-00356-g8a696a29c690 #0 Not tainted  syz-executor.1/2542 is trying to acquire lock:  ffff88808b5df9e8 (rlock-AF_UNIX){+.+.}-{2:2}, at: skb_queue_tail+0x36/0x120 net/core/skbuff.c:3863  but task is already holding lock:  ffff88808b5dfe70 (\u0026u-\u003elock/1){+.+.}-{2:2}, at: unix_dgram_sendmsg+0xfc7/0x2200 net/unix/af_unix.c:2089  which lock already depends on the new lock.  the existing dependency chain (in reverse order) is:  -\u003e #1 (\u0026u-\u003elock/1){+.+.}-{2:2}:         lock_acquire+0x1e3/0x530 kernel/locking/lockdep.c:5754         _raw_spin_lock_nested+0x31/0x40 kernel/locking/spinlock.c:378         sk_diag_dump_icons net/unix/diag.c:87 [inline]         sk_diag_fill+0x6ea/0xfe0 net/unix/diag.c:157         sk_diag_dump net/unix/diag.c:196 [inline]         unix_diag_dump+0x3e9/0x630 net/unix/diag.c:220         netlink_dump+0x5c1/0xcd0 net/netlink/af_netlink.c:2264         __netlink_dump_start+0x5d7/0x780 net/netlink/af_netlink.c:2370         netlink_dump_start include/linux/netlink.h:338 [inline]         unix_diag_handler_dump+0x1c3/0x8f0 net/unix/diag.c:319        sock_diag_rcv_msg+0xe3/0x400         netlink_rcv_skb+0x1df/0x430 net/netlink/af_netlink.c:2543         sock_diag_rcv+0x2a/0x40 net/core/sock_diag.c:280         netlink_unicast_kernel net/netlink/af_netlink.c:1341 [inline]         netlink_unicast+0x7e6/0x980 net/netlink/af_netlink.c:1367         netlink_sendmsg+0xa37/0xd70 net/netlink/af_netlink.c:1908         sock_sendmsg_nosec net/socket.c:730 [inline]         __sock_sendmsg net/socket.c:745 [inline]         sock_write_iter+0x39a/0x520 net/socket.c:1160         call_write_iter include/linux/fs.h:2085 [inline]         new_sync_write fs/read_write.c:497 [inline]         vfs_write+0xa74/0xca0 fs/read_write.c:590         ksys_write+0x1a0/0x2c0 fs/read_write.c:643         do_syscall_x64 arch/x86/entry/common.c:52 [inline]         do_syscall_64+0xf5/0x230 arch/x86/entry/common.c:83        entry_SYSCALL_64_after_hwframe+0x63/0x6b  -\u003e #0 (rlock-AF_UNIX){+.+.}-{2:2}:         check_prev_add kernel/locking/lockdep.c:3134 [inline]         check_prevs_add kernel/locking/lockdep.c:3253 [inline]         validate_chain+0x1909/0x5ab0 kernel/locking/lockdep.c:3869         __lock_acquire+0x1345/0x1fd0 kernel/locking/lockdep.c:5137         lock_acquire+0x1e3/0x530 kernel/locking/lockdep.c:5754         __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:110 [inline]         _raw_spin_lock_irqsave+0xd5/0x120 kernel/locking/spinlock.c:162         skb_queue_tail+0x36/0x120 net/core/skbuff.c:3863         unix_dgram_sendmsg+0x15d9/0x2200 net/unix/af_unix.c:2112         sock_sendmsg_nosec net/socket.c:730 [inline]         __sock_sendmsg net/socket.c:745 [inline]         ____sys_sendmsg+0x592/0x890 net/socket.c:2584         ___sys_sendmsg net/socket.c:2638 [inline]         __sys_sendmmsg+0x3b2/0x730 net/socket.c:2724         __do_sys_sendmmsg net/socket.c:2753 [inline]         __se_sys_sendmmsg net/socket.c:2750 [inline]         __x64_sys_sendmmsg+0xa0/0xb0 net/socket.c:2750         do_syscall_x64 arch/x86/entry/common.c:52 [inline]         do_syscall_64+0xf5/0x230 arch/x86/entry/common.c:83        entry_SYSCALL_64_after_hwframe+0x63/0x6b  other info that might help us debug this:   Possible unsafe locking scenario:         CPU0              ---truncated---",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26624",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-51781",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel before 6.6.8. atalk_ioctl in net/appletalk/ddp.c has a use-after-free because of an atalk_recvmsg race condition.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-51781",
            "severity": "Unknown",
            "fixedby": "5.10.205-2"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-45871",
            "namespace": "debian:11",
            "description": "An issue was discovered in drivers/net/ethernet/intel/igb/igb_main.c in the IGB driver in the Linux kernel before 6.5.3. A buffer size may not be adequate for frames larger than the MTU.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-45871",
            "severity": "Unknown",
            "fixedby": "5.10.197-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-23559",
            "namespace": "debian:11",
            "description": "In rndis_query_oid in drivers/net/wireless/rndis_wlan.c in the Linux kernel through 6.1.5, there is an integer overflow in an addition.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-23559",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-2194",
            "namespace": "debian:11",
            "description": "An out-of-bounds write vulnerability was found in the Linux kernel's SLIMpro I2C device driver. The userspace \"data-\u003eblock[0]\" variable was not capped to a number between 0-255 and was used as the size of a memcpy, possibly writing beyond the end of dma_buffer. This flaw could allow a local privileged user to crash the system or potentially achieve code execution.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-2194",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-1077",
            "namespace": "debian:11",
            "description": "In the Linux kernel, pick_next_rt_entity() may return a type confused entry, not detected by the BUG_ON condition, as the confused entry will not be NULL, but list_head.The buggy error condition would lead to a type confused entry with the list head,which would then be used as a type confused sched_rt_entity,causing memory corruption.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1077",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52588",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: fix to tag gcing flag on page during block migration  It needs to add missing gcing flag on page during block migration, in order to garantee migrated data be persisted during checkpoint, otherwise out-of-order persistency between data and node may cause data corruption after SPOR.  Similar issue was fixed by commit 2d1fe8a86bf5 (\"f2fs: fix to tag gcing flag on page during file defragment\").",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52588",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26614",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  tcp: make sure init the accept_queue's spinlocks once  When I run syz's reproduction C program locally, it causes the following issue: pvqspinlock: lock 0xffff9d181cd5c660 has corrupted value 0x0! WARNING: CPU: 19 PID: 21160 at __pv_queued_spin_unlock_slowpath (kernel/locking/qspinlock_paravirt.h:508) Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011 RIP: 0010:__pv_queued_spin_unlock_slowpath (kernel/locking/qspinlock_paravirt.h:508) Code: 73 56 3a ff 90 c3 cc cc cc cc 8b 05 bb 1f 48 01 85 c0 74 05 c3 cc cc cc cc 8b 17 48 89 fe 48 c7 c7 30 20 ce 8f e8 ad 56 42 ff \u003c0f\u003e 0b c3 cc cc cc cc 0f 0b 0f 1f 40 00 90 90 90 90 90 90 90 90 90 RSP: 0018:ffffa8d200604cb8 EFLAGS: 00010282 RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffff9d1ef60e0908 RDX: 00000000ffffffd8 RSI: 0000000000000027 RDI: ffff9d1ef60e0900 RBP: ffff9d181cd5c280 R08: 0000000000000000 R09: 00000000ffff7fff R10: ffffa8d200604b68 R11: ffffffff907dcdc8 R12: 0000000000000000 R13: ffff9d181cd5c660 R14: ffff9d1813a3f330 R15: 0000000000001000 FS:  00007fa110184640(0000) GS:ffff9d1ef60c0000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000020000000 CR3: 000000011f65e000 CR4: 00000000000006f0 Call Trace: \u003cIRQ\u003e   _raw_spin_unlock (kernel/locking/spinlock.c:186)   inet_csk_reqsk_queue_add (net/ipv4/inet_connection_sock.c:1321)   inet_csk_complete_hashdance (net/ipv4/inet_connection_sock.c:1358)   tcp_check_req (net/ipv4/tcp_minisocks.c:868)   tcp_v4_rcv (net/ipv4/tcp_ipv4.c:2260)   ip_protocol_deliver_rcu (net/ipv4/ip_input.c:205)   ip_local_deliver_finish (net/ipv4/ip_input.c:234)   __netif_receive_skb_one_core (net/core/dev.c:5529)   process_backlog (./include/linux/rcupdate.h:779)   __napi_poll (net/core/dev.c:6533)   net_rx_action (net/core/dev.c:6604)   __do_softirq (./arch/x86/include/asm/jump_label.h:27)   do_softirq (kernel/softirq.c:454 kernel/softirq.c:441) \u003c/IRQ\u003e \u003cTASK\u003e   __local_bh_enable_ip (kernel/softirq.c:381)   __dev_queue_xmit (net/core/dev.c:4374)   ip_finish_output2 (./include/net/neighbour.h:540 net/ipv4/ip_output.c:235)   __ip_queue_xmit (net/ipv4/ip_output.c:535)   __tcp_transmit_skb (net/ipv4/tcp_output.c:1462)   tcp_rcv_synsent_state_process (net/ipv4/tcp_input.c:6469)   tcp_rcv_state_process (net/ipv4/tcp_input.c:6657)   tcp_v4_do_rcv (net/ipv4/tcp_ipv4.c:1929)   __release_sock (./include/net/sock.h:1121 net/core/sock.c:2968)   release_sock (net/core/sock.c:3536)   inet_wait_for_connect (net/ipv4/af_inet.c:609)   __inet_stream_connect (net/ipv4/af_inet.c:702)   inet_stream_connect (net/ipv4/af_inet.c:748)   __sys_connect (./include/linux/file.h:45 net/socket.c:2064)   __x64_sys_connect (net/socket.c:2073 net/socket.c:2070 net/socket.c:2070)   do_syscall_64 (arch/x86/entry/common.c:51 arch/x86/entry/common.c:82)   entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:129)   RIP: 0033:0x7fa10ff05a3d   Code: 5b 41 5c c3 66 0f 1f 84 00 00 00 00 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89   c2 4d 89 c8 4c 8b 4c 24 08 0f 05 \u003c48\u003e 3d 01 f0 ff ff 73 01 c3 48 8b 0d ab a3 0e 00 f7 d8 64 89 01 48   RSP: 002b:00007fa110183de8 EFLAGS: 00000202 ORIG_RAX: 000000000000002a   RAX: ffffffffffffffda RBX: 0000000020000054 RCX: 00007fa10ff05a3d   RDX: 000000000000001c RSI: 0000000020000040 RDI: 0000000000000003   RBP: 00007fa110183e20 R08: 0000000000000000 R09: 0000000000000000   R10: 0000000000000000 R11: 0000000000000202 R12: 00007fa110184640   R13: 0000000000000000 R14: 00007fa10fe8b060 R15: 00007fff73e23b20 \u003c/TASK\u003e  The issue triggering process is analyzed as follows: Thread A                                       Thread B tcp_v4_rcv\t//receive ack TCP packet       inet_shutdown   tcp_check_req                                  tcp_disconnect //disconnect sock   ...                                              tcp_set_state(sk, TCP_CLOSE)     inet_csk_complete_hashdance                ...       inet_csk_reqsk_queue_add          ---truncated---",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26614",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-39198",
            "namespace": "debian:11",
            "description": "A race condition was found in the QXL driver in the Linux kernel. The qxl_mode_dumb_create() function dereferences the qobj returned by the qxl_gem_object_create_with_handle(), but the handle is the only one holding a reference to it. This flaw allows an attacker to guess the returned handle value and trigger a use-after-free issue, potentially leading to a denial of service or privilege escalation.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-39198",
            "severity": "Unknown",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-7042",
            "namespace": "debian:11",
            "description": "A null pointer dereference vulnerability was found in ath10k_wmi_tlv_op_pull_mgmt_tx_compl_ev() in drivers/net/wireless/ath/ath10k/wmi-tlv.c in the Linux kernel. This issue could be exploited to trigger a denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-7042",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26633",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  ip6_tunnel: fix NEXTHDR_FRAGMENT handling in ip6_tnl_parse_tlv_enc_lim()  syzbot pointed out [1] that NEXTHDR_FRAGMENT handling is broken.  Reading frag_off can only be done if we pulled enough bytes to skb-\u003ehead. Currently we might access garbage.  [1] BUG: KMSAN: uninit-value in ip6_tnl_parse_tlv_enc_lim+0x94f/0xbb0 ip6_tnl_parse_tlv_enc_lim+0x94f/0xbb0 ipxip6_tnl_xmit net/ipv6/ip6_tunnel.c:1326 [inline] ip6_tnl_start_xmit+0xab2/0x1a70 net/ipv6/ip6_tunnel.c:1432 __netdev_start_xmit include/linux/netdevice.h:4940 [inline] netdev_start_xmit include/linux/netdevice.h:4954 [inline] xmit_one net/core/dev.c:3548 [inline] dev_hard_start_xmit+0x247/0xa10 net/core/dev.c:3564 __dev_queue_xmit+0x33b8/0x5130 net/core/dev.c:4349 dev_queue_xmit include/linux/netdevice.h:3134 [inline] neigh_connected_output+0x569/0x660 net/core/neighbour.c:1592 neigh_output include/net/neighbour.h:542 [inline] ip6_finish_output2+0x23a9/0x2b30 net/ipv6/ip6_output.c:137 ip6_finish_output+0x855/0x12b0 net/ipv6/ip6_output.c:222 NF_HOOK_COND include/linux/netfilter.h:303 [inline] ip6_output+0x323/0x610 net/ipv6/ip6_output.c:243 dst_output include/net/dst.h:451 [inline] ip6_local_out+0xe9/0x140 net/ipv6/output_core.c:155 ip6_send_skb net/ipv6/ip6_output.c:1952 [inline] ip6_push_pending_frames+0x1f9/0x560 net/ipv6/ip6_output.c:1972 rawv6_push_pending_frames+0xbe8/0xdf0 net/ipv6/raw.c:582 rawv6_sendmsg+0x2b66/0x2e70 net/ipv6/raw.c:920 inet_sendmsg+0x105/0x190 net/ipv4/af_inet.c:847 sock_sendmsg_nosec net/socket.c:730 [inline] __sock_sendmsg net/socket.c:745 [inline] ____sys_sendmsg+0x9c2/0xd60 net/socket.c:2584 ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2638 __sys_sendmsg net/socket.c:2667 [inline] __do_sys_sendmsg net/socket.c:2676 [inline] __se_sys_sendmsg net/socket.c:2674 [inline] __x64_sys_sendmsg+0x307/0x490 net/socket.c:2674 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0x44/0x110 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x63/0x6b  Uninit was created at: slab_post_alloc_hook+0x129/0xa70 mm/slab.h:768 slab_alloc_node mm/slub.c:3478 [inline] __kmem_cache_alloc_node+0x5c9/0x970 mm/slub.c:3517 __do_kmalloc_node mm/slab_common.c:1006 [inline] __kmalloc_node_track_caller+0x118/0x3c0 mm/slab_common.c:1027 kmalloc_reserve+0x249/0x4a0 net/core/skbuff.c:582 pskb_expand_head+0x226/0x1a00 net/core/skbuff.c:2098 __pskb_pull_tail+0x13b/0x2310 net/core/skbuff.c:2655 pskb_may_pull_reason include/linux/skbuff.h:2673 [inline] pskb_may_pull include/linux/skbuff.h:2681 [inline] ip6_tnl_parse_tlv_enc_lim+0x901/0xbb0 net/ipv6/ip6_tunnel.c:408 ipxip6_tnl_xmit net/ipv6/ip6_tunnel.c:1326 [inline] ip6_tnl_start_xmit+0xab2/0x1a70 net/ipv6/ip6_tunnel.c:1432 __netdev_start_xmit include/linux/netdevice.h:4940 [inline] netdev_start_xmit include/linux/netdevice.h:4954 [inline] xmit_one net/core/dev.c:3548 [inline] dev_hard_start_xmit+0x247/0xa10 net/core/dev.c:3564 __dev_queue_xmit+0x33b8/0x5130 net/core/dev.c:4349 dev_queue_xmit include/linux/netdevice.h:3134 [inline] neigh_connected_output+0x569/0x660 net/core/neighbour.c:1592 neigh_output include/net/neighbour.h:542 [inline] ip6_finish_output2+0x23a9/0x2b30 net/ipv6/ip6_output.c:137 ip6_finish_output+0x855/0x12b0 net/ipv6/ip6_output.c:222 NF_HOOK_COND include/linux/netfilter.h:303 [inline] ip6_output+0x323/0x610 net/ipv6/ip6_output.c:243 dst_output include/net/dst.h:451 [inline] ip6_local_out+0xe9/0x140 net/ipv6/output_core.c:155 ip6_send_skb net/ipv6/ip6_output.c:1952 [inline] ip6_push_pending_frames+0x1f9/0x560 net/ipv6/ip6_output.c:1972 rawv6_push_pending_frames+0xbe8/0xdf0 net/ipv6/raw.c:582 rawv6_sendmsg+0x2b66/0x2e70 net/ipv6/raw.c:920 inet_sendmsg+0x105/0x190 net/ipv4/af_inet.c:847 sock_sendmsg_nosec net/socket.c:730 [inline] __sock_sendmsg net/socket.c:745 [inline] ____sys_sendmsg+0x9c2/0xd60 net/socket.c:2584 ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2638 __sys_sendmsg net/socket.c:2667 [inline] __do_sys_sendms ---truncated---",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26633",
            "severity": "Unknown",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-4921",
            "namespace": "debian:11",
            "description": "A use-after-free vulnerability in the Linux kernel's net/sched: sch_qfq component can be exploited to achieve local privilege escalation.  When the plug qdisc is used as a class of the qfq qdisc, sending network packets triggers use-after-free in qfq_dequeue() due to the incorrect .peek handler of sch_plug and lack of error checking in agg_dequeue().  We recommend upgrading past commit 8fc134fee27f2263988ae38920bc03da416b03d8.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4921",
            "severity": "Unknown",
            "fixedby": "5.10.197-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52587",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  IB/ipoib: Fix mcast list locking  Releasing the `priv-\u003elock` while iterating the `priv-\u003emulticast_list` in `ipoib_mcast_join_task()` opens a window for `ipoib_mcast_dev_flush()` to remove the items while in the middle of iteration. If the mcast is removed while the lock was dropped, the for loop spins forever resulting in a hard lockup (as was reported on RHEL 4.18.0-372.75.1.el8_6 kernel):      Task A (kworker/u72:2 below)       | Task B (kworker/u72:0 below)     -----------------------------------+-----------------------------------     ipoib_mcast_join_task(work)        | ipoib_ib_dev_flush_light(work)       spin_lock_irq(\u0026priv-\u003elock)       | __ipoib_ib_dev_flush(priv, ...)       list_for_each_entry(mcast,       | ipoib_mcast_dev_flush(dev = priv-\u003edev)           \u0026priv-\u003emulticast_list, list) |         ipoib_mcast_join(dev, mcast)   |           spin_unlock_irq(\u0026priv-\u003elock) |                                        |   spin_lock_irqsave(\u0026priv-\u003elock, flags)                                        |   list_for_each_entry_safe(mcast, tmcast,                                        |                  \u0026priv-\u003emulticast_list, list)                                        |     list_del(\u0026mcast-\u003elist);                                        |     list_add_tail(\u0026mcast-\u003elist, \u0026remove_list)                                        |   spin_unlock_irqrestore(\u0026priv-\u003elock, flags)           spin_lock_irq(\u0026priv-\u003elock)   |                                        |   ipoib_mcast_remove_list(\u0026remove_list)    (Here, `mcast` is no longer on the  |     list_for_each_entry_safe(mcast, tmcast,     `priv-\u003emulticast_list` and we keep |                            remove_list, list)     spinning on the `remove_list` of   |  \u003e\u003e\u003e  wait_for_completion(\u0026mcast-\u003edone)     the other thread which is blocked  |     and the list is still valid on     |     it's stack.)  Fix this by keeping the lock held and changing to GFP_ATOMIC to prevent eventual sleeps. Unfortunately we could not reproduce the lockup and confirm this fix but based on the code review I think this fix should address such lockups.  crash\u003e bc 31 PID: 747      TASK: ff1c6a1a007e8000  CPU: 31   COMMAND: \"kworker/u72:2\" --     [exception RIP: ipoib_mcast_join_task+0x1b1]     RIP: ffffffffc0944ac1  RSP: ff646f199a8c7e00  RFLAGS: 00000002     RAX: 0000000000000000  RBX: ff1c6a1a04dc82f8  RCX: 0000000000000000                                   work (\u0026priv-\u003emcast_task{,.work})     RDX: ff1c6a192d60ac68  RSI: 0000000000000286  RDI: ff1c6a1a04dc8000            \u0026mcast-\u003elist     RBP: ff646f199a8c7e90   R8: ff1c699980019420   R9: ff1c6a1920c9a000     R10: ff646f199a8c7e00  R11: ff1c6a191a7d9800  R12: ff1c6a192d60ac00                                                          mcast     R13: ff1c6a1d82200000  R14: ff1c6a1a04dc8000  R15: ff1c6a1a04dc82d8            dev                    priv (\u0026priv-\u003elock)     \u0026priv-\u003emulticast_list (aka head)     ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018 --- \u003cNMI exception stack\u003e ---  #5 [ff646f199a8c7e00] ipoib_mcast_join_task+0x1b1 at ffffffffc0944ac1 [ib_ipoib]  #6 [ff646f199a8c7e98] process_one_work+0x1a7 at ffffffff9bf10967  crash\u003e rx ff646f199a8c7e68 ff646f199a8c7e68:  ff1c6a1a04dc82f8 \u003c\u003c\u003c work = \u0026priv-\u003emcast_task.work  crash\u003e list -hO ipoib_dev_priv.multicast_list ff1c6a1a04dc8000 (empty)  crash\u003e ipoib_dev_priv.mcast_task.work.func,mcast_mutex.owner.counter ff1c6a1a04dc8000   mcast_task.work.func = 0xffffffffc0944910 \u003cipoib_mcast_join_task\u003e,   mcast_mutex.owner.counter = 0xff1c69998efec000  crash\u003e b 8 PID: 8        TASK: ff1c69998efec000  CPU: 33   COMMAND: \"kworker/u72:0\" --  #3 [ff646f1980153d50] wait_for_completion+0x96 at ffffffff9c7d7646  #4 [ff646f1980153d90] ipoib_mcast_remove_list+0x56 at ffffffffc0944dc6 [ib_ipoib]  #5 [ff646f1980153de8] ipoib_mcast_dev_flush+0x1a7 at ffffffffc09455a7 [ib_ipoib]  #6 [ff646f1980153e58] __ipoib_ib_dev_flush+0x1a4 at ffffffffc09431a4 [ib_ipoib]  #7 [ff ---truncated---",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52587",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-0597",
            "namespace": "debian:11",
            "description": "A flaw possibility of memory leak in the Linux kernel cpu_entry_area mapping of X86 CPU data to memory was found in the way user can guess location of exception stack(s) or other important data. A local user could use this flaw to get access to some important data with expected location in memory.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-0597",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-37453",
            "namespace": "debian:11",
            "description": "An issue was discovered in the USB subsystem in the Linux kernel through 6.4.2. There is an out-of-bounds and crash in read_descriptors in drivers/usb/core/sysfs.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-37453",
            "severity": "Unknown",
            "fixedby": "5.10.197-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52597",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  KVM: s390: fix setting of fpc register  kvm_arch_vcpu_ioctl_set_fpu() allows to set the floating point control (fpc) register of a guest cpu. The new value is tested for validity by temporarily loading it into the fpc register.  This may lead to corruption of the fpc register of the host process: if an interrupt happens while the value is temporarily loaded into the fpc register, and within interrupt context floating point or vector registers are used, the current fp/vx registers are saved with save_fpu_regs() assuming they belong to user space and will be loaded into fp/vx registers when returning to user space.  test_fp_ctl() restores the original user space / host process fpc register value, however it will be discarded, when returning to user space.  In result the host process will incorrectly continue to run with the value that was supposed to be used for a guest cpu.  Fix this by simply removing the test. There is another test right before the SIE context is entered which will handles invalid values.  This results in a change of behaviour: invalid values will now be accepted instead of that the ioctl fails with -EINVAL. This seems to be acceptable, given that this interface is most likely not used anymore, and this is in addition the same behaviour implemented with the memory mapped interface (replace invalid values with zero) - see sync_regs() in kvm-s390.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52597",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52436",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: explicitly null-terminate the xattr list  When setting an xattr, explicitly null-terminate the xattr list.  This eliminates the fragile assumption that the unused xattr space is always zeroed.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52436",
            "severity": "Unknown",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-22099",
            "namespace": "debian:11",
            "description": "NULL Pointer Dereference vulnerability in Linux Linux kernel kernel on Linux, x86, ARM (net, bluetooth modules) allows Overflow Buffers. This vulnerability is associated with program files /net/bluetooth/rfcomm/core.C.  This issue affects Linux kernel: v2.6.12-rc2.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-22099",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-0394",
            "namespace": "debian:11",
            "description": "A NULL pointer dereference flaw was found in rawv6_push_pending_frames in net/ipv6/raw.c in the network subcomponent in the Linux kernel. This flaw causes the system to crash.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-0394",
            "severity": "Unknown",
            "fixedby": "5.10.162-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52567",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  serial: 8250_port: Check IRQ data before use  In case the leaf driver wants to use IRQ polling (irq = 0) and IIR register shows that an interrupt happened in the 8250 hardware the IRQ data can be NULL. In such a case we need to skip the wake event as we came to this path from the timer interrupt and quite likely system is already awake.  Without this fix we have got an Oops:      serial8250: ttyS0 at I/O 0x3f8 (irq = 0, base_baud = 115200) is a 16550A     ...     BUG: kernel NULL pointer dereference, address: 0000000000000010     RIP: 0010:serial8250_handle_irq+0x7c/0x240     Call Trace:      ? serial8250_handle_irq+0x7c/0x240      ? __pfx_serial8250_timeout+0x10/0x10",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52567",
            "severity": "Unknown",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-3090",
            "namespace": "debian:11",
            "description": "A heap out-of-bounds write vulnerability in the Linux Kernel ipvlan network driver can be exploited to achieve local privilege escalation.  The out-of-bounds write is caused by missing skb-\u003ecb  initialization in the ipvlan network driver. The vulnerability is reachable if CONFIG_IPVLAN is enabled.   We recommend upgrading past commit 90cbed5247439a966b645b34eb0a2e037836ea8e.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3090",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26635",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  llc: Drop support for ETH_P_TR_802_2.  syzbot reported an uninit-value bug below. [0]  llc supports ETH_P_802_2 (0x0004) and used to support ETH_P_TR_802_2 (0x0011), and syzbot abused the latter to trigger the bug.    write$tun(r0, \u0026(0x7f0000000040)={@val={0x0, 0x11}, @val, @mpls={[], @llc={@snap={0xaa, 0x1, ')', \"90e5dd\"}}}}, 0x16)  llc_conn_handler() initialises local variables {saddr,daddr}.mac based on skb in llc_pdu_decode_sa()/llc_pdu_decode_da() and passes them to __llc_lookup().  However, the initialisation is done only when skb-\u003eprotocol is htons(ETH_P_802_2), otherwise, __llc_lookup_established() and __llc_lookup_listener() will read garbage.  The missing initialisation existed prior to commit 211ed865108e (\"net: delete all instances of special processing for token ring\").  It removed the part to kick out the token ring stuff but forgot to close the door allowing ETH_P_TR_802_2 packets to sneak into llc_rcv().  Let's remove llc_tr_packet_type and complete the deprecation.  [0]: BUG: KMSAN: uninit-value in __llc_lookup_established+0xe9d/0xf90  __llc_lookup_established+0xe9d/0xf90  __llc_lookup net/llc/llc_conn.c:611 [inline]  llc_conn_handler+0x4bd/0x1360 net/llc/llc_conn.c:791  llc_rcv+0xfbb/0x14a0 net/llc/llc_input.c:206  __netif_receive_skb_one_core net/core/dev.c:5527 [inline]  __netif_receive_skb+0x1a6/0x5a0 net/core/dev.c:5641  netif_receive_skb_internal net/core/dev.c:5727 [inline]  netif_receive_skb+0x58/0x660 net/core/dev.c:5786  tun_rx_batched+0x3ee/0x980 drivers/net/tun.c:1555  tun_get_user+0x53af/0x66d0 drivers/net/tun.c:2002  tun_chr_write_iter+0x3af/0x5d0 drivers/net/tun.c:2048  call_write_iter include/linux/fs.h:2020 [inline]  new_sync_write fs/read_write.c:491 [inline]  vfs_write+0x8ef/0x1490 fs/read_write.c:584  ksys_write+0x20f/0x4c0 fs/read_write.c:637  __do_sys_write fs/read_write.c:649 [inline]  __se_sys_write fs/read_write.c:646 [inline]  __x64_sys_write+0x93/0xd0 fs/read_write.c:646  do_syscall_x64 arch/x86/entry/common.c:51 [inline]  do_syscall_64+0x44/0x110 arch/x86/entry/common.c:82  entry_SYSCALL_64_after_hwframe+0x63/0x6b  Local variable daddr created at:  llc_conn_handler+0x53/0x1360 net/llc/llc_conn.c:783  llc_rcv+0xfbb/0x14a0 net/llc/llc_input.c:206  CPU: 1 PID: 5004 Comm: syz-executor994 Not tainted 6.6.0-syzkaller-14500-g1c41041124bd #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/09/2023",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26635",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26651",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  sr9800: Add check for usbnet_get_endpoints  Add check for usbnet_get_endpoints() and return the error if it fails in order to transfer the error.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26651",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52515",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  RDMA/srp: Do not call scsi_done() from srp_abort()  After scmd_eh_abort_handler() has called the SCSI LLD eh_abort_handler callback, it performs one of the following actions: * Call scsi_queue_insert(). * Call scsi_finish_command(). * Call scsi_eh_scmd_add(). Hence, SCSI abort handlers must not call scsi_done(). Otherwise all the above actions would trigger a use-after-free. Hence remove the scsi_done() call from srp_abort(). Keep the srp_free_req() call before returning SUCCESS because we may not see the command again if SUCCESS is returned.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52515",
            "severity": "Unknown",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26644",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: don't abort filesystem when attempting to snapshot deleted subvolume  If the source file descriptor to the snapshot ioctl refers to a deleted subvolume, we get the following abort:    BTRFS: Transaction aborted (error -2)   WARNING: CPU: 0 PID: 833 at fs/btrfs/transaction.c:1875 create_pending_snapshot+0x1040/0x1190 [btrfs]   Modules linked in: pata_acpi btrfs ata_piix libata scsi_mod virtio_net blake2b_generic xor net_failover virtio_rng failover scsi_common rng_core raid6_pq libcrc32c   CPU: 0 PID: 833 Comm: t_snapshot_dele Not tainted 6.7.0-rc6 #2   Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-1.fc39 04/01/2014   RIP: 0010:create_pending_snapshot+0x1040/0x1190 [btrfs]   RSP: 0018:ffffa09c01337af8 EFLAGS: 00010282   RAX: 0000000000000000 RBX: ffff9982053e7c78 RCX: 0000000000000027   RDX: ffff99827dc20848 RSI: 0000000000000001 RDI: ffff99827dc20840   RBP: ffffa09c01337c00 R08: 0000000000000000 R09: ffffa09c01337998   R10: 0000000000000003 R11: ffffffffb96da248 R12: fffffffffffffffe   R13: ffff99820535bb28 R14: ffff99820b7bd000 R15: ffff99820381ea80   FS:  00007fe20aadabc0(0000) GS:ffff99827dc00000(0000) knlGS:0000000000000000   CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033   CR2: 0000559a120b502f CR3: 00000000055b6000 CR4: 00000000000006f0   Call Trace:    \u003cTASK\u003e    ? create_pending_snapshot+0x1040/0x1190 [btrfs]    ? __warn+0x81/0x130    ? create_pending_snapshot+0x1040/0x1190 [btrfs]    ? report_bug+0x171/0x1a0    ? handle_bug+0x3a/0x70    ? exc_invalid_op+0x17/0x70    ? asm_exc_invalid_op+0x1a/0x20    ? create_pending_snapshot+0x1040/0x1190 [btrfs]    ? create_pending_snapshot+0x1040/0x1190 [btrfs]    create_pending_snapshots+0x92/0xc0 [btrfs]    btrfs_commit_transaction+0x66b/0xf40 [btrfs]    btrfs_mksubvol+0x301/0x4d0 [btrfs]    btrfs_mksnapshot+0x80/0xb0 [btrfs]    __btrfs_ioctl_snap_create+0x1c2/0x1d0 [btrfs]    btrfs_ioctl_snap_create_v2+0xc4/0x150 [btrfs]    btrfs_ioctl+0x8a6/0x2650 [btrfs]    ? kmem_cache_free+0x22/0x340    ? do_sys_openat2+0x97/0xe0    __x64_sys_ioctl+0x97/0xd0    do_syscall_64+0x46/0xf0    entry_SYSCALL_64_after_hwframe+0x6e/0x76   RIP: 0033:0x7fe20abe83af   RSP: 002b:00007ffe6eff1360 EFLAGS: 00000246 ORIG_RAX: 0000000000000010   RAX: ffffffffffffffda RBX: 0000000000000004 RCX: 00007fe20abe83af   RDX: 00007ffe6eff23c0 RSI: 0000000050009417 RDI: 0000000000000003   RBP: 0000000000000003 R08: 0000000000000000 R09: 00007fe20ad16cd0   R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000   R13: 00007ffe6eff13c0 R14: 00007fe20ad45000 R15: 0000559a120b6d58    \u003c/TASK\u003e   ---[ end trace 0000000000000000 ]---   BTRFS: error (device vdc: state A) in create_pending_snapshot:1875: errno=-2 No such entry   BTRFS info (device vdc: state EA): forced readonly   BTRFS warning (device vdc: state EA): Skipping commit of aborted transaction.   BTRFS: error (device vdc: state EA) in cleanup_transaction:2055: errno=-2 No such entry  This happens because create_pending_snapshot() initializes the new root item as a copy of the source root item. This includes the refs field, which is 0 for a deleted subvolume. The call to btrfs_insert_root() therefore inserts a root with refs == 0. btrfs_get_new_fs_root() then finds the root and returns -ENOENT if refs == 0, which causes create_pending_snapshot() to abort.  Fix it by checking the source root's refs before attempting the snapshot, but after locking subvol_sem to avoid racing with deletion.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26644",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52622",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  ext4: avoid online resizing failures due to oversized flex bg  When we online resize an ext4 filesystem with a oversized flexbg_size,       mkfs.ext4 -F -G 67108864 $dev -b 4096 100M      mount $dev $dir      resize2fs $dev 16G  the following WARN_ON is triggered: ================================================================== WARNING: CPU: 0 PID: 427 at mm/page_alloc.c:4402 __alloc_pages+0x411/0x550 Modules linked in: sg(E) CPU: 0 PID: 427 Comm: resize2fs Tainted: G  E  6.6.0-rc5+ #314 RIP: 0010:__alloc_pages+0x411/0x550 Call Trace:  \u003cTASK\u003e  __kmalloc_large_node+0xa2/0x200  __kmalloc+0x16e/0x290  ext4_resize_fs+0x481/0xd80  __ext4_ioctl+0x1616/0x1d90  ext4_ioctl+0x12/0x20  __x64_sys_ioctl+0xf0/0x150  do_syscall_64+0x3b/0x90 ==================================================================  This is because flexbg_size is too large and the size of the new_group_data array to be allocated exceeds MAX_ORDER. Currently, the minimum value of MAX_ORDER is 8, the minimum value of PAGE_SIZE is 4096, the corresponding maximum number of groups that can be allocated is:   (PAGE_SIZE \u003c\u003c MAX_ORDER) / sizeof(struct ext4_new_group_data) ≈ 21845  And the value that is down-aligned to the power of 2 is 16384. Therefore, this value is defined as MAX_RESIZE_BG, and the number of groups added each time does not exceed this value during resizing, and is added multiple times to complete the online resizing. The difference is that the metadata in a flex_bg may be more dispersed.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52622",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52621",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Check rcu_read_lock_trace_held() before calling bpf map helpers  These three bpf_map_{lookup,update,delete}_elem() helpers are also available for sleepable bpf program, so add the corresponding lock assertion for sleepable bpf program, otherwise the following warning will be reported when a sleepable bpf program manipulates bpf map under interpreter mode (aka bpf_jit_enable=0):    WARNING: CPU: 3 PID: 4985 at kernel/bpf/helpers.c:40 ......   CPU: 3 PID: 4985 Comm: test_progs Not tainted 6.6.0+ #2   Hardware name: QEMU Standard PC (i440FX + PIIX, 1996) ......   RIP: 0010:bpf_map_lookup_elem+0x54/0x60   ......   Call Trace:    \u003cTASK\u003e    ? __warn+0xa5/0x240    ? bpf_map_lookup_elem+0x54/0x60    ? report_bug+0x1ba/0x1f0    ? handle_bug+0x40/0x80    ? exc_invalid_op+0x18/0x50    ? asm_exc_invalid_op+0x1b/0x20    ? __pfx_bpf_map_lookup_elem+0x10/0x10    ? rcu_lockdep_current_cpu_online+0x65/0xb0    ? rcu_is_watching+0x23/0x50    ? bpf_map_lookup_elem+0x54/0x60    ? __pfx_bpf_map_lookup_elem+0x10/0x10    ___bpf_prog_run+0x513/0x3b70    __bpf_prog_run32+0x9d/0xd0    ? __bpf_prog_enter_sleepable_recur+0xad/0x120    ? __bpf_prog_enter_sleepable_recur+0x3e/0x120    bpf_trampoline_6442580665+0x4d/0x1000    __x64_sys_getpgid+0x5/0x30    ? do_syscall_64+0x36/0xb0    entry_SYSCALL_64_after_hwframe+0x6e/0x76    \u003c/TASK\u003e",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52621",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26647",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Fix late derefrence 'dsc' check in 'link_set_dsc_pps_packet()'  In link_set_dsc_pps_packet(), 'struct display_stream_compressor *dsc' was dereferenced in a DC_LOGGER_INIT(dsc-\u003ectx-\u003elogger); before the 'dsc' NULL pointer check.  Fixes the below: drivers/gpu/drm/amd/amdgpu/../display/dc/link/link_dpms.c:905 link_set_dsc_pps_packet() warn: variable dereferenced before check 'dsc' (see line 903)",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26647",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52625",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Refactor DMCUB enter/exit idle interface  [Why] We can hang in place trying to send commands when the DMCUB isn't powered on.  [How] We need to exit out of the idle state prior to sending a command, but the process that performs the exit also invokes a command itself.  Fixing this issue involves the following:  1. Using a software state to track whether or not we need to start    the process to exit idle or notify idle.  It's possible for the hardware to have exited an idle state without driver knowledge, but entering one is always restricted to a driver allow - which makes the SW state vs HW state mismatch issue purely one of optimization, which should seldomly be hit, if at all.  2. Refactor any instances of exit/notify idle to use a single wrapper    that maintains this SW state.  This works simialr to dc_allow_idle_optimizations, but works at the DMCUB level and makes sure the state is marked prior to any notify/exit idle so we don't enter an infinite loop.  3. Make sure we exit out of idle prior to sending any commands or    waiting for DMCUB idle.  This patch takes care of 1/2. A future patch will take care of wrapping DMCUB command submission with calls to this new interface.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52625",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52628",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  netfilter: nftables: exthdr: fix 4-byte stack OOB write  If priv-\u003elen is a multiple of 4, then dst[len / 4] can write past the destination array which leads to stack corruption.  This construct is necessary to clean the remainder of the register in case -\u003elen is NOT a multiple of the register size, so make it conditional just like nft_payload.c does.  The bug was added in 4.1 cycle and then copied/inherited when tcp/sctp and ip option support was added.  Bug reported by Zero Day Initiative project (ZDI-CAN-21950, ZDI-CAN-21951, ZDI-CAN-21961).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52628",
            "severity": "Unknown",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-3611",
            "namespace": "debian:11",
            "description": "An out-of-bounds write vulnerability in the Linux kernel's net/sched: sch_qfq component can be exploited to achieve local privilege escalation.  The qfq_change_agg() function in net/sched/sch_qfq.c allows an out-of-bounds write because lmax is updated according to packet sizes without bounds checks.  We recommend upgrading past commit 3e337087c3b5805fe0b8a46ba622a962880b5d64.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3611",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-6240",
            "namespace": "debian:11",
            "description": "A Marvin vulnerability side-channel leakage was found in the RSA decryption operation in the Linux Kernel. This issue may allow a network attacker to decrypt ciphertexts or forge signatures, limiting the services that use that private key.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-6240",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52624",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Wake DMCUB before executing GPINT commands  [Why] DMCUB can be in idle when we attempt to interface with the HW through the GPINT mailbox resulting in a system hang.  [How] Add dc_wake_and_execute_gpint() to wrap the wake, execute, sleep sequence.  If the GPINT executes successfully then DMCUB will be put back into sleep after the optional response is returned.  It functions similar to the inbox command interface.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52624",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26648",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Fix variable deferencing before NULL check in edp_setup_replay()  In edp_setup_replay(), 'struct dc *dc' \u0026 'struct dmub_replay *replay' was dereferenced before the pointer 'link' \u0026 'replay' NULL check.  Fixes the below: drivers/gpu/drm/amd/amdgpu/../display/dc/link/protocols/link_edp_panel_control.c:947 edp_setup_replay() warn: variable dereferenced before check 'link' (see line 933)",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26648",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26646",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  thermal: intel: hfi: Add syscore callbacks for system-wide PM  The kernel allocates a memory buffer and provides its location to the hardware, which uses it to update the HFI table. This allocation occurs during boot and remains constant throughout runtime.  When resuming from hibernation, the restore kernel allocates a second memory buffer and reprograms the HFI hardware with the new location as part of a normal boot. The location of the second memory buffer may differ from the one allocated by the image kernel.  When the restore kernel transfers control to the image kernel, its HFI buffer becomes invalid, potentially leading to memory corruption if the hardware writes to it (the hardware continues to use the buffer from the restore kernel).  It is also possible that the hardware \"forgets\" the address of the memory buffer when resuming from \"deep\" suspend. Memory corruption may also occur in such a scenario.  To prevent the described memory corruption, disable HFI when preparing to suspend or hibernate. Enable it when resuming.  Add syscore callbacks to handle the package of the boot CPU (packages of non-boot CPUs are handled via CPU offline). Syscore ops always run on the boot CPU. Additionally, HFI only needs to be disabled during \"deep\" suspend and hibernation. Syscore ops only run in these cases.  [ rjw: Comment adjustment, subject and changelog edits ]",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26646",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52623",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  SUNRPC: Fix a suspicious RCU usage warning  I received the following warning while running cthon against an ontap server running pNFS:  [   57.202521] ============================= [   57.202522] WARNING: suspicious RCU usage [   57.202523] 6.7.0-rc3-g2cc14f52aeb7 #41492 Not tainted [   57.202525] ----------------------------- [   57.202525] net/sunrpc/xprtmultipath.c:349 RCU-list traversed in non-reader section!! [   57.202527]                other info that might help us debug this:  [   57.202528]                rcu_scheduler_active = 2, debug_locks = 1 [   57.202529] no locks held by test5/3567. [   57.202530]                stack backtrace: [   57.202532] CPU: 0 PID: 3567 Comm: test5 Not tainted 6.7.0-rc3-g2cc14f52aeb7 #41492 5b09971b4965c0aceba19f3eea324a4a806e227e [   57.202534] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS unknown 2/2/2022 [   57.202536] Call Trace: [   57.202537]  \u003cTASK\u003e [   57.202540]  dump_stack_lvl+0x77/0xb0 [   57.202551]  lockdep_rcu_suspicious+0x154/0x1a0 [   57.202556]  rpc_xprt_switch_has_addr+0x17c/0x190 [sunrpc ebe02571b9a8ceebf7d98e71675af20c19bdb1f6] [   57.202596]  rpc_clnt_setup_test_and_add_xprt+0x50/0x180 [sunrpc ebe02571b9a8ceebf7d98e71675af20c19bdb1f6] [   57.202621]  ? rpc_clnt_add_xprt+0x254/0x300 [sunrpc ebe02571b9a8ceebf7d98e71675af20c19bdb1f6] [   57.202646]  rpc_clnt_add_xprt+0x27a/0x300 [sunrpc ebe02571b9a8ceebf7d98e71675af20c19bdb1f6] [   57.202671]  ? __pfx_rpc_clnt_setup_test_and_add_xprt+0x10/0x10 [sunrpc ebe02571b9a8ceebf7d98e71675af20c19bdb1f6] [   57.202696]  nfs4_pnfs_ds_connect+0x345/0x760 [nfsv4 c716d88496ded0ea6d289bbea684fa996f9b57a9] [   57.202728]  ? __pfx_nfs4_test_session_trunk+0x10/0x10 [nfsv4 c716d88496ded0ea6d289bbea684fa996f9b57a9] [   57.202754]  nfs4_fl_prepare_ds+0x75/0xc0 [nfs_layout_nfsv41_files e3a4187f18ae8a27b630f9feae6831b584a9360a] [   57.202760]  filelayout_write_pagelist+0x4a/0x200 [nfs_layout_nfsv41_files e3a4187f18ae8a27b630f9feae6831b584a9360a] [   57.202765]  pnfs_generic_pg_writepages+0xbe/0x230 [nfsv4 c716d88496ded0ea6d289bbea684fa996f9b57a9] [   57.202788]  __nfs_pageio_add_request+0x3fd/0x520 [nfs 6c976fa593a7c2976f5a0aeb4965514a828e6902] [   57.202813]  nfs_pageio_add_request+0x18b/0x390 [nfs 6c976fa593a7c2976f5a0aeb4965514a828e6902] [   57.202831]  nfs_do_writepage+0x116/0x1e0 [nfs 6c976fa593a7c2976f5a0aeb4965514a828e6902] [   57.202849]  nfs_writepages_callback+0x13/0x30 [nfs 6c976fa593a7c2976f5a0aeb4965514a828e6902] [   57.202866]  write_cache_pages+0x265/0x450 [   57.202870]  ? __pfx_nfs_writepages_callback+0x10/0x10 [nfs 6c976fa593a7c2976f5a0aeb4965514a828e6902] [   57.202891]  nfs_writepages+0x141/0x230 [nfs 6c976fa593a7c2976f5a0aeb4965514a828e6902] [   57.202913]  do_writepages+0xd2/0x230 [   57.202917]  ? filemap_fdatawrite_wbc+0x5c/0x80 [   57.202921]  filemap_fdatawrite_wbc+0x67/0x80 [   57.202924]  filemap_write_and_wait_range+0xd9/0x170 [   57.202930]  nfs_wb_all+0x49/0x180 [nfs 6c976fa593a7c2976f5a0aeb4965514a828e6902] [   57.202947]  nfs4_file_flush+0x72/0xb0 [nfsv4 c716d88496ded0ea6d289bbea684fa996f9b57a9] [   57.202969]  __se_sys_close+0x46/0xd0 [   57.202972]  do_syscall_64+0x68/0x100 [   57.202975]  ? do_syscall_64+0x77/0x100 [   57.202976]  ? do_syscall_64+0x77/0x100 [   57.202979]  entry_SYSCALL_64_after_hwframe+0x6e/0x76 [   57.202982] RIP: 0033:0x7fe2b12e4a94 [   57.202985] Code: 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 80 3d d5 18 0e 00 00 74 13 b8 03 00 00 00 0f 05 \u003c48\u003e 3d 00 f0 ff ff 77 44 c3 0f 1f 00 48 83 ec 18 89 7c 24 0c e8 c3 [   57.202987] RSP: 002b:00007ffe857ddb38 EFLAGS: 00000202 ORIG_RAX: 0000000000000003 [   57.202989] RAX: ffffffffffffffda RBX: 00007ffe857dfd68 RCX: 00007fe2b12e4a94 [   57.202991] RDX: 0000000000002000 RSI: 00007ffe857ddc40 RDI: 0000000000000003 [   57.202992] RBP: 00007ffe857dfc50 R08: 7fffffffffffffff R09: 0000000065650f49 [   57.202993] R10: 00007f ---truncated---",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52623",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26645",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  tracing: Ensure visibility when inserting an element into tracing_map  Running the following two commands in parallel on a multi-processor AArch64 machine can sporadically produce an unexpected warning about duplicate histogram entries:   $ while true; do      echo hist:key=id.syscall:val=hitcount \u003e \\        /sys/kernel/debug/tracing/events/raw_syscalls/sys_enter/trigger      cat /sys/kernel/debug/tracing/events/raw_syscalls/sys_enter/hist      sleep 0.001    done  $ stress-ng --sysbadaddr $(nproc)  The warning looks as follows:  [ 2911.172474] ------------[ cut here ]------------ [ 2911.173111] Duplicates detected: 1 [ 2911.173574] WARNING: CPU: 2 PID: 12247 at kernel/trace/tracing_map.c:983 tracing_map_sort_entries+0x3e0/0x408 [ 2911.174702] Modules linked in: iscsi_ibft(E) iscsi_boot_sysfs(E) rfkill(E) af_packet(E) nls_iso8859_1(E) nls_cp437(E) vfat(E) fat(E) ena(E) tiny_power_button(E) qemu_fw_cfg(E) button(E) fuse(E) efi_pstore(E) ip_tables(E) x_tables(E) xfs(E) libcrc32c(E) aes_ce_blk(E) aes_ce_cipher(E) crct10dif_ce(E) polyval_ce(E) polyval_generic(E) ghash_ce(E) gf128mul(E) sm4_ce_gcm(E) sm4_ce_ccm(E) sm4_ce(E) sm4_ce_cipher(E) sm4(E) sm3_ce(E) sm3(E) sha3_ce(E) sha512_ce(E) sha512_arm64(E) sha2_ce(E) sha256_arm64(E) nvme(E) sha1_ce(E) nvme_core(E) nvme_auth(E) t10_pi(E) sg(E) scsi_mod(E) scsi_common(E) efivarfs(E) [ 2911.174738] Unloaded tainted modules: cppc_cpufreq(E):1 [ 2911.180985] CPU: 2 PID: 12247 Comm: cat Kdump: loaded Tainted: G            E      6.7.0-default #2 1b58bbb22c97e4399dc09f92d309344f69c44a01 [ 2911.182398] Hardware name: Amazon EC2 c7g.8xlarge/, BIOS 1.0 11/1/2018 [ 2911.183208] pstate: 61400005 (nZCv daif +PAN -UAO -TCO +DIT -SSBS BTYPE=--) [ 2911.184038] pc : tracing_map_sort_entries+0x3e0/0x408 [ 2911.184667] lr : tracing_map_sort_entries+0x3e0/0x408 [ 2911.185310] sp : ffff8000a1513900 [ 2911.185750] x29: ffff8000a1513900 x28: ffff0003f272fe80 x27: 0000000000000001 [ 2911.186600] x26: ffff0003f272fe80 x25: 0000000000000030 x24: 0000000000000008 [ 2911.187458] x23: ffff0003c5788000 x22: ffff0003c16710c8 x21: ffff80008017f180 [ 2911.188310] x20: ffff80008017f000 x19: ffff80008017f180 x18: ffffffffffffffff [ 2911.189160] x17: 0000000000000000 x16: 0000000000000000 x15: ffff8000a15134b8 [ 2911.190015] x14: 0000000000000000 x13: 205d373432323154 x12: 5b5d313131333731 [ 2911.190844] x11: 00000000fffeffff x10: 00000000fffeffff x9 : ffffd1b78274a13c [ 2911.191716] x8 : 000000000017ffe8 x7 : c0000000fffeffff x6 : 000000000057ffa8 [ 2911.192554] x5 : ffff0012f6c24ec0 x4 : 0000000000000000 x3 : ffff2e5b72b5d000 [ 2911.193404] x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff0003ff254480 [ 2911.194259] Call trace: [ 2911.194626]  tracing_map_sort_entries+0x3e0/0x408 [ 2911.195220]  hist_show+0x124/0x800 [ 2911.195692]  seq_read_iter+0x1d4/0x4e8 [ 2911.196193]  seq_read+0xe8/0x138 [ 2911.196638]  vfs_read+0xc8/0x300 [ 2911.197078]  ksys_read+0x70/0x108 [ 2911.197534]  __arm64_sys_read+0x24/0x38 [ 2911.198046]  invoke_syscall+0x78/0x108 [ 2911.198553]  el0_svc_common.constprop.0+0xd0/0xf8 [ 2911.199157]  do_el0_svc+0x28/0x40 [ 2911.199613]  el0_svc+0x40/0x178 [ 2911.200048]  el0t_64_sync_handler+0x13c/0x158 [ 2911.200621]  el0t_64_sync+0x1a8/0x1b0 [ 2911.201115] ---[ end trace 0000000000000000 ]---  The problem appears to be caused by CPU reordering of writes issued from __tracing_map_insert().  The check for the presence of an element with a given key in this function is:   val = READ_ONCE(entry-\u003eval);  if (val \u0026\u0026 keys_match(key, val-\u003ekey, map-\u003ekey_size)) ...  The write of a new entry is:   elt = get_free_elt(map);  memcpy(elt-\u003ekey, key, map-\u003ekey_size);  entry-\u003eval = elt;  The \"memcpy(elt-\u003ekey, key, map-\u003ekey_size);\" and \"entry-\u003eval = elt;\" stores may become visible in the reversed order on another CPU. This second CPU might then incorrectly determine that a new key doesn't match an already present val-\u003ekey and subse ---truncated---",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26645",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52629",
            "namespace": "debian:11",
            "description": "",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52629",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-3863",
            "namespace": "debian:11",
            "description": "A use-after-free flaw was found in nfc_llcp_find_local in net/nfc/llcp_core.c in NFC in the Linux kernel. This flaw allows a local user with special privileges to impact a kernel information leak issue.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3863",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "systemd",
            "featureversion": "247.3-7+deb11u1",
            "vulnerability": "CVE-2022-4415",
            "namespace": "debian:11",
            "description": "A vulnerability was found in systemd. This security flaw can cause a local information leak due to systemd-coredump not respecting the fs.suid_dumpable kernel setting.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-4415",
            "severity": "Unknown",
            "fixedby": "247.3-7+deb11u2"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52444",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: fix to avoid dirent corruption  As Al reported in link[1]:  f2fs_rename() ... \tif (old_dir != new_dir \u0026\u0026 !whiteout) \t\tf2fs_set_link(old_inode, old_dir_entry, \t\t\t\t\told_dir_page, new_dir); \telse \t\tf2fs_put_page(old_dir_page, 0);  You want correct inumber in the \"..\" link.  And cross-directory rename does move the source to new parent, even if you'd been asked to leave a whiteout in the old place.  [1] https://lore.kernel.org/all/20231017055040.GN800259@ZenIV/  With below testcase, it may cause dirent corruption, due to it missed to call f2fs_set_link() to update \"..\" link to new directory. - mkdir -p dir/foo - renameat2 -w dir/foo bar  [ASSERT] (__chk_dots_dentries:1421)  --\u003e Bad inode number[0x4] for '..', parent parent ino is [0x3] [FSCK] other corrupted bugs                           [Fail]",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52444",
            "severity": "Unknown",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "systemd",
            "featureversion": "247.3-7+deb11u1",
            "vulnerability": "CVE-2023-50387",
            "namespace": "debian:11",
            "description": "Certain DNSSEC aspects of the DNS protocol (in RFC 4033, 4034, 4035, 6840, and related RFCs) allow remote attackers to cause a denial of service (CPU consumption) via one or more DNSSEC responses, aka the \"KeyTrap\" issue. One of the concerns is that, when there is a zone with many DNSKEY and RRSIG records, the protocol specification implies that an algorithm must evaluate all combinations of DNSKEY and RRSIG records.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-50387",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "systemd",
            "featureversion": "247.3-7+deb11u1",
            "vulnerability": "CVE-2022-3821",
            "namespace": "debian:11",
            "description": "An off-by-one Error issue was discovered in Systemd in format_timespan() function of time-util.c. An attacker could supply specific values for time and accuracy that leads to buffer overrun in format_timespan(), leading to a Denial of Service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-3821",
            "severity": "Unknown",
            "fixedby": "247.3-7+deb11u2"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-37454",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 6.4.2. A crafted UDF filesystem image causes a use-after-free write operation in the udf_put_super and udf_close_lvid functions in fs/udf/super.c. NOTE: the suse.com reference has a different perspective about this.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-37454",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-51780",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel before 6.6.8. do_vcc_ioctl in net/atm/ioctl.c has a use-after-free because of a vcc_recvmsg race condition.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-51780",
            "severity": "Unknown",
            "fixedby": "5.10.205-2"
        },
        {
            "featurename": "systemd",
            "featureversion": "247.3-7+deb11u1",
            "vulnerability": "CVE-2023-7008",
            "namespace": "debian:11",
            "description": "A vulnerability was found in systemd-resolved. This issue may allow systemd-resolved to accept records of DNSSEC-signed domains even when they have no signature, allowing man-in-the-middles (or the upstream DNS resolver) to manipulate records.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-7008",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "systemd",
            "featureversion": "247.3-7+deb11u1",
            "vulnerability": "CVE-2023-50868",
            "namespace": "debian:11",
            "description": "The Closest Encloser Proof aspect of the DNS protocol (in RFC 5155 when RFC 9276 guidance is skipped) allows remote attackers to cause a denial of service (CPU consumption for SHA-1 computations) via DNSSEC responses in a random subdomain attack, aka the \"NSEC3\" issue. The RFC 5155 specification implies that an algorithm must perform thousands of iterations of a hash function in certain situations.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-50868",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-3566",
            "namespace": "debian:11",
            "description": "A vulnerability, which was classified as problematic, was found in Linux Kernel. This affects the function tcp_getsockopt/tcp_setsockopt of the component TCP Handler. The manipulation leads to race condition. It is recommended to apply a patch to fix this issue. The identifier VDB-211089 was assigned to this vulnerability.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-3566",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26598",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  KVM: arm64: vgic-its: Avoid potential UAF in LPI translation cache  There is a potential UAF scenario in the case of an LPI translation cache hit racing with an operation that invalidates the cache, such as a DISCARD ITS command. The root of the problem is that vgic_its_check_cache() does not elevate the refcount on the vgic_irq before dropping the lock that serializes refcount changes.  Have vgic_its_check_cache() raise the refcount on the returned vgic_irq and add the corresponding decrement after queueing the interrupt.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26598",
            "severity": "Unknown",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52488",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  serial: sc16is7xx: convert from _raw_ to _noinc_ regmap functions for FIFO  The SC16IS7XX IC supports a burst mode to access the FIFOs where the initial register address is sent ($00), followed by all the FIFO data without having to resend the register address each time. In this mode, the IC doesn't increment the register address for each R/W byte.  The regmap_raw_read() and regmap_raw_write() are functions which can perform IO over multiple registers. They are currently used to read/write from/to the FIFO, and although they operate correctly in this burst mode on the SPI bus, they would corrupt the regmap cache if it was not disabled manually. The reason is that when the R/W size is more than 1 byte, these functions assume that the register address is incremented and handle the cache accordingly.  Convert FIFO R/W functions to use the regmap _noinc_ versions in order to remove the manual cache control which was a workaround when using the _raw_ versions. FIFO registers are properly declared as volatile so cache will not be used/updated for FIFO accesses.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52488",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-3358",
            "namespace": "debian:11",
            "description": "A null pointer dereference was found in the Linux kernel's Integrated Sensor Hub (ISH) driver. This issue could allow a local user to crash the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3358",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "gnutls28",
            "featureversion": "3.7.1-5+deb11u2",
            "vulnerability": "CVE-2024-0553",
            "namespace": "debian:11",
            "description": "A vulnerability was found in GnuTLS. The response times to malformed ciphertexts in RSA-PSK ClientKeyExchange differ from the response times of ciphertexts with correct PKCS#1 v1.5 padding. This issue may allow a remote attacker to perform a timing side-channel attack in the RSA-PSK key exchange, potentially leading to the leakage of sensitive data. CVE-2024-0553 is designated as an incomplete resolution for CVE-2023-5981.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-0553",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "gnutls28",
            "featureversion": "3.7.1-5+deb11u2",
            "vulnerability": "CVE-2023-5981",
            "namespace": "debian:11",
            "description": "A vulnerability was found that the response times to malformed ciphertexts in RSA-PSK ClientKeyExchange differ from response times of ciphertexts with correct PKCS#1 v1.5 padding.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-5981",
            "severity": "Unknown",
            "fixedby": "3.7.1-5+deb11u4"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-0564",
            "namespace": "debian:11",
            "description": "A flaw was found in the Linux kernel's memory deduplication mechanism. The max page sharing of Kernel Samepage Merging (KSM), added in Linux kernel version 4.4.0-96.119, can create a side channel. When the attacker and the victim share the same host and the default setting of KSM is \"max page sharing=256\", it is possible for the attacker to time the unmap to merge with the victim's page. The unmapping time depends on whether it merges with the victim's page and additional physical pages are created beyond the KSM's \"max page share\". Through these operations, the attacker can leak the victim's page.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-0564",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "gnutls28",
            "featureversion": "3.7.1-5+deb11u2",
            "vulnerability": "CVE-2024-28835",
            "namespace": "debian:11",
            "description": "A flaw has been discovered in GnuTLS where an application crash can be induced when attempting to verify a specially crafted .pem bundle using the \"certtool --verify-chain\" command.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-28835",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "gnutls28",
            "featureversion": "3.7.1-5+deb11u2",
            "vulnerability": "CVE-2024-28834",
            "namespace": "debian:11",
            "description": "A flaw was found in GnuTLS. The Minerva attack is a cryptographic vulnerability that exploits deterministic behavior in systems like GnuTLS, leading to side-channel leaks. In specific scenarios, such as when using the GNUTLS_PRIVKEY_FLAG_REPRODUCIBLE flag, it can result in a noticeable step in nonce size from 513 to 512 bits, exposing a potential timing side-channel.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-28834",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "gnutls28",
            "featureversion": "3.7.1-5+deb11u2",
            "vulnerability": "CVE-2023-0361",
            "namespace": "debian:11",
            "description": "A timing side-channel in the handling of RSA ClientKeyExchange messages was discovered in GnuTLS. This side-channel can be sufficient to recover the key encrypted in the RSA ciphertext across a network in a Bleichenbacher style attack. To achieve a successful decryption the attacker would need to send a large amount of specially crafted messages to the vulnerable server. By recovering the secret from the ClientKeyExchange message, the attacker would be able to decrypt the application data exchanged over that connection.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-0361",
            "severity": "Unknown",
            "fixedby": "3.7.1-5+deb11u3"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-46343",
            "namespace": "debian:11",
            "description": "In the Linux kernel before 6.5.9, there is a NULL pointer dereference in send_acknowledge in net/nfc/nci/spi.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-46343",
            "severity": "Unknown",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-48628",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  ceph: drop messages from MDS when unmounting  When unmounting all the dirty buffers will be flushed and after the last osd request is finished the last reference of the i_count will be released. Then it will flush the dirty cap/snap to MDSs, and the unmounting won't wait the possible acks, which will ihold the inodes when updating the metadata locally but makes no sense any more, of this. This will make the evict_inodes() to skip these inodes.  If encrypt is enabled the kernel generate a warning when removing the encrypt keys when the skipped inodes still hold the keyring:  WARNING: CPU: 4 PID: 168846 at fs/crypto/keyring.c:242 fscrypt_destroy_keyring+0x7e/0xd0 CPU: 4 PID: 168846 Comm: umount Tainted: G S  6.1.0-rc5-ceph-g72ead199864c #1 Hardware name: Supermicro SYS-5018R-WR/X10SRW-F, BIOS 2.0 12/17/2015 RIP: 0010:fscrypt_destroy_keyring+0x7e/0xd0 RSP: 0018:ffffc9000b277e28 EFLAGS: 00010202 RAX: 0000000000000002 RBX: ffff88810d52ac00 RCX: ffff88810b56aa00 RDX: 0000000080000000 RSI: ffffffff822f3a09 RDI: ffff888108f59000 RBP: ffff8881d394fb88 R08: 0000000000000028 R09: 0000000000000000 R10: 0000000000000001 R11: 11ff4fe6834fcd91 R12: ffff8881d394fc40 R13: ffff888108f59000 R14: ffff8881d394f800 R15: 0000000000000000 FS:  00007fd83f6f1080(0000) GS:ffff88885fd00000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f918d417000 CR3: 000000017f89a005 CR4: 00000000003706e0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: \u003cTASK\u003e generic_shutdown_super+0x47/0x120 kill_anon_super+0x14/0x30 ceph_kill_sb+0x36/0x90 [ceph] deactivate_locked_super+0x29/0x60 cleanup_mnt+0xb8/0x140 task_work_run+0x67/0xb0 exit_to_user_mode_prepare+0x23d/0x240 syscall_exit_to_user_mode+0x25/0x60 do_syscall_64+0x40/0x80 entry_SYSCALL_64_after_hwframe+0x63/0xcd RIP: 0033:0x7fd83dc39e9b  Later the kernel will crash when iput() the inodes and dereferencing the \"sb-\u003es_master_keys\", which has been released by the generic_shutdown_super().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-48628",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-4194",
            "namespace": "debian:11",
            "description": "A flaw was found in the Linux kernel's TUN/TAP functionality. This issue could allow a local user to bypass network filters and gain unauthorized access to some resources. The original patches fixing CVE-2023-1076 are incorrect or incomplete. The problem is that the following upstream commits - a096ccca6e50 (\"tun: tun_chr_open(): correctly initialize socket uid\"), - 66b2c338adce (\"tap: tap_open(): correctly initialize socket uid\"), pass \"inode-\u003ei_uid\" to sock_init_data_uid() as the last parameter and that turns out to not be accurate.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4194",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-21255",
            "namespace": "debian:11",
            "description": "In multiple functions of binder.c, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-21255",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-35001",
            "namespace": "debian:11",
            "description": "Linux Kernel nftables Out-Of-Bounds Read/Write Vulnerability; nft_byteorder poorly handled vm register contents when CAP_NET_ADMIN is in any user or network namespace",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-35001",
            "severity": "Unknown",
            "fixedby": "5.10.179-2"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52528",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  net: usb: smsc75xx: Fix uninit-value access in __smsc75xx_read_reg  syzbot reported the following uninit-value access issue:  ===================================================== BUG: KMSAN: uninit-value in smsc75xx_wait_ready drivers/net/usb/smsc75xx.c:975 [inline] BUG: KMSAN: uninit-value in smsc75xx_bind+0x5c9/0x11e0 drivers/net/usb/smsc75xx.c:1482 CPU: 0 PID: 8696 Comm: kworker/0:3 Not tainted 5.8.0-rc5-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Workqueue: usb_hub_wq hub_event Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x21c/0x280 lib/dump_stack.c:118  kmsan_report+0xf7/0x1e0 mm/kmsan/kmsan_report.c:121  __msan_warning+0x58/0xa0 mm/kmsan/kmsan_instr.c:215  smsc75xx_wait_ready drivers/net/usb/smsc75xx.c:975 [inline]  smsc75xx_bind+0x5c9/0x11e0 drivers/net/usb/smsc75xx.c:1482  usbnet_probe+0x1152/0x3f90 drivers/net/usb/usbnet.c:1737  usb_probe_interface+0xece/0x1550 drivers/usb/core/driver.c:374  really_probe+0xf20/0x20b0 drivers/base/dd.c:529  driver_probe_device+0x293/0x390 drivers/base/dd.c:701  __device_attach_driver+0x63f/0x830 drivers/base/dd.c:807  bus_for_each_drv+0x2ca/0x3f0 drivers/base/bus.c:431  __device_attach+0x4e2/0x7f0 drivers/base/dd.c:873  device_initial_probe+0x4a/0x60 drivers/base/dd.c:920  bus_probe_device+0x177/0x3d0 drivers/base/bus.c:491  device_add+0x3b0e/0x40d0 drivers/base/core.c:2680  usb_set_configuration+0x380f/0x3f10 drivers/usb/core/message.c:2032  usb_generic_driver_probe+0x138/0x300 drivers/usb/core/generic.c:241  usb_probe_device+0x311/0x490 drivers/usb/core/driver.c:272  really_probe+0xf20/0x20b0 drivers/base/dd.c:529  driver_probe_device+0x293/0x390 drivers/base/dd.c:701  __device_attach_driver+0x63f/0x830 drivers/base/dd.c:807  bus_for_each_drv+0x2ca/0x3f0 drivers/base/bus.c:431  __device_attach+0x4e2/0x7f0 drivers/base/dd.c:873  device_initial_probe+0x4a/0x60 drivers/base/dd.c:920  bus_probe_device+0x177/0x3d0 drivers/base/bus.c:491  device_add+0x3b0e/0x40d0 drivers/base/core.c:2680  usb_new_device+0x1bd4/0x2a30 drivers/usb/core/hub.c:2554  hub_port_connect drivers/usb/core/hub.c:5208 [inline]  hub_port_connect_change drivers/usb/core/hub.c:5348 [inline]  port_event drivers/usb/core/hub.c:5494 [inline]  hub_event+0x5e7b/0x8a70 drivers/usb/core/hub.c:5576  process_one_work+0x1688/0x2140 kernel/workqueue.c:2269  worker_thread+0x10bc/0x2730 kernel/workqueue.c:2415  kthread+0x551/0x590 kernel/kthread.c:292  ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:293  Local variable ----buf.i87@smsc75xx_bind created at:  __smsc75xx_read_reg drivers/net/usb/smsc75xx.c:83 [inline]  smsc75xx_wait_ready drivers/net/usb/smsc75xx.c:968 [inline]  smsc75xx_bind+0x485/0x11e0 drivers/net/usb/smsc75xx.c:1482  __smsc75xx_read_reg drivers/net/usb/smsc75xx.c:83 [inline]  smsc75xx_wait_ready drivers/net/usb/smsc75xx.c:968 [inline]  smsc75xx_bind+0x485/0x11e0 drivers/net/usb/smsc75xx.c:1482  This issue is caused because usbnet_read_cmd() reads less bytes than requested (zero byte in the reproducer). In this case, 'buf' is not properly filled.  This patch fixes the issue by returning -ENODATA if usbnet_read_cmd() reads less bytes than requested.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52528",
            "severity": "Unknown",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "openldap",
            "featureversion": "2.4.57+dfsg-3+deb11u1",
            "vulnerability": "CVE-2023-2953",
            "namespace": "debian:11",
            "description": "A vulnerability was found in openldap. This security flaw causes a null pointer dereference in ber_memalloc_x() function.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-2953",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-1855",
            "namespace": "debian:11",
            "description": "A use-after-free flaw was found in xgene_hwmon_remove in drivers/hwmon/xgene-hwmon.c in the Hardware Monitoring Linux Kernel Driver (xgene-hwmon). This flaw could allow a local attacker to crash the system due to a race problem. This vulnerability could even lead to a kernel information leak problem.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1855",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-35788",
            "namespace": "debian:11",
            "description": "An issue was discovered in fl_set_geneve_opt in net/sched/cls_flower.c in the Linux kernel before 6.3.7. It allows an out-of-bounds write in the flower classifier code via TCA_FLOWER_KEY_ENC_OPTS_GENEVE packets. This may result in denial of service or privilege escalation.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-35788",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "glib2.0",
            "featureversion": "2.66.8-1",
            "vulnerability": "CVE-2023-29499",
            "namespace": "debian:11",
            "description": "A flaw was found in GLib. GVariant deserialization fails to validate that the input conforms to the expected format, leading to denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-29499",
            "severity": "Unknown",
            "fixedby": "2.66.8-1+deb11u1"
        },
        {
            "featurename": "glib2.0",
            "featureversion": "2.66.8-1",
            "vulnerability": "CVE-2023-32665",
            "namespace": "debian:11",
            "description": "A flaw was found in GLib. GVariant deserialization is vulnerable to an exponential blowup issue where a crafted GVariant can cause excessive processing, leading to denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-32665",
            "severity": "Unknown",
            "fixedby": "2.66.8-1+deb11u1"
        },
        {
            "featurename": "glib2.0",
            "featureversion": "2.66.8-1",
            "vulnerability": "CVE-2023-32611",
            "namespace": "debian:11",
            "description": "A flaw was found in GLib. GVariant deserialization is vulnerable to a slowdown issue where a crafted GVariant can cause excessive processing, leading to denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-32611",
            "severity": "Unknown",
            "fixedby": "2.66.8-1+deb11u1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26629",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  nfsd: fix RELEASE_LOCKOWNER  The test on so_count in nfsd4_release_lockowner() is nonsense and harmful.  Revert to using check_for_locks(), changing that to not sleep.  First: harmful. As is documented in the kdoc comment for nfsd4_release_lockowner(), the test on so_count can transiently return a false positive resulting in a return of NFS4ERR_LOCKS_HELD when in fact no locks are held.  This is clearly a protocol violation and with the Linux NFS client it can cause incorrect behaviour.  If RELEASE_LOCKOWNER is sent while some other thread is still processing a LOCK request which failed because, at the time that request was received, the given owner held a conflicting lock, then the nfsd thread processing that LOCK request can hold a reference (conflock) to the lock owner that causes nfsd4_release_lockowner() to return an incorrect error.  The Linux NFS client ignores that NFS4ERR_LOCKS_HELD error because it never sends NFS4_RELEASE_LOCKOWNER without first releasing any locks, so it knows that the error is impossible.  It assumes the lock owner was in fact released so it feels free to use the same lock owner identifier in some later locking request.  When it does reuse a lock owner identifier for which a previous RELEASE failed, it will naturally use a lock_seqid of zero.  However the server, which didn't release the lock owner, will expect a larger lock_seqid and so will respond with NFS4ERR_BAD_SEQID.  So clearly it is harmful to allow a false positive, which testing so_count allows.  The test is nonsense because ... well... it doesn't mean anything.  so_count is the sum of three different counts. 1/ the set of states listed on so_stateids 2/ the set of active vfs locks owned by any of those states 3/ various transient counts such as for conflicting locks.  When it is tested against '2' it is clear that one of these is the transient reference obtained by find_lockowner_str_locked().  It is not clear what the other one is expected to be.  In practice, the count is often 2 because there is precisely one state on so_stateids.  If there were more, this would fail.  In my testing I see two circumstances when RELEASE_LOCKOWNER is called. In one case, CLOSE is called before RELEASE_LOCKOWNER.  That results in all the lock states being removed, and so the lockowner being discarded (it is removed when there are no more references which usually happens when the lock state is discarded).  When nfsd4_release_lockowner() finds that the lock owner doesn't exist, it returns success.  The other case shows an so_count of '2' and precisely one state listed in so_stateid.  It appears that the Linux client uses a separate lock owner for each file resulting in one lock state per lock owner, so this test on '2' is safe.  For another client it might not be safe.  So this patch changes check_for_locks() to use the (newish) find_any_file_locked() so that it doesn't take a reference on the nfs4_file and so never calls nfsd_file_put(), and so never sleeps.  With this check is it safe to restore the use of check_for_locks() rather than testing so_count against the mysterious '2'.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26629",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-1281",
            "namespace": "debian:11",
            "description": "Use After Free vulnerability in Linux kernel traffic control index filter (tcindex) allows Privilege Escalation. The imperfect hash area can be updated while packets are traversing, which will cause a use-after-free when 'tcf_exts_exec()' is called with the destroyed tcf_ext. A local attacker user can use this vulnerability to elevate its privileges to root. This issue affects Linux Kernel: from 4.14 before git commit ee059170b1f7e94e55fa6cadee544e176a6e59c2.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1281",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-6040",
            "namespace": "debian:11",
            "description": "An out-of-bounds access vulnerability involving netfilter was reported and fixed as: f1082dd31fe4 (netfilter: nf_tables: Reject tables of unsupported family); While creating a new netfilter table, lack of a safeguard against invalid nf_tables family (pf) values within `nf_tables_newtable` function enables an attacker to achieve out-of-bounds access.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-6040",
            "severity": "Unknown",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "glibc",
            "featureversion": "2.31-13+deb11u5",
            "vulnerability": "CVE-2023-4813",
            "namespace": "debian:11",
            "description": "A flaw was found in glibc. In an uncommon situation, the gaih_inet function may use memory that has been freed, resulting in an application crash. This issue is only exploitable when the getaddrinfo function is called and the hosts database in /etc/nsswitch.conf is configured with SUCCESS=continue or SUCCESS=merge.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4813",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-3344",
            "namespace": "debian:11",
            "description": "A flaw was found in the KVM's AMD nested virtualization (SVM). A malicious L1 guest could purposely fail to intercept the shutdown of a cooperative nested guest (L2), possibly leading to a page fault and kernel panic in the host (L0).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-3344",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-4269",
            "namespace": "debian:11",
            "description": "A flaw was found in the Linux kernel Traffic Control (TC) subsystem. Using a specific networking configuration (redirecting egress packets to ingress using TC action \"mirred\") a local unprivileged user could trigger a CPU soft lockup (ABBA deadlock) when the transport protocol in use (TCP or SCTP) does a retransmission, resulting in a denial of service condition.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-4269",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-31436",
            "namespace": "debian:11",
            "description": "qfq_change_class in net/sched/sch_qfq.c in the Linux kernel before 6.2.13 allows an out-of-bounds write because lmax can exceed QFQ_MIN_LMAX.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-31436",
            "severity": "Unknown",
            "fixedby": "5.10.179-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2021-33631",
            "namespace": "debian:11",
            "description": "Integer Overflow or Wraparound vulnerability in openEuler kernel on Linux (filesystem modules) allows Forced Integer Overflow.This issue affects openEuler kernel: from 4.19.90 before 4.19.90-2401.3, from 5.10.0-60.18.0 before 5.10.0-183.0.0.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-33631",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-4132",
            "namespace": "debian:11",
            "description": "A use-after-free vulnerability was found in the siano smsusb module in the Linux kernel. The bug occurs during device initialization when the siano device is plugged in. This flaw allows a local user to crash the system, causing a denial of service condition.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4132",
            "severity": "Unknown",
            "fixedby": "5.10.191-1"
        },
        {
            "featurename": "glibc",
            "featureversion": "2.31-13+deb11u5",
            "vulnerability": "CVE-2023-4806",
            "namespace": "debian:11",
            "description": "A flaw was found in glibc. In an extremely rare situation, the getaddrinfo function may access memory that has been freed, resulting in an application crash. This issue is only exploitable when a NSS module implements only the _nss_*_gethostbyname2_r and _nss_*_getcanonname_r hooks without implementing the _nss_*_gethostbyname3_r hook. The resolved name should return a large number of IPv6 and IPv4, and the call to the getaddrinfo function should have the AF_INET6 address family with AI_CANONNAME, AI_ALL and AI_V4MAPPED as flags.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4806",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-39189",
            "namespace": "debian:11",
            "description": "A flaw was found in the Netfilter subsystem in the Linux kernel. The nfnl_osf_add_callback function did not validate the user mode controlled opt_num field. This flaw allows a local privileged (CAP_NET_ADMIN) attacker to trigger an out-of-bounds read, leading to a crash or information disclosure.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-39189",
            "severity": "Unknown",
            "fixedby": "5.10.197-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-6932",
            "namespace": "debian:11",
            "description": "A use-after-free vulnerability in the Linux kernel's ipv4: igmp component can be exploited to achieve local privilege escalation.  A race condition can be exploited to cause a timer be mistakenly registered on a RCU read locked object which is freed by another thread.  We recommend upgrading past commit e2b706c691905fe78468c361aaabc719d0a496f1.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-6932",
            "severity": "Unknown",
            "fixedby": "5.10.205-2"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-4382",
            "namespace": "debian:11",
            "description": "A use-after-free flaw caused by a race among the superblock operations in the gadgetfs Linux driver was found. It could be triggered by yanking out a device that is running the gadgetfs side.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-4382",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-47929",
            "namespace": "debian:11",
            "description": "In the Linux kernel before 6.1.6, a NULL pointer dereference bug in the traffic control subsystem allows an unprivileged user to trigger a denial of service (system crash) via a crafted traffic control configuration that is set up with \"tc qdisc\" and \"tc class\" commands. This affects qdisc_graft in net/sched/sch_api.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-47929",
            "severity": "Unknown",
            "fixedby": "5.10.162-1"
        },
        {
            "featurename": "shadow",
            "featureversion": "1:4.8.1-1",
            "vulnerability": "CVE-2023-29383",
            "namespace": "debian:11",
            "description": "In Shadow 4.13, it is possible to inject control characters into fields provided to the SUID program chfn (change finger). Although it is not possible to exploit this directly (e.g., adding a new user fails because \\n is in the block list), it is possible to misrepresent the /etc/passwd file when viewed. Use of \\r manipulations and Unicode characters to work around blocking of the : character make it possible to give the impression that a new user has been added. In other words, an adversary may be able to convince a system administrator to take the system offline (an indirect, social-engineered denial of service) by demonstrating that \"cat /etc/passwd\" shows a rogue user account.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-29383",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52429",
            "namespace": "debian:11",
            "description": "dm_table_create in drivers/md/dm-table.c in the Linux kernel through 6.7.4 can attempt to (in alloc_targets) allocate more than INT_MAX bytes, and crash, because of a missing check for struct dm_ioctl.target_count.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52429",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-1073",
            "namespace": "debian:11",
            "description": "A memory corruption flaw was found in the Linux kernel’s human interface device (HID) subsystem in how a user inserts a malicious USB device. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1073",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "shadow",
            "featureversion": "1:4.8.1-1",
            "vulnerability": "CVE-2023-4641",
            "namespace": "debian:11",
            "description": "A flaw was found in shadow-utils. When asking for a new password, shadow-utils asks the password twice. If the password fails on the second attempt, shadow-utils fails in cleaning the buffer used to store the first entry. This may allow an attacker with enough access to retrieve the password from the memory.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4641",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u3",
            "vulnerability": "CVE-2023-46218",
            "namespace": "debian:11",
            "description": "This flaw allows a malicious HTTP server to set \"super cookies\" in curl that are then passed back to more origins than what is otherwise allowed or possible. This allows a site to set cookies that then would get sent to different and unrelated sites and domains.  It could do this by exploiting a mixed case flaw in curl's function that verifies a given cookie domain against the Public Suffix List (PSL). For example a cookie could be set with `domain=co.UK` when the URL used a lower case hostname `curl.co.uk`, even though `co.uk` is listed as a PSL domain.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-46218",
            "severity": "Unknown",
            "fixedby": "7.74.0-1.3+deb11u11"
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u3",
            "vulnerability": "CVE-2023-23916",
            "namespace": "debian:11",
            "description": "An allocation of resources without limits or throttling vulnerability exists in curl \u003cv7.88.0 based on the \"chained\" HTTP compression algorithms, meaning that a server response can be compressed multiple times and potentially with differentalgorithms. The number of acceptable \"links\" in this \"decompression chain\" wascapped, but the cap was implemented on a per-header basis allowing a maliciousserver to insert a virtually unlimited number of compression steps simply byusing many headers. The use of such a decompression chain could result in a \"malloc bomb\", making curl end up spending enormous amounts of allocated heap memory, or trying to and returning out of memory errors.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-23916",
            "severity": "Unknown",
            "fixedby": "7.74.0-1.3+deb11u7"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52477",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  usb: hub: Guard against accesses to uninitialized BOS descriptors  Many functions in drivers/usb/core/hub.c and drivers/usb/core/hub.h access fields inside udev-\u003ebos without checking if it was allocated and initialized. If usb_get_bos_descriptor() fails for whatever reason, udev-\u003ebos will be NULL and those accesses will result in a crash:  BUG: kernel NULL pointer dereference, address: 0000000000000018 PGD 0 P4D 0 Oops: 0000 [#1] PREEMPT SMP NOPTI CPU: 5 PID: 17818 Comm: kworker/5:1 Tainted: G W 5.15.108-18910-gab0e1cb584e1 #1 \u003cHASH:1f9e 1\u003e Hardware name: Google Kindred/Kindred, BIOS Google_Kindred.12672.413.0 02/03/2021 Workqueue: usb_hub_wq hub_event RIP: 0010:hub_port_reset+0x193/0x788 Code: 89 f7 e8 20 f7 15 00 48 8b 43 08 80 b8 96 03 00 00 03 75 36 0f b7 88 92 03 00 00 81 f9 10 03 00 00 72 27 48 8b 80 a8 03 00 00 \u003c48\u003e 83 78 18 00 74 19 48 89 df 48 8b 75 b0 ba 02 00 00 00 4c 89 e9 RSP: 0018:ffffab740c53fcf8 EFLAGS: 00010246 RAX: 0000000000000000 RBX: ffffa1bc5f678000 RCX: 0000000000000310 RDX: fffffffffffffdff RSI: 0000000000000286 RDI: ffffa1be9655b840 RBP: ffffab740c53fd70 R08: 00001b7d5edaa20c R09: ffffffffb005e060 R10: 0000000000000001 R11: 0000000000000000 R12: 0000000000000000 R13: ffffab740c53fd3e R14: 0000000000000032 R15: 0000000000000000 FS: 0000000000000000(0000) GS:ffffa1be96540000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000018 CR3: 000000022e80c005 CR4: 00000000003706e0 Call Trace: hub_event+0x73f/0x156e ? hub_activate+0x5b7/0x68f process_one_work+0x1a2/0x487 worker_thread+0x11a/0x288 kthread+0x13a/0x152 ? process_one_work+0x487/0x487 ? kthread_associate_blkcg+0x70/0x70 ret_from_fork+0x1f/0x30  Fall back to a default behavior if the BOS descriptor isn't accessible and skip all the functionalities that depend on it: LPM support checks, Super Speed capabilitiy checks, U1/U2 states setup.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52477",
            "severity": "Unknown",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52504",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  x86/alternatives: Disable KASAN in apply_alternatives()  Fei has reported that KASAN triggers during apply_alternatives() on a 5-level paging machine:  \tBUG: KASAN: out-of-bounds in rcu_is_watching() \tRead of size 4 at addr ff110003ee6419a0 by task swapper/0/0 \t... \t__asan_load4() \trcu_is_watching() \ttrace_hardirqs_on() \ttext_poke_early() \tapply_alternatives() \t...  On machines with 5-level paging, cpu_feature_enabled(X86_FEATURE_LA57) gets patched. It includes KASAN code, where KASAN_SHADOW_START depends on __VIRTUAL_MASK_SHIFT, which is defined with cpu_feature_enabled().  KASAN gets confused when apply_alternatives() patches the KASAN_SHADOW_START users. A test patch that makes KASAN_SHADOW_START static, by replacing __VIRTUAL_MASK_SHIFT with 56, works around the issue.  Fix it for real by disabling KASAN while the kernel is patching alternatives.  [ mingo: updated the changelog ]",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52504",
            "severity": "Unknown",
            "fixedby": "5.10.205-1"
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u3",
            "vulnerability": "CVE-2023-28321",
            "namespace": "debian:11",
            "description": "An improper certificate validation vulnerability exists in curl \u003cv8.1.0 in the way it supports matching of wildcard patterns when listed as \"Subject Alternative Name\" in TLS server certificates. curl can be built to use its own name matching function for TLS rather than one provided by a TLS library. This private wildcard matching function would match IDN (International Domain Name) hosts incorrectly and could as a result accept patterns that otherwise should mismatch. IDN hostnames are converted to puny code before used for certificate checks. Puny coded names always start with `xn--` and should not be allowed to pattern match, but the wildcard check in curl could still check for `x*`, which would match even though the IDN name most likely contained nothing even resembling an `x`.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-28321",
            "severity": "Unknown",
            "fixedby": "7.74.0-1.3+deb11u9"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-21803",
            "namespace": "debian:11",
            "description": "Use After Free vulnerability in Linux Linux kernel kernel on Linux, x86, ARM (bluetooth modules) allows Local Execution of Code. This vulnerability is associated with program files https://gitee.Com/anolis/cloud-kernel/blob/devel-5.10/net/bluetooth/af_bluetooth.C.  This issue affects Linux kernel: from v2.6.12-rc2 before v6.8-rc1.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-21803",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u3",
            "vulnerability": "CVE-2023-27533",
            "namespace": "debian:11",
            "description": "A vulnerability in input validation exists in curl \u003c8.0 during communication using the TELNET protocol may allow an attacker to pass on maliciously crafted user name and \"telnet options\" during server negotiation. The lack of proper input scrubbing allows an attacker to send content or perform option negotiation without the application's intent. This vulnerability could be exploited if an application allows user input, thereby enabling attackers to execute arbitrary code on the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-27533",
            "severity": "Unknown",
            "fixedby": "7.74.0-1.3+deb11u8"
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u3",
            "vulnerability": "CVE-2023-27534",
            "namespace": "debian:11",
            "description": "A path traversal vulnerability exists in curl \u003c8.0.0 SFTP implementation causes the tilde (~) character to be wrongly replaced when used as a prefix in the first path element, in addition to its intended use as the first element to indicate a path relative to the user's home directory. Attackers can exploit this flaw to bypass filtering or execute arbitrary code by crafting a path like /~2/foo while accessing a server with a specific user.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-27534",
            "severity": "Unknown",
            "fixedby": "7.74.0-1.3+deb11u8"
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u3",
            "vulnerability": "CVE-2023-27536",
            "namespace": "debian:11",
            "description": "An authentication bypass vulnerability exists libcurl \u003c8.0.0 in the connection reuse feature which can reuse previously established connections with incorrect user permissions due to a failure to check for changes in the CURLOPT_GSSAPI_DELEGATION option. This vulnerability affects krb5/kerberos/negotiate/GSSAPI transfers and could potentially result in unauthorized access to sensitive information. The safest option is to not reuse connections if the CURLOPT_GSSAPI_DELEGATION option has been changed.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-27536",
            "severity": "Unknown",
            "fixedby": "7.74.0-1.3+deb11u8"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52340",
            "namespace": "debian:11",
            "description": "",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52340",
            "severity": "Unknown",
            "fixedby": "5.10.209-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-3108",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 5.16-rc6. kfd_parse_subtype_iolink in drivers/gpu/drm/amd/amdkfd/kfd_crat.c lacks check of the return value of kmemdup().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-3108",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52594",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: ath9k: Fix potential array-index-out-of-bounds read in ath9k_htc_txstatus()  Fix an array-index-out-of-bounds read in ath9k_htc_txstatus(). The bug occurs when txs-\u003ecnt, data from a URB provided by a USB device, is bigger than the size of the array txs-\u003etxstatus, which is HTC_MAX_TX_STATUS. WARN_ON() already checks it, but there is no bug handling code after the check. Make the function return if that is the case.  Found by a modified version of syzkaller.  UBSAN: array-index-out-of-bounds in htc_drv_txrx.c index 13 is out of range for type '__wmi_event_txstatus [12]' Call Trace:  ath9k_htc_txstatus  ath9k_wmi_event_tasklet  tasklet_action_common  __do_softirq  irq_exit_rxu  sysvec_apic_timer_interrupt",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52594",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u3",
            "vulnerability": "CVE-2022-32221",
            "namespace": "debian:11",
            "description": "When doing HTTP(S) transfers, libcurl might erroneously use the read callback (`CURLOPT_READFUNCTION`) to ask for data to send, even when the `CURLOPT_POSTFIELDS` option has been set, if the same handle previously was used to issue a `PUT` request which used that callback. This flaw may surprise the application and cause it to misbehave and either send off the wrong data or use memory after free or similar in the subsequent `POST` request. The problem exists in the logic for a reused handle when it is changed from a PUT to a POST.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-32221",
            "severity": "Unknown",
            "fixedby": "7.74.0-1.3+deb11u5"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-52491",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  media: mtk-jpeg: Fix use after free bug due to error path handling in mtk_jpeg_dec_device_run  In mtk_jpeg_probe, \u0026jpeg-\u003ejob_timeout_work is bound with mtk_jpeg_job_timeout_work.  In mtk_jpeg_dec_device_run, if error happens in mtk_jpeg_set_dec_dst, it will finally start the worker while mark the job as finished by invoking v4l2_m2m_job_finish.  There are two methods to trigger the bug. If we remove the module, it which will call mtk_jpeg_remove to make cleanup. The possible sequence is as follows, which will cause a use-after-free bug.  CPU0                  CPU1 mtk_jpeg_dec_...    |   start worker\t    |                     |mtk_jpeg_job_timeout_work mtk_jpeg_remove     |   v4l2_m2m_release  |     kfree(m2m_dev); |                     |                     | v4l2_m2m_get_curr_priv                     |   m2m_dev-\u003ecurr_ctx //use  If we close the file descriptor, which will call mtk_jpeg_release, it will have a similar sequence.  Fix this bug by starting timeout worker only if started jpegdec worker successfully. Then v4l2_m2m_job_finish will only be called in either mtk_jpeg_job_timeout_work or mtk_jpeg_dec_device_run.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52491",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-6535",
            "namespace": "debian:11",
            "description": "A flaw was found in the Linux kernel's NVMe driver. This issue may allow an unauthenticated malicious actor to send a set of crafted TCP packages when using NVMe over TCP, leading the NVMe driver to a NULL pointer dereference in the NVMe driver, causing kernel panic and a denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-6535",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u3",
            "vulnerability": "CVE-2023-28322",
            "namespace": "debian:11",
            "description": "An information disclosure vulnerability exists in curl \u003cv8.1.0 when doing HTTP(S) transfers, libcurl might erroneously use the read callback (`CURLOPT_READFUNCTION`) to ask for data to send, even when the `CURLOPT_POSTFIELDS` option has been set, if the same handle previously wasused to issue a `PUT` request which used that callback. This flaw may surprise the application and cause it to misbehave and either send off the wrong data or use memory after free or similar in the second transfer. The problem exists in the logic for a reused handle when it is (expected to be) changed from a PUT to a POST.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-28322",
            "severity": "Unknown",
            "fixedby": "7.74.0-1.3+deb11u9"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2022-4129",
            "namespace": "debian:11",
            "description": "A flaw was found in the Linux kernel's Layer 2 Tunneling Protocol (L2TP). A missing lock when clearing sk_user_data can lead to a race condition and NULL pointer dereference. A local user could use this flaw to potentially crash the system causing a denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-4129",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u3",
            "vulnerability": "CVE-2023-38546",
            "namespace": "debian:11",
            "description": "This flaw allows an attacker to insert cookies at will into a running program using libcurl, if the specific series of conditions are met.  libcurl performs transfers. In its API, an application creates \"easy handles\" that are the individual handles for single transfers.  libcurl provides a function call that duplicates en easy handle called [curl_easy_duphandle](https://curl.se/libcurl/c/curl_easy_duphandle.html).  If a transfer has cookies enabled when the handle is duplicated, the cookie-enable state is also cloned - but without cloning the actual cookies. If the source handle did not read any cookies from a specific file on disk, the cloned version of the handle would instead store the file name as `none` (using the four ASCII letters, no quotes).  Subsequent use of the cloned handle that does not explicitly set a source to load cookies from would then inadvertently load cookies from a file named `none` - if such a file exists and is readable in the current directory of the program using libcurl. And if using the correct file format of course.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-38546",
            "severity": "Unknown",
            "fixedby": "7.74.0-1.3+deb11u10"
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u3",
            "vulnerability": "CVE-2023-27538",
            "namespace": "debian:11",
            "description": "An authentication bypass vulnerability exists in libcurl prior to v8.0.0 where it reuses a previously established SSH connection despite the fact that an SSH option was modified, which should have prevented reuse. libcurl maintains a pool of previously used connections to reuse them for subsequent transfers if the configurations match. However, two SSH settings were omitted from the configuration check, allowing them to match easily, potentially leading to the reuse of an inappropriate connection.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-27538",
            "severity": "Unknown",
            "fixedby": "7.74.0-1.3+deb11u8"
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u3",
            "vulnerability": "CVE-2022-43552",
            "namespace": "debian:11",
            "description": "A use after free vulnerability exists in curl \u003c7.87.0. Curl can be asked to *tunnel* virtually all protocols it supports through an HTTP proxy. HTTP proxies can (and often do) deny such tunnel operations. When getting denied to tunnel the specific protocols SMB or TELNET, curl would use a heap-allocated struct after it had been freed, in its transfer shutdown code path.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-43552",
            "severity": "Unknown",
            "fixedby": "7.74.0-1.3+deb11u5"
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u3",
            "vulnerability": "CVE-2023-27535",
            "namespace": "debian:11",
            "description": "An authentication bypass vulnerability exists in libcurl \u003c8.0.0 in the FTP connection reuse feature that can result in wrong credentials being used during subsequent transfers. Previously created connections are kept in a connection pool for reuse if they match the current setup. However, certain FTP settings such as CURLOPT_FTP_ACCOUNT, CURLOPT_FTP_ALTERNATIVE_TO_USER, CURLOPT_FTP_SSL_CCC, and CURLOPT_USE_SSL were not included in the configuration match checks, causing them to match too easily. This could lead to libcurl using the wrong credentials when performing a transfer, potentially allowing unauthorized access to sensitive information.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-27535",
            "severity": "Unknown",
            "fixedby": "7.74.0-1.3+deb11u8"
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u3",
            "vulnerability": "CVE-2024-2398",
            "namespace": "debian:11",
            "description": "When an application tells libcurl it wants to allow HTTP/2 server push, and the amount of received headers for the push surpasses the maximum allowed limit (1000), libcurl aborts the server push. When aborting, libcurl inadvertently does not free all the previously allocated headers and instead leaks the memory.  Further, this error condition fails silently and is therefore not easily detected by an application.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-2398",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2023-1998",
            "namespace": "debian:11",
            "description": "The Linux kernel allows userspace processes to enable mitigations by calling prctl with PR_SET_SPECULATION_CTRL which disables the speculation feature as well as by using seccomp. We had noticed that on VMs of at least one major cloud provider, the kernel still left the victim process exposed to attacks in some cases even after enabling the spectre-BTI mitigation with prctl. The same behavior can be observed on a bare-metal machine when forcing the mitigation to IBRS on boot command line.  This happened because when plain IBRS was enabled (not enhanced IBRS), the kernel had some logic that determined that STIBP was not needed. The IBRS bit implicitly protects against cross-thread branch target injection. However, with legacy IBRS, the IBRS bit was cleared on returning to userspace, due to performance reasons, which disabled the implicit STIBP and left userspace threads vulnerable to cross-thread branch target injection against which STIBP protects.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1998",
            "severity": "Unknown",
            "fixedby": "5.10.178-1"
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.158-2",
            "vulnerability": "CVE-2024-26622",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  tomoyo: fix UAF write bug in tomoyo_write_control()  Since tomoyo_write_control() updates head-\u003ewrite_buf when write() of long lines is requested, we need to fetch head-\u003ewrite_buf after head-\u003eio_sem is held.  Otherwise, concurrent write() requests can cause use-after-free-write and double-free problems.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26622",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "util-linux",
            "featureversion": "2.36.1-8+deb11u1",
            "vulnerability": "CVE-2024-28085",
            "namespace": "debian:11",
            "description": "wall in util-linux through 2.40, often installed with setgid tty permissions, allows escape sequences to be sent to other users' terminals through argv. (Specifically, escape sequences received from stdin are blocked, but escape sequences received from argv are not blocked.) There may be plausible scenarios where this leads to account takeover.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-28085",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "krb5",
            "featureversion": "1.18.3-6+deb11u3",
            "vulnerability": "CVE-2024-26462",
            "namespace": "debian:11",
            "description": "Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/kdc/ndr.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26462",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "krb5",
            "featureversion": "1.18.3-6+deb11u3",
            "vulnerability": "CVE-2023-36054",
            "namespace": "debian:11",
            "description": "lib/kadm5/kadm_rpc_xdr.c in MIT Kerberos 5 (aka krb5) before 1.20.2 and 1.21.x before 1.21.1 frees an uninitialized pointer. A remote authenticated user can trigger a kadmind crash. This occurs because _xdr_kadm5_principal_ent_rec does not validate the relationship between n_key_data and the key_data array count.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-36054",
            "severity": "Unknown",
            "fixedby": "1.18.3-6+deb11u4"
        },
        {
            "featurename": "python3.9",
            "featureversion": "3.9.2-1",
            "vulnerability": "CVE-2023-24329",
            "namespace": "debian:11",
            "description": "An issue in the urllib.parse component of Python before 3.11.4 allows attackers to bypass blocklisting methods by supplying a URL that starts with blank characters.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-24329",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "python3.9",
            "featureversion": "3.9.2-1",
            "vulnerability": "CVE-2023-27043",
            "namespace": "debian:11",
            "description": "The email module of Python through 3.11.3 incorrectly parses e-mail addresses that contain a special character. The wrong portion of an RFC2822 header is identified as the value of the addr-spec. In some applications, an attacker can bypass a protection mechanism in which application access is granted only after verifying receipt of e-mail to a specific domain (e.g., only @company.example.com addresses may be used for signup). This occurs in email/_parseaddr.py in recent versions of Python.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-27043",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "krb5",
            "featureversion": "1.18.3-6+deb11u3",
            "vulnerability": "CVE-2024-26461",
            "namespace": "debian:11",
            "description": "Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/lib/gssapi/krb5/k5sealv3.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26461",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "python3.9",
            "featureversion": "3.9.2-1",
            "vulnerability": "CVE-2022-45061",
            "namespace": "debian:11",
            "description": "An issue was discovered in Python before 3.11.1. An unnecessary quadratic algorithm exists in one path when processing some inputs to the IDNA (RFC 3490) decoder, such that a crafted, unreasonably long name being presented to the decoder could lead to a CPU denial of service. Hostnames are often supplied by remote servers that could be controlled by a malicious actor; in such a scenario, they could trigger excessive CPU consumption on the client attempting to make use of an attacker-supplied supposed hostname. For example, the attack payload could be placed in the Location header of an HTTP response with status code 302. A fix is planned in 3.11.1, 3.10.9, 3.9.16, 3.8.16, and 3.7.16.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-45061",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "python3.9",
            "featureversion": "3.9.2-1",
            "vulnerability": "CVE-2023-40217",
            "namespace": "debian:11",
            "description": "An issue was discovered in Python before 3.8.18, 3.9.x before 3.9.18, 3.10.x before 3.10.13, and 3.11.x before 3.11.5. It primarily affects servers (such as HTTP servers) that use TLS client authentication. If a TLS server-side socket is created, receives data into the socket buffer, and then is closed quickly, there is a brief window where the SSLSocket instance will detect the socket as \"not connected\" and won't initiate a handshake, but buffered data will still be readable from the socket buffer. This data will not be authenticated if the server-side TLS peer is expecting client certificate authentication, and is indistinguishable from valid TLS stream data. Data is limited in size to the amount that will fit in the buffer. (The TLS connection cannot directly be used for data exfiltration because the vulnerable code path requires that the connection be closed on initialization of the SSLSocket.)",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-40217",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "krb5",
            "featureversion": "1.18.3-6+deb11u3",
            "vulnerability": "CVE-2024-26458",
            "namespace": "debian:11",
            "description": "Kerberos 5 (aka krb5) 1.21.2 contains a memory leak in /krb5/src/lib/rpc/pmap_rmt.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26458",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "libxml2",
            "featureversion": "2.9.10+dfsg-6.7+deb11u4",
            "vulnerability": "CVE-2016-3709",
            "namespace": "debian:11",
            "description": "Possible cross-site scripting vulnerability in libxml after commit 960f0e2.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2016-3709",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "libxml2",
            "featureversion": "2.9.10+dfsg-6.7+deb11u4",
            "vulnerability": "CVE-2024-25062",
            "namespace": "debian:11",
            "description": "An issue was discovered in libxml2 before 2.11.7 and 2.12.x before 2.12.5. When using the XML Reader interface with DTD validation and XInclude expansion enabled, processing crafted XML documents can lead to an xmlValidatePopElement use-after-free.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-25062",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "libxml2",
            "featureversion": "2.9.10+dfsg-6.7+deb11u4",
            "vulnerability": "CVE-2023-39615",
            "namespace": "debian:11",
            "description": "Xmlsoft Libxml2 v2.11.0 was discovered to contain an out-of-bounds read via the xmlSAX2StartElement() function at /libxml2/SAX2.c. This vulnerability allows attackers to cause a Denial of Service (DoS) via supplying a crafted XML file. NOTE: the vendor's position is that the product does not support the legacy SAX1 interface with custom callbacks; there is a crash even without crafted input.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-39615",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "libxml2",
            "featureversion": "2.9.10+dfsg-6.7+deb11u4",
            "vulnerability": "CVE-2023-45322",
            "namespace": "debian:11",
            "description": "libxml2 through 2.11.5 has a use-after-free that can only occur after a certain memory allocation fails. This occurs in xmlUnlinkNode in tree.c. NOTE: the vendor's position is \"I don't think these issues are critical enough to warrant a CVE ID ... because an attacker typically can't control when memory allocations fail.\"",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-45322",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "zlib",
            "featureversion": "1:1.2.11.dfsg-2+deb11u2",
            "vulnerability": "CVE-2023-45853",
            "namespace": "debian:11",
            "description": "MiniZip in zlib through 1.3 has an integer overflow and resultant heap-based buffer overflow in zipOpenNewFileInZip4_64 via a long filename, comment, or extra field. NOTE: MiniZip is not a supported part of the zlib product. NOTE: pyminizip through 0.2.6 is also vulnerable because it bundles an affected zlib version, and exposes the applicable MiniZip code through its compress API.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-45853",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "python3.9",
            "featureversion": "3.9.2-1",
            "vulnerability": "CVE-2024-0450",
            "namespace": "debian:11",
            "description": "An issue was found in the CPython `zipfile` module affecting versions 3.12.2, 3.11.8, 3.10.13, 3.9.18, and 3.8.18 and prior.  The zipfile module is vulnerable to “quoted-overlap” zip-bombs which exploit the zip format to create a zip-bomb with a high compression ratio. The fixed versions of CPython makes the zipfile module reject zip archives which overlap entries in the archive.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-0450",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "python3.9",
            "featureversion": "3.9.2-1",
            "vulnerability": "CVE-2020-10735",
            "namespace": "debian:11",
            "description": "A flaw was found in python. In algorithms with quadratic time complexity using non-binary bases, when using int(\"text\"), a system could take 50ms to parse an int string with 100,000 digits and 5s for 1,000,000 digits (float, decimal, int.from_bytes(), and int() for binary bases 2, 4, 8, 16, and 32 are not affected). The highest threat from this vulnerability is to system availability.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-10735",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "nodejs",
            "featureversion": "20.12.0-1nodesource1",
            "vulnerability": "CVE-2023-30590",
            "namespace": "debian:11",
            "description": "The generateKeys() API function returned from crypto.createDiffieHellman() only generates missing (or outdated) keys, that is, it only generates a private key if none has been set yet, but the function is also needed to compute the corresponding public key after calling setPrivateKey(). However, the documentation says this API call: \"Generates private and public Diffie-Hellman key values\".  The documented behavior is very different from the actual behavior, and this difference could easily lead to security issues in applications that use these APIs as the DiffieHellman may be used as the basis for application-level security, implications are consequently broad.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-30590",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "nodejs",
            "featureversion": "20.12.0-1nodesource1",
            "vulnerability": "CVE-2023-46809",
            "namespace": "debian:11",
            "description": "",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-46809",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "nodejs",
            "featureversion": "20.12.0-1nodesource1",
            "vulnerability": "CVE-2024-22025",
            "namespace": "debian:11",
            "description": "A vulnerability in Node.js has been identified, allowing for a Denial of Service (DoS) attack through resource exhaustion when using the fetch() function to retrieve content from an untrusted URL. The vulnerability stems from the fact that the fetch() function in Node.js always decodes Brotli, making it possible for an attacker to cause resource exhaustion when fetching content from an untrusted URL. An attacker controlling the URL passed into fetch() can exploit this vulnerability to exhaust memory, potentially leading to process termination, depending on the system configuration.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-22025",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "apr-util",
            "featureversion": "1.6.1-5",
            "vulnerability": "CVE-2022-25147",
            "namespace": "debian:11",
            "description": "Integer Overflow or Wraparound vulnerability in apr_base64 functions of Apache Portable Runtime Utility (APR-util) allows an attacker to write beyond bounds of a buffer.     This issue affects Apache Portable Runtime Utility (APR-util) 1.6.1 and prior versions.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-25147",
            "severity": "Unknown",
            "fixedby": "1.6.1-5+deb11u1"
        },
        {
            "featurename": "git",
            "featureversion": "1:2.30.2-1",
            "vulnerability": "CVE-2022-39253",
            "namespace": "debian:11",
            "description": "Git is an open source, scalable, distributed revision control system. Versions prior to 2.30.6, 2.31.5, 2.32.4, 2.33.5, 2.34.5, 2.35.5, 2.36.3, and 2.37.4 are subject to exposure of sensitive information to a malicious actor. When performing a local clone (where the source and target of the clone are on the same volume), Git copies the contents of the source's `$GIT_DIR/objects` directory into the destination by either creating hardlinks to the source contents, or copying them (if hardlinks are disabled via `--no-hardlinks`). A malicious actor could convince a victim to clone a repository with a symbolic link pointing at sensitive information on the victim's machine. This can be done either by having the victim clone a malicious repository on the same machine, or having them clone a malicious repository embedded as a bare repository via a submodule from any source, provided they clone with the `--recurse-submodules` option. Git does not create symbolic links in the `$GIT_DIR/objects` directory. The problem has been patched in the versions published on 2022-10-18, and backported to v2.30.x. Potential workarounds: Avoid cloning untrusted repositories using the `--local` optimization when on a shared machine, either by passing the `--no-local` option to `git clone` or cloning from a URL that uses the `file://` scheme. Alternatively, avoid cloning repositories from untrusted sources with `--recurse-submodules` or run `git config --global protocol.file.allow user`.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-39253",
            "severity": "Unknown",
            "fixedby": "1:2.30.2-1+deb11u1"
        },
        {
            "featurename": "git",
            "featureversion": "1:2.30.2-1",
            "vulnerability": "CVE-2023-25652",
            "namespace": "debian:11",
            "description": "Git is a revision control system. Prior to versions 2.30.9, 2.31.8, 2.32.7, 2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1, by feeding specially crafted input to `git apply --reject`, a path outside the working tree can be overwritten with partially controlled contents (corresponding to the rejected hunk(s) from the given patch). A fix is available in versions 2.30.9, 2.31.8, 2.32.7, 2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1. As a workaround, avoid using `git apply` with `--reject` when applying patches from an untrusted source. Use `git apply --stat` to inspect a patch before applying; avoid applying one that create a conflict where a link corresponding to the `*.rej` file exists.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-25652",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "git",
            "featureversion": "1:2.30.2-1",
            "vulnerability": "CVE-2022-41903",
            "namespace": "debian:11",
            "description": "Git is distributed revision control system. `git log` can display commits in an arbitrary format using its `--format` specifiers. This functionality is also exposed to `git archive` via the `export-subst` gitattribute. When processing the padding operators, there is a integer overflow in `pretty.c::format_and_pad_commit()` where a `size_t` is stored improperly as an `int`, and then added as an offset to a `memcpy()`. This overflow can be triggered directly by a user running a command which invokes the commit formatting machinery (e.g., `git log --format=...`). It may also be triggered indirectly through git archive via the export-subst mechanism, which expands format specifiers inside of files within the repository during a git archive. This integer overflow can result in arbitrary heap writes, which may result in arbitrary code execution. The problem has been patched in the versions published on 2023-01-17, going back to v2.30.7. Users are advised to upgrade. Users who are unable to upgrade should disable `git archive` in untrusted repositories. If you expose git archive via `git daemon`, disable it by running `git config --global daemon.uploadArch false`.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-41903",
            "severity": "Unknown",
            "fixedby": "1:2.30.2-1+deb11u1"
        },
        {
            "featurename": "git",
            "featureversion": "1:2.30.2-1",
            "vulnerability": "CVE-2022-39260",
            "namespace": "debian:11",
            "description": "Git is an open source, scalable, distributed revision control system. `git shell` is a restricted login shell that can be used to implement Git's push/pull functionality via SSH. In versions prior to 2.30.6, 2.31.5, 2.32.4, 2.33.5, 2.34.5, 2.35.5, 2.36.3, and 2.37.4, the function that splits the command arguments into an array improperly uses an `int` to represent the number of entries in the array, allowing a malicious actor to intentionally overflow the return value, leading to arbitrary heap writes. Because the resulting array is then passed to `execv()`, it is possible to leverage this attack to gain remote code execution on a victim machine. Note that a victim must first allow access to `git shell` as a login shell in order to be vulnerable to this attack. This problem is patched in versions 2.30.6, 2.31.5, 2.32.4, 2.33.5, 2.34.5, 2.35.5, 2.36.3, and 2.37.4 and users are advised to upgrade to the latest version. Disabling `git shell` access via remote logins is a viable short-term workaround.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-39260",
            "severity": "Unknown",
            "fixedby": "1:2.30.2-1+deb11u1"
        },
        {
            "featurename": "git",
            "featureversion": "1:2.30.2-1",
            "vulnerability": "CVE-2023-29007",
            "namespace": "debian:11",
            "description": "Git is a revision control system. Prior to versions 2.30.9, 2.31.8, 2.32.7, 2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1, a specially crafted `.gitmodules` file with submodule URLs that are longer than 1024 characters can used to exploit a bug in `config.c::git_config_copy_or_rename_section_in_file()`. This bug can be used to inject arbitrary configuration into a user's `$GIT_DIR/config` when attempting to remove the configuration section associated with that submodule. When the attacker injects configuration values which specify executables to run (such as `core.pager`, `core.editor`, `core.sshCommand`, etc.) this can lead to a remote code execution. A fix A fix is available in versions 2.30.9, 2.31.8, 2.32.7, 2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1. As a workaround, avoid running `git submodule deinit` on untrusted repositories or without prior inspection of any submodule sections in `$GIT_DIR/config`.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-29007",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "git",
            "featureversion": "1:2.30.2-1",
            "vulnerability": "CVE-2023-23946",
            "namespace": "debian:11",
            "description": "Git, a revision control system, is vulnerable to path traversal prior to versions 2.39.2, 2.38.4, 2.37.6, 2.36.5, 2.35.7, 2.34.7, 2.33.7, 2.32.6, 2.31.7, and 2.30.8. By feeding a crafted input to `git apply`, a path outside the working tree can be overwritten as the user who is running `git apply`. A fix has been prepared and will appear in v2.39.2, v2.38.4, v2.37.6, v2.36.5, v2.35.7, v2.34.7, v2.33.7, v2.32.6, v2.31.7, and v2.30.8. As a workaround, use `git apply --stat` to inspect a patch before applying; avoid applying one that creates a symbolic link and then creates a file beyond the symbolic link.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-23946",
            "severity": "Unknown",
            "fixedby": "1:2.30.2-1+deb11u2"
        },
        {
            "featurename": "git",
            "featureversion": "1:2.30.2-1",
            "vulnerability": "CVE-2023-25815",
            "namespace": "debian:11",
            "description": "In Git for Windows, the Windows port of Git, no localized messages are shipped with the installer. As a consequence, Git is expected not to localize messages at all, and skips the gettext initialization. However, due to a change in MINGW-packages, the `gettext()` function's implicit initialization no longer uses the runtime prefix but uses the hard-coded path `C:\\mingw64\\share\\locale` to look for localized messages. And since any authenticated user has the permission to create folders in `C:\\` (and since `C:\\mingw64` does not typically exist), it is possible for low-privilege users to place fake messages in that location where `git.exe` will pick them up in version 2.40.1.  This vulnerability is relatively hard to exploit and requires social engineering. For example, a legitimate message at the end of a clone could be maliciously modified to ask the user to direct their web browser to a malicious website, and the user might think that the message comes from Git and is legitimate. It does require local write access by the attacker, though, which makes this attack vector less likely. Version 2.40.1 contains a patch for this issue. Some workarounds are available. Do not work on a Windows machine with shared accounts, or alternatively create a `C:\\mingw64` folder and leave it empty. Users who have administrative rights may remove the permission to create folders in `C:\\`.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-25815",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "git",
            "featureversion": "1:2.30.2-1",
            "vulnerability": "CVE-2022-23521",
            "namespace": "debian:11",
            "description": "Git is distributed revision control system. gitattributes are a mechanism to allow defining attributes for paths. These attributes can be defined by adding a `.gitattributes` file to the repository, which contains a set of file patterns and the attributes that should be set for paths matching this pattern. When parsing gitattributes, multiple integer overflows can occur when there is a huge number of path patterns, a huge number of attributes for a single pattern, or when the declared attribute names are huge. These overflows can be triggered via a crafted `.gitattributes` file that may be part of the commit history. Git silently splits lines longer than 2KB when parsing gitattributes from a file, but not when parsing them from the index. Consequentially, the failure mode depends on whether the file exists in the working tree, the index or both. This integer overflow can result in arbitrary heap reads and writes, which may result in remote code execution. The problem has been patched in the versions published on 2023-01-17, going back to v2.30.7. Users are advised to upgrade. There are no known workarounds for this issue.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-23521",
            "severity": "Unknown",
            "fixedby": "1:2.30.2-1+deb11u1"
        },
        {
            "featurename": "git",
            "featureversion": "1:2.30.2-1",
            "vulnerability": "CVE-2023-22490",
            "namespace": "debian:11",
            "description": "Git is a revision control system. Using a specially-crafted repository, Git prior to versions 2.39.2, 2.38.4, 2.37.6, 2.36.5, 2.35.7, 2.34.7, 2.33.7, 2.32.6, 2.31.7, and 2.30.8 can be tricked into using its local clone optimization even when using a non-local transport. Though Git will abort local clones whose source `$GIT_DIR/objects` directory contains symbolic links, the `objects` directory itself may still be a symbolic link. These two may be combined to include arbitrary files based on known paths on the victim's filesystem within the malicious repository's working copy, allowing for data exfiltration in a similar manner as CVE-2022-39253.  A fix has been prepared and will appear in v2.39.2 v2.38.4 v2.37.6 v2.36.5 v2.35.7 v2.34.7 v2.33.7 v2.32.6, v2.31.7 and v2.30.8. If upgrading is impractical, two short-term workarounds are available. Avoid cloning repositories from untrusted sources with `--recurse-submodules`. Instead, consider cloning repositories without recursively cloning their submodules, and instead run `git submodule update` at each layer. Before doing so, inspect each new `.gitmodules` file to ensure that it does not contain suspicious module URLs.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-22490",
            "severity": "Unknown",
            "fixedby": "1:2.30.2-1+deb11u2"
        },
        {
            "featurename": "ncurses",
            "featureversion": "6.2+20201114-2",
            "vulnerability": "CVE-2023-50495",
            "namespace": "debian:11",
            "description": "NCurse v6.4-20230418 was discovered to contain a segmentation fault via the component _nc_wrap_entry().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-50495",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "ncurses",
            "featureversion": "6.2+20201114-2",
            "vulnerability": "CVE-2023-45918",
            "namespace": "debian:11",
            "description": "ncurses 6.4-20230610 has a NULL pointer dereference in tgetstr in tinfo/lib_termcap.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-45918",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "ncurses",
            "featureversion": "6.2+20201114-2",
            "vulnerability": "CVE-2023-29491",
            "namespace": "debian:11",
            "description": "ncurses before 6.4 20230408, when used by a setuid application, allows local users to trigger security-relevant memory corruption via malformed data in a terminfo database file that is found in $HOME/.terminfo or reached via the TERMINFO or TERM environment variable.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-29491",
            "severity": "Unknown",
            "fixedby": "6.2+20201114-2+deb11u2"
        },
        {
            "featurename": "openssh",
            "featureversion": "1:8.4p1-5+deb11u1",
            "vulnerability": "CVE-2023-38408",
            "namespace": "debian:11",
            "description": "The PKCS#11 feature in ssh-agent in OpenSSH before 9.3p2 has an insufficiently trustworthy search path, leading to remote code execution if an agent is forwarded to an attacker-controlled system. (Code in /usr/lib is not necessarily safe for loading into ssh-agent.) NOTE: this issue exists because of an incomplete fix for CVE-2016-10009.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-38408",
            "severity": "Unknown",
            "fixedby": "1:8.4p1-5+deb11u2"
        },
        {
            "featurename": "perl",
            "featureversion": "5.32.1-4+deb11u2",
            "vulnerability": "CVE-2023-31484",
            "namespace": "debian:11",
            "description": "CPAN.pm before 2.35 does not verify TLS certificates when downloading distributions over HTTPS.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-31484",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "openssh",
            "featureversion": "1:8.4p1-5+deb11u1",
            "vulnerability": "CVE-2023-51385",
            "namespace": "debian:11",
            "description": "In ssh in OpenSSH before 9.6, OS command injection might occur if a user name or host name has shell metacharacters, and this name is referenced by an expansion token in certain situations. For example, an untrusted Git repository can have a submodule with shell metacharacters in a user name or host name.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-51385",
            "severity": "Unknown",
            "fixedby": "1:8.4p1-5+deb11u3"
        },
        {
            "featurename": "libgcrypt20",
            "featureversion": "1.8.7-6",
            "vulnerability": "CVE-2024-2236",
            "namespace": "debian:11",
            "description": "A timing-based side-channel flaw was found in libgcrypt's RSA implementation. This issue may allow a remote attacker to initiate a Bleichenbacher-style attack, which can lead to the decryption of RSA ciphertexts.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-2236",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "sqlite3",
            "featureversion": "3.34.1-3",
            "vulnerability": "CVE-2023-7104",
            "namespace": "debian:11",
            "description": "A vulnerability was found in SQLite SQLite3 up to 3.43.0 and classified as critical. This issue affects the function sessionReadRecord of the file ext/session/sqlite3session.c of the component make alltest Handler. The manipulation leads to heap-based buffer overflow. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-248999.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-7104",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "expat",
            "featureversion": "2.2.10-2+deb11u5",
            "vulnerability": "CVE-2024-28757",
            "namespace": "debian:11",
            "description": "libexpat through 2.6.1 allows an XML Entity Expansion attack when there is isolated use of external parsers (created via XML_ExternalEntityParserCreate).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-28757",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "expat",
            "featureversion": "2.2.10-2+deb11u5",
            "vulnerability": "CVE-2023-52425",
            "namespace": "debian:11",
            "description": "libexpat through 2.5.0 allows a denial of service (resource consumption) because many full reparsings are required in the case of a large token for which multiple buffer fills are needed.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52425",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "libssh2",
            "featureversion": "1.9.0-2",
            "vulnerability": "CVE-2020-22218",
            "namespace": "debian:11",
            "description": "An issue was discovered in function _libssh2_packet_add in libssh2 1.10.0 allows attackers to access out of bounds memory.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-22218",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "gcc-9",
            "featureversion": "9.3.0-22",
            "vulnerability": "CVE-2023-4039",
            "namespace": "debian:11",
            "description": "**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains  that target AArch64 allows an attacker to exploit an existing buffer  overflow in dynamically-sized local variables in your application  without this being detected. This stack-protector failure only applies  to C99-style dynamically-sized local variables or those created using  alloca(). The stack-protector operates as intended for statically-sized  local variables.  The default behavior when the stack-protector  detects an overflow is to terminate your application, resulting in  controlled loss of availability. An attacker who can exploit a buffer  overflow without triggering the stack-protector might be able to change  program flow control to cause an uncontrolled loss of availability or to  go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4039",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "openssl",
            "featureversion": "1.1.1n-0+deb11u3",
            "vulnerability": "CVE-2023-0464",
            "namespace": "debian:11",
            "description": "A security vulnerability has been identified in all supported versions  of OpenSSL related to the verification of X.509 certificate chains that include policy constraints.  Attackers may be able to exploit this vulnerability by creating a malicious certificate chain that triggers exponential use of computational resources, leading to a denial-of-service (DoS) attack on affected systems.  Policy processing is disabled by default but can be enabled by passing the `-policy' argument to the command line utilities or by calling the `X509_VERIFY_PARAM_set1_policies()' function.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-0464",
            "severity": "Unknown",
            "fixedby": "1.1.1n-0+deb11u5"
        },
        {
            "featurename": "openssl",
            "featureversion": "1.1.1n-0+deb11u3",
            "vulnerability": "CVE-2023-0466",
            "namespace": "debian:11",
            "description": "The function X509_VERIFY_PARAM_add0_policy() is documented to implicitly enable the certificate policy check when doing certificate verification. However the implementation of the function does not enable the check which allows certificates with invalid or incorrect policies to pass the certificate verification.  As suddenly enabling the policy check could break existing deployments it was decided to keep the existing behavior of the X509_VERIFY_PARAM_add0_policy() function.  Instead the applications that require OpenSSL to perform certificate policy check need to use X509_VERIFY_PARAM_set1_policies() or explicitly enable the policy check by calling X509_VERIFY_PARAM_set_flags() with the X509_V_FLAG_POLICY_CHECK flag argument.  Certificate policy checks are disabled by default in OpenSSL and are not commonly used by applications.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-0466",
            "severity": "Unknown",
            "fixedby": "1.1.1n-0+deb11u5"
        },
        {
            "featurename": "openssl",
            "featureversion": "1.1.1n-0+deb11u3",
            "vulnerability": "CVE-2023-0215",
            "namespace": "debian:11",
            "description": "The public API function BIO_new_NDEF is a helper function used for streaming ASN.1 data via a BIO. It is primarily used internally to OpenSSL to support the SMIME, CMS and PKCS7 streaming capabilities, but may also be called directly by end user applications.  The function receives a BIO from the caller, prepends a new BIO_f_asn1 filter BIO onto the front of it to form a BIO chain, and then returns the new head of the BIO chain to the caller. Under certain conditions, for example if a CMS recipient public key is invalid, the new filter BIO is freed and the function returns a NULL result indicating a failure. However, in this case, the BIO chain is not properly cleaned up and the BIO passed by the caller still retains internal pointers to the previously freed filter BIO. If the caller then goes on to call BIO_pop() on the BIO then a use-after-free will occur. This will most likely result in a crash.    This scenario occurs directly in the internal function B64_write_ASN1() which may cause BIO_new_NDEF() to be called and will subsequently call BIO_pop() on the BIO. This internal function is in turn called by the public API functions PEM_write_bio_ASN1_stream, PEM_write_bio_CMS_stream, PEM_write_bio_PKCS7_stream, SMIME_write_ASN1, SMIME_write_CMS and SMIME_write_PKCS7.  Other public API functions that may be impacted by this include i2d_ASN1_bio_stream, BIO_new_CMS, BIO_new_PKCS7, i2d_CMS_bio_stream and i2d_PKCS7_bio_stream.  The OpenSSL cms and smime command line applications are similarly affected.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-0215",
            "severity": "Unknown",
            "fixedby": "1.1.1n-0+deb11u4"
        },
        {
            "featurename": "openssl",
            "featureversion": "1.1.1n-0+deb11u3",
            "vulnerability": "CVE-2024-0727",
            "namespace": "debian:11",
            "description": "Issue summary: Processing a maliciously formatted PKCS12 file may lead OpenSSL to crash leading to a potential Denial of Service attack  Impact summary: Applications loading files in the PKCS12 format from untrusted sources might terminate abruptly.  A file in PKCS12 format can contain certificates and keys and may come from an untrusted source. The PKCS12 specification allows certain fields to be NULL, but OpenSSL does not correctly check for this case. This can lead to a NULL pointer dereference that results in OpenSSL crashing. If an application processes PKCS12 files from an untrusted source using the OpenSSL APIs then that application will be vulnerable to this issue.  OpenSSL APIs that are vulnerable to this are: PKCS12_parse(), PKCS12_unpack_p7data(), PKCS12_unpack_p7encdata(), PKCS12_unpack_authsafes() and PKCS12_newpass().  We have also fixed a similar issue in SMIME_write_PKCS7(). However since this function is related to writing data we do not consider it security significant.  The FIPS modules in 3.2, 3.1 and 3.0 are not affected by this issue.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-0727",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "openssl",
            "featureversion": "1.1.1n-0+deb11u3",
            "vulnerability": "CVE-2023-2650",
            "namespace": "debian:11",
            "description": "Issue summary: Processing some specially crafted ASN.1 object identifiers or data containing them may be very slow.  Impact summary: Applications that use OBJ_obj2txt() directly, or use any of the OpenSSL subsystems OCSP, PKCS7/SMIME, CMS, CMP/CRMF or TS with no message size limit may experience notable to very long delays when processing those messages, which may lead to a Denial of Service.  An OBJECT IDENTIFIER is composed of a series of numbers - sub-identifiers - most of which have no size limit.  OBJ_obj2txt() may be used to translate an ASN.1 OBJECT IDENTIFIER given in DER encoding form (using the OpenSSL type ASN1_OBJECT) to its canonical numeric text form, which are the sub-identifiers of the OBJECT IDENTIFIER in decimal form, separated by periods.  When one of the sub-identifiers in the OBJECT IDENTIFIER is very large (these are sizes that are seen as absurdly large, taking up tens or hundreds of KiBs), the translation to a decimal number in text may take a very long time.  The time complexity is O(n^2) with 'n' being the size of the sub-identifiers in bytes (*).  With OpenSSL 3.0, support to fetch cryptographic algorithms using names / identifiers in string form was introduced.  This includes using OBJECT IDENTIFIERs in canonical numeric text form as identifiers for fetching algorithms.  Such OBJECT IDENTIFIERs may be received through the ASN.1 structure AlgorithmIdentifier, which is commonly used in multiple protocols to specify what cryptographic algorithm should be used to sign or verify, encrypt or decrypt, or digest passed data.  Applications that call OBJ_obj2txt() directly with untrusted data are affected, with any version of OpenSSL.  If the use is for the mere purpose of display, the severity is considered low.  In OpenSSL 3.0 and newer, this affects the subsystems OCSP, PKCS7/SMIME, CMS, CMP/CRMF or TS.  It also impacts anything that processes X.509 certificates, including simple things like verifying its signature.  The impact on TLS is relatively low, because all versions of OpenSSL have a 100KiB limit on the peer's certificate chain.  Additionally, this only impacts clients, or servers that have explicitly enabled client authentication.  In OpenSSL 1.1.1 and 1.0.2, this only affects displaying diverse objects, such as X.509 certificates.  This is assumed to not happen in such a way that it would cause a Denial of Service, so these versions are considered not affected by this issue in such a way that it would be cause for concern, and the severity is therefore considered low.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-2650",
            "severity": "Unknown",
            "fixedby": "1.1.1n-0+deb11u5"
        },
        {
            "featurename": "curl",
            "featureversion": "7.74.0-1.3+deb11u11",
            "vulnerability": "CVE-2024-2398",
            "namespace": "debian:11",
            "description": "When an application tells libcurl it wants to allow HTTP/2 server push, and the amount of received headers for the push surpasses the maximum allowed limit (1000), libcurl aborts the server push. When aborting, libcurl inadvertently does not free all the previously allocated headers and instead leaks the memory.  Further, this error condition fails silently and is therefore not easily detected by an application.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-2398",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "openssl",
            "featureversion": "1.1.1n-0+deb11u3",
            "vulnerability": "CVE-2023-0465",
            "namespace": "debian:11",
            "description": "Applications that use a non-default option when verifying certificates may be vulnerable to an attack from a malicious CA to circumvent certain checks.  Invalid certificate policies in leaf certificates are silently ignored by OpenSSL and other certificate policy checks are skipped for that certificate. A malicious CA could use this to deliberately assert invalid certificate policies in order to circumvent policy checking on the certificate altogether.  Policy processing is disabled by default but can be enabled by passing the `-policy' argument to the command line utilities or by calling the `X509_VERIFY_PARAM_set1_policies()' function.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-0465",
            "severity": "Unknown",
            "fixedby": "1.1.1n-0+deb11u5"
        },
        {
            "featurename": "openssl",
            "featureversion": "1.1.1n-0+deb11u3",
            "vulnerability": "CVE-2023-0286",
            "namespace": "debian:11",
            "description": "There is a type confusion vulnerability relating to X.400 address processing inside an X.509 GeneralName. X.400 addresses were parsed as an ASN1_STRING but the public structure definition for GENERAL_NAME incorrectly specified the type of the x400Address field as ASN1_TYPE. This field is subsequently interpreted by the OpenSSL function GENERAL_NAME_cmp as an ASN1_TYPE rather than an ASN1_STRING.  When CRL checking is enabled (i.e. the application sets the X509_V_FLAG_CRL_CHECK flag), this vulnerability may allow an attacker to pass arbitrary pointers to a memcmp call, enabling them to read memory contents or enact a denial of service. In most cases, the attack requires the attacker to provide both the certificate chain and CRL, neither of which need to have a valid signature. If the attacker only controls one of these inputs, the other input must already contain an X.400 address as a CRL distribution point, which is uncommon. As such, this vulnerability is most likely to only affect applications which have implemented their own functionality for retrieving CRLs over a network.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-0286",
            "severity": "Unknown",
            "fixedby": "1.1.1n-0+deb11u4"
        },
        {
            "featurename": "openssl",
            "featureversion": "1.1.1n-0+deb11u3",
            "vulnerability": "CVE-2023-3817",
            "namespace": "debian:11",
            "description": "Issue summary: Checking excessively long DH keys or parameters may be very slow.  Impact summary: Applications that use the functions DH_check(), DH_check_ex() or EVP_PKEY_param_check() to check a DH key or DH parameters may experience long delays. Where the key or parameters that are being checked have been obtained from an untrusted source this may lead to a Denial of Service.  The function DH_check() performs various checks on DH parameters. After fixing CVE-2023-3446 it was discovered that a large q parameter value can also trigger an overly long computation during some of these checks. A correct q value, if present, cannot be larger than the modulus p parameter, thus it is unnecessary to perform these checks if q is larger than p.  An application that calls DH_check() and supplies a key or parameters obtained from an untrusted source could be vulnerable to a Denial of Service attack.  The function DH_check() is itself called by a number of other OpenSSL functions. An application calling any of those other functions may similarly be affected. The other functions affected by this are DH_check_ex() and EVP_PKEY_param_check().  Also vulnerable are the OpenSSL dhparam and pkeyparam command line applications when using the \"-check\" option.  The OpenSSL SSL/TLS implementation is not affected by this issue.  The OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3817",
            "severity": "Unknown",
            "fixedby": "1.1.1v-0~deb11u1"
        },
        {
            "featurename": "tar",
            "featureversion": "1.34+dfsg-1",
            "vulnerability": "CVE-2023-39804",
            "namespace": "debian:11",
            "description": "In GNU tar before 1.35, mishandled extension attributes in a PAX archive can lead to an application crash in xheader.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-39804",
            "severity": "Unknown",
            "fixedby": "1.34+dfsg-1+deb11u1"
        },
        {
            "featurename": "openssl",
            "featureversion": "1.1.1n-0+deb11u3",
            "vulnerability": "CVE-2023-3446",
            "namespace": "debian:11",
            "description": "Issue summary: Checking excessively long DH keys or parameters may be very slow.  Impact summary: Applications that use the functions DH_check(), DH_check_ex() or EVP_PKEY_param_check() to check a DH key or DH parameters may experience long delays. Where the key or parameters that are being checked have been obtained from an untrusted source this may lead to a Denial of Service.  The function DH_check() performs various checks on DH parameters. One of those checks confirms that the modulus ('p' parameter) is not too large. Trying to use a very large modulus is slow and OpenSSL will not normally use a modulus which is over 10,000 bits in length.  However the DH_check() function checks numerous aspects of the key or parameters that have been supplied. Some of those checks use the supplied modulus value even if it has already been found to be too large.  An application that calls DH_check() and supplies a key or parameters obtained from an untrusted source could be vulernable to a Denial of Service attack.  The function DH_check() is itself called by a number of other OpenSSL functions. An application calling any of those other functions may similarly be affected. The other functions affected by this are DH_check_ex() and EVP_PKEY_param_check().  Also vulnerable are the OpenSSL dhparam and pkeyparam command line applications when using the '-check' option.  The OpenSSL SSL/TLS implementation is not affected by this issue. The OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3446",
            "severity": "Unknown",
            "fixedby": "1.1.1v-0~deb11u1"
        },
        {
            "featurename": "openssl",
            "featureversion": "1.1.1n-0+deb11u3",
            "vulnerability": "CVE-2022-4304",
            "namespace": "debian:11",
            "description": "A timing based side channel exists in the OpenSSL RSA Decryption implementation which could be sufficient to recover a plaintext across a network in a Bleichenbacher style attack. To achieve a successful decryption an attacker would have to be able to send a very large number of trial messages for decryption. The vulnerability affects all RSA padding modes: PKCS#1 v1.5, RSA-OEAP and RSASVE.  For example, in a TLS connection, RSA is commonly used by a client to send an encrypted pre-master secret to the server. An attacker that had observed a genuine connection between a client and a server could use this flaw to send trial messages to the server and record the time taken to process them. After a sufficiently large number of messages the attacker could recover the pre-master secret used for the original connection and thus be able to decrypt the application data sent over that connection.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-4304",
            "severity": "Unknown",
            "fixedby": "1.1.1n-0+deb11u4"
        },
        {
            "featurename": "openssl",
            "featureversion": "1.1.1n-0+deb11u3",
            "vulnerability": "CVE-2023-5678",
            "namespace": "debian:11",
            "description": "Issue summary: Generating excessively long X9.42 DH keys or checking excessively long X9.42 DH keys or parameters may be very slow.  Impact summary: Applications that use the functions DH_generate_key() to generate an X9.42 DH key may experience long delays.  Likewise, applications that use DH_check_pub_key(), DH_check_pub_key_ex() or EVP_PKEY_public_check() to check an X9.42 DH key or X9.42 DH parameters may experience long delays. Where the key or parameters that are being checked have been obtained from an untrusted source this may lead to a Denial of Service.  While DH_check() performs all the necessary checks (as of CVE-2023-3817), DH_check_pub_key() doesn't make any of these checks, and is therefore vulnerable for excessively large P and Q parameters.  Likewise, while DH_generate_key() performs a check for an excessively large P, it doesn't check for an excessively large Q.  An application that calls DH_generate_key() or DH_check_pub_key() and supplies a key or parameters obtained from an untrusted source could be vulnerable to a Denial of Service attack.  DH_generate_key() and DH_check_pub_key() are also called by a number of other OpenSSL functions.  An application calling any of those other functions may similarly be affected.  The other functions affected by this are DH_check_pub_key_ex(), EVP_PKEY_public_check(), and EVP_PKEY_generate().  Also vulnerable are the OpenSSL pkey command line application when using the \"-pubcheck\" option, as well as the OpenSSL genpkey command line application.  The OpenSSL SSL/TLS implementation is not affected by this issue.  The OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-5678",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "openssl",
            "featureversion": "1.1.1n-0+deb11u3",
            "vulnerability": "CVE-2022-4450",
            "namespace": "debian:11",
            "description": "The function PEM_read_bio_ex() reads a PEM file from a BIO and parses and decodes the \"name\" (e.g. \"CERTIFICATE\"), any header data and the payload data. If the function succeeds then the \"name_out\", \"header\" and \"data\" arguments are populated with pointers to buffers containing the relevant decoded data. The caller is responsible for freeing those buffers. It is possible to construct a PEM file that results in 0 bytes of payload data. In this case PEM_read_bio_ex() will return a failure code but will populate the header argument with a pointer to a buffer that has already been freed. If the caller also frees this buffer then a double free will occur. This will most likely lead to a crash. This could be exploited by an attacker who has the ability to supply malicious PEM files for parsing to achieve a denial of service attack.  The functions PEM_read_bio() and PEM_read() are simple wrappers around PEM_read_bio_ex() and therefore these functions are also directly affected.  These functions are also called indirectly by a number of other OpenSSL functions including PEM_X509_INFO_read_bio_ex() and SSL_CTX_use_serverinfo_file() which are also vulnerable. Some OpenSSL internal uses of these functions are not vulnerable because the caller does not free the header argument if PEM_read_bio_ex() returns a failure code. These locations include the PEM_read_bio_TYPE() functions as well as the decoders introduced in OpenSSL 3.0.  The OpenSSL asn1parse command line application is also impacted by this issue.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-4450",
            "severity": "Unknown",
            "fixedby": "1.1.1n-0+deb11u4"
        },
        {
            "featurename": "pam",
            "featureversion": "1.4.0-9+deb11u1",
            "vulnerability": "CVE-2024-22365",
            "namespace": "debian:11",
            "description": "linux-pam (aka Linux PAM) before 1.6.0 allows attackers to cause a denial of service (blocked login process) via mkfifo because the openat call (for protect_dir) lacks O_DIRECTORY.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-22365",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "libarchive",
            "featureversion": "3.4.3-2+deb11u1",
            "vulnerability": "CVE-2023-30571",
            "namespace": "debian:11",
            "description": "Libarchive through 3.6.2 can cause directories to have world-writable permissions. The umask() call inside archive_write_disk_posix.c changes the umask of the whole process for a very short period of time; a race condition with another thread can lead to a permanent umask 0 setting. Such a race condition could lead to implicit directory creation with permissions 0777 (without the sticky bit), which means that any low-privileged local user can delete and rename files inside those directories.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-30571",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "libarchive",
            "featureversion": "3.4.3-2+deb11u1",
            "vulnerability": "CVE-2022-36227",
            "namespace": "debian:11",
            "description": "In libarchive before 3.6.2, the software does not check for an error after calling calloc function that can return with a NULL pointer if the function fails, which leads to a resultant NULL pointer dereference. NOTE: the discoverer cites this CWE-476 remark but third parties dispute the code-execution impact: \"In rare circumstances, when NULL is equivalent to the 0x0 memory address and privileged code can access it, then writing or reading memory is possible, which may lead to code execution.\"",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-36227",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "procps",
            "featureversion": "2:3.3.17-5",
            "vulnerability": "CVE-2023-4016",
            "namespace": "debian:11",
            "description": "Under some circumstances, this weakness allows a user who has access to run the “ps” utility on a machine, the ability to write almost unlimited amounts of unfiltered data into the process heap.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4016",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "gcc-10",
            "featureversion": "10.2.1-6",
            "vulnerability": "CVE-2023-4039",
            "namespace": "debian:11",
            "description": "**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains  that target AArch64 allows an attacker to exploit an existing buffer  overflow in dynamically-sized local variables in your application  without this being detected. This stack-protector failure only applies  to C99-style dynamically-sized local variables or those created using  alloca(). The stack-protector operates as intended for statically-sized  local variables.  The default behavior when the stack-protector  detects an overflow is to terminate your application, resulting in  controlled loss of availability. An attacker who can exploit a buffer  overflow without triggering the stack-protector might be able to change  program flow control to cause an uncontrolled loss of availability or to  go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4039",
            "severity": "Unknown",
            "fixedby": ""
        }
    ]
}