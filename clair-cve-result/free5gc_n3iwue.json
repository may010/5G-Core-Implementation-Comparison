{
    "image": "free5gc/n3iwue",
    "unapproved": [
        "CVE-2023-5678",
        "CVE-2010-0928",
        "CVE-2007-6755",
        "CVE-2024-0727",
        "CVE-2023-2603",
        "CVE-2023-2602",
        "CVE-2022-3219",
        "CVE-2018-19519",
        "CVE-2023-1801",
        "CVE-2019-1010220",
        "CVE-2022-31782",
        "CVE-2017-16231",
        "CVE-2019-20838",
        "CVE-2017-7246",
        "CVE-2017-11164",
        "CVE-2017-7245",
        "CVE-2022-4899",
        "CVE-2023-4039",
        "CVE-2021-33294",
        "CVE-2024-25260",
        "CVE-2022-3715",
        "CVE-2024-26622",
        "CVE-2019-19378",
        "CVE-2023-6535",
        "CVE-2023-52491",
        "CVE-2023-52594",
        "CVE-2007-3719",
        "CVE-2022-3108",
        "CVE-2024-21803",
        "CVE-2024-26601",
        "CVE-2019-12382",
        "CVE-2023-52429",
        "CVE-2022-1247",
        "CVE-2022-1280",
        "CVE-2022-3344",
        "CVE-2019-12455",
        "CVE-2024-26629",
        "CVE-2022-48628",
        "CVE-2022-2961",
        "CVE-2024-0564",
        "CVE-2022-45884",
        "CVE-2023-52488",
        "CVE-2022-3566",
        "CVE-2023-37454",
        "CVE-2023-52489",
        "CVE-2021-47028",
        "CVE-2024-26627",
        "CVE-2023-23039",
        "CVE-2023-6240",
        "CVE-2021-39686",
        "CVE-2019-12378",
        "CVE-2023-52569",
        "CVE-2023-52597",
        "CVE-2023-0597",
        "CVE-2019-16231",
        "CVE-2023-52587",
        "CVE-2024-26614",
        "CVE-2022-44032",
        "CVE-2020-35501",
        "CVE-2022-3523",
        "CVE-2022-43945",
        "CVE-2023-52479",
        "CVE-2023-52589",
        "CVE-2024-24857",
        "CVE-2021-4149",
        "CVE-2022-38457",
        "CVE-2021-3669",
        "CVE-2024-26595",
        "CVE-2023-3397",
        "CVE-2024-23851",
        "CVE-2023-52595",
        "CVE-2011-4915",
        "CVE-2019-12380",
        "CVE-2023-52606",
        "CVE-2023-52452",
        "CVE-2019-12456",
        "CVE-2024-25741",
        "CVE-2024-0607",
        "CVE-2005-3660",
        "CVE-2023-4010",
        "CVE-2016-8660",
        "CVE-2022-45885",
        "CVE-2024-24861",
        "CVE-2024-26585",
        "CVE-2013-7445",
        "CVE-2024-26641",
        "CVE-2019-15213",
        "CVE-2024-23850",
        "CVE-2023-52484",
        "CVE-2019-16089",
        "CVE-2014-9900",
        "CVE-2023-52498",
        "CVE-2024-26600",
        "CVE-2023-52517",
        "CVE-2014-9892",
        "CVE-2024-22386",
        "CVE-2021-4204",
        "CVE-2023-52447",
        "CVE-2023-52591",
        "CVE-2024-26610",
        "CVE-2023-6270",
        "CVE-2023-52482",
        "CVE-2024-0565",
        "CVE-2022-44033",
        "CVE-2022-41848",
        "CVE-2023-52590",
        "CVE-2021-47094",
        "CVE-2024-0841",
        "CVE-2023-52572",
        "CVE-2023-52614",
        "CVE-2023-52600",
        "CVE-2011-4917",
        "CVE-2008-2544",
        "CVE-2021-33061",
        "CVE-2019-15794",
        "CVE-2019-19814",
        "CVE-2024-26636",
        "CVE-2021-26934",
        "CVE-2024-26639",
        "CVE-2019-16233",
        "CVE-2021-3847",
        "CVE-2023-6610",
        "CVE-2024-26589",
        "CVE-2024-26640",
        "CVE-2020-12363",
        "CVE-2024-26581",
        "CVE-2022-40133",
        "CVE-2023-52476",
        "CVE-2018-1121",
        "CVE-2015-2877",
        "CVE-2023-52531",
        "CVE-2023-52617",
        "CVE-2023-52585",
        "CVE-2023-31083",
        "CVE-2023-52434",
        "CVE-2024-25740",
        "CVE-2023-52619",
        "CVE-2024-24858",
        "CVE-2019-16234",
        "CVE-2021-47070",
        "CVE-2023-52494",
        "CVE-2019-16230",
        "CVE-2024-26602",
        "CVE-2024-26607",
        "CVE-2023-52561",
        "CVE-2023-1192",
        "CVE-2024-26643",
        "CVE-2023-1075",
        "CVE-2022-3567",
        "CVE-2022-25265",
        "CVE-2024-26615",
        "CVE-2023-4133",
        "CVE-2024-26584",
        "CVE-2023-52497",
        "CVE-2024-23848",
        "CVE-2024-24855",
        "CVE-2020-36694",
        "CVE-2021-47101",
        "CVE-2023-52603",
        "CVE-2019-19070",
        "CVE-2023-52530",
        "CVE-2022-0480",
        "CVE-2023-52601",
        "CVE-2024-26583",
        "CVE-2023-52602",
        "CVE-2023-52435",
        "CVE-2024-24864",
        "CVE-2021-47105",
        "CVE-2022-0400",
        "CVE-2024-24859",
        "CVE-2023-52607",
        "CVE-2023-23003",
        "CVE-2023-31081",
        "CVE-2023-52596",
        "CVE-2023-23000",
        "CVE-2022-3114",
        "CVE-2022-48626",
        "CVE-2017-13694",
        "CVE-2021-47076",
        "CVE-2023-28746",
        "CVE-2023-31085",
        "CVE-2023-0160",
        "CVE-2024-26593",
        "CVE-2023-52584",
        "CVE-2021-3714",
        "CVE-2022-4543",
        "CVE-2023-22995",
        "CVE-2022-27672",
        "CVE-2019-16229",
        "CVE-2023-52618",
        "CVE-2020-12362",
        "CVE-2021-3864",
        "CVE-2023-52610",
        "CVE-2023-4134",
        "CVE-2010-4563",
        "CVE-2024-23849",
        "CVE-2023-52493",
        "CVE-2023-47233",
        "CVE-2020-12364",
        "CVE-2010-5321",
        "CVE-2021-46987",
        "CVE-2023-52458",
        "CVE-2004-0230",
        "CVE-2016-10723",
        "CVE-2023-52604",
        "CVE-2017-13693",
        "CVE-2019-16232",
        "CVE-2022-44034",
        "CVE-2023-52616",
        "CVE-2021-47036",
        "CVE-2019-12379",
        "CVE-2024-0340",
        "CVE-2022-0500",
        "CVE-2023-52593",
        "CVE-2023-52508",
        "CVE-2024-1151",
        "CVE-2023-52608",
        "CVE-2023-52598",
        "CVE-2019-12381",
        "CVE-2024-26606",
        "CVE-2023-52481",
        "CVE-2024-23307",
        "CVE-2023-52485",
        "CVE-2024-2193",
        "CVE-2021-47014",
        "CVE-2023-52492",
        "CVE-2008-4609",
        "CVE-2023-52480",
        "CVE-2023-31082",
        "CVE-2023-4569",
        "CVE-2011-4916",
        "CVE-2023-52615",
        "CVE-2018-17977",
        "CVE-2020-11725",
        "CVE-2023-52620",
        "CVE-2024-25739",
        "CVE-2023-52586",
        "CVE-2020-24504",
        "CVE-2019-11191",
        "CVE-2019-20794",
        "CVE-2024-26625",
        "CVE-2023-52583",
        "CVE-2021-4023",
        "CVE-2023-52486",
        "CVE-2023-52599",
        "CVE-2021-32078",
        "CVE-2023-52511",
        "CVE-2012-4542",
        "CVE-2024-26642",
        "CVE-2023-3640",
        "CVE-2021-46926",
        "CVE-2020-14304",
        "CVE-2024-26624",
        "CVE-2021-46937",
        "CVE-2023-52588",
        "CVE-2019-19449",
        "CVE-2023-7042",
        "CVE-2021-47037",
        "CVE-2024-22099",
        "CVE-2017-0630",
        "CVE-2023-26242",
        "CVE-2018-12928",
        "CVE-2024-26635",
        "CVE-2024-26651",
        "CVE-2024-26644",
        "CVE-2023-52622",
        "CVE-2023-52621",
        "CVE-2024-26647",
        "CVE-2023-52625",
        "CVE-2023-52627",
        "CVE-2021-47178",
        "CVE-2023-52624",
        "CVE-2024-26648",
        "CVE-2024-26646",
        "CVE-2023-52623",
        "CVE-2024-26645",
        "CVE-2016-2781",
        "CVE-2017-18018",
        "CVE-2021-4214",
        "CVE-2019-6129",
        "CVE-2017-9937",
        "CVE-2005-2541",
        "CVE-2024-0553",
        "CVE-2011-3389",
        "CVE-2024-28835",
        "CVE-2024-28834",
        "CVE-2024-0567",
        "CVE-2024-26458",
        "CVE-2024-26461",
        "CVE-2018-5709",
        "CVE-2024-26462",
        "CVE-2023-4016",
        "CVE-2021-33560",
        "CVE-2018-6829",
        "CVE-2024-2236",
        "CVE-2022-0563",
        "CVE-2024-28085",
        "CVE-2016-1585",
        "CVE-2012-2663",
        "CVE-2019-1010023",
        "CVE-2019-1010022",
        "CVE-2023-4813",
        "CVE-2019-1010024",
        "CVE-2019-1010025",
        "CVE-2018-20796",
        "CVE-2019-9192",
        "CVE-2010-4756",
        "CVE-2023-4806",
        "CVE-2011-4116",
        "CVE-2023-31486",
        "CVE-2023-31484",
        "CVE-2020-16156",
        "CVE-2019-8457",
        "CVE-2023-28486",
        "CVE-2022-43995",
        "CVE-2023-28487",
        "CVE-2023-42465",
        "CVE-2005-1119",
        "CVE-2023-3316",
        "CVE-2017-17973",
        "CVE-2023-26966",
        "CVE-2023-26965",
        "CVE-2017-9117",
        "CVE-2023-2908",
        "CVE-2022-1210",
        "CVE-2022-1056",
        "CVE-2023-52355",
        "CVE-2022-40090",
        "CVE-2023-6277",
        "CVE-2017-16232",
        "CVE-2017-5563",
        "CVE-2023-52356",
        "CVE-2023-30775",
        "CVE-2023-1916",
        "CVE-2023-25433",
        "CVE-2023-6228",
        "CVE-2018-10126",
        "CVE-2023-3164",
        "CVE-2023-3618",
        "CVE-2011-3374",
        "CVE-2024-22365",
        "CVE-2022-3534",
        "CVE-2021-45941",
        "CVE-2021-45940",
        "CVE-2022-3606",
        "CVE-2023-31437",
        "CVE-2023-50387",
        "CVE-2023-31438",
        "CVE-2020-13529",
        "CVE-2023-7008",
        "CVE-2023-50868",
        "CVE-2023-31439",
        "CVE-2013-4392",
        "CVE-2023-45918",
        "CVE-2023-50495",
        "CVE-2023-45853",
        "CVE-2021-46822",
        "CVE-2021-36087",
        "CVE-2021-36084",
        "CVE-2021-36085",
        "CVE-2021-36086",
        "CVE-2022-41409",
        "CVE-2022-1304",
        "CVE-2019-19882",
        "CVE-2023-29383",
        "CVE-2013-4235",
        "CVE-2007-5686",
        "CVE-2023-4641",
        "CVE-2021-38115",
        "CVE-2021-40145",
        "CVE-2021-40812",
        "CVE-2013-0340",
        "CVE-2023-52425",
        "CVE-2024-28757",
        "CVE-2023-52426"
    ],
    "vulnerabilities": [
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2019-19814",
            "namespace": "debian:11",
            "description": "In the Linux kernel 5.0.21, mounting a crafted f2fs filesystem image can cause __remove_dirty_segment slab-out-of-bounds write access because an array is bounded by the number of dirty types (8) but the array index can exceed this.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-19814",
            "severity": "Critical",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2013-7445",
            "namespace": "debian:11",
            "description": "The Direct Rendering Manager (DRM) subsystem in the Linux kernel through 4.x mishandles requests for Graphics Execution Manager (GEM) objects, which allows context-dependent attackers to cause a denial of service (memory consumption) via an application that processes graphics data, as demonstrated by JavaScript code that creates many CANVAS elements for rendering by Chrome or Firefox.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2013-7445",
            "severity": "High",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2021-3847",
            "namespace": "debian:11",
            "description": "An unauthorized access to the execution of the setuid file with capabilities flaw in the Linux kernel OverlayFS subsystem was found in the way user copying a capable file from a nosuid mount into another mount. A local user could use this flaw to escalate their privileges on the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-3847",
            "severity": "High",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2019-15794",
            "namespace": "debian:11",
            "description": "Overlayfs in the Linux kernel and shiftfs, a non-upstream patch to the Linux kernel included in the Ubuntu 5.0 and 5.3 kernel series, both replace vma-\u003evm_file in their mmap handlers. On error the original value is not restored, and the reference is put for the file to which vm_file points. On upstream kernels this is not an issue, as no callers dereference vm_file following after call_mmap() returns an error. However, the aufs patchs change mmap_region() to replace the fput() using a local variable with vma_fput(), which will fput() vm_file, leading to a refcount underflow.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-15794",
            "severity": "High",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2021-39686",
            "namespace": "debian:11",
            "description": "In several functions of binder.c, there is a possible way to represent the wrong domain to SELinux due to a race condition. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-200688826References: Upstream kernel",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-39686",
            "severity": "High",
            "fixedby": ""
        },
        {
            "featurename": "libjpeg-turbo",
            "featureversion": "1:2.0.6-4",
            "vulnerability": "CVE-2021-46822",
            "namespace": "debian:11",
            "description": "The PPM reader in libjpeg-turbo through 2.0.90 mishandles use of tjLoadImage for loading a 16-bit binary PPM file into a grayscale buffer and loading a 16-bit binary PGM file into an RGB buffer. This is related to a heap-based buffer overflow in the get_word_rgb_row function in rdppm.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-46822",
            "severity": "Medium",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2019-15213",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel before 5.2.3. There is a use-after-free caused by a malicious USB device in the drivers/media/usb/dvb-usb/dvb-usb-init.c driver.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-15213",
            "severity": "Medium",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2019-16089",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 5.2.13. nbd_genl_status in drivers/block/nbd.c does not check the nla_nest_start_noflag return value.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-16089",
            "severity": "Medium",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2020-12362",
            "namespace": "debian:11",
            "description": "Integer overflow in the firmware for some Intel(R) Graphics Drivers for Windows * before version 26.20.100.7212 and before Linux kernel version 5.5 may allow a privileged user to potentially enable an escalation of privilege via local access.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-12362",
            "severity": "Medium",
            "fixedby": ""
        },
        {
            "featurename": "libbpf",
            "featureversion": "0.3-2",
            "vulnerability": "CVE-2021-45940",
            "namespace": "debian:11",
            "description": "libbpf 0.6.0 and 0.6.1 has a heap-based buffer overflow (4 bytes) in __bpf_object__open (called from bpf_object__open_mem and bpf-object-fuzzer.c).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-45940",
            "severity": "Medium",
            "fixedby": ""
        },
        {
            "featurename": "libbpf",
            "featureversion": "0.3-2",
            "vulnerability": "CVE-2021-45941",
            "namespace": "debian:11",
            "description": "libbpf 0.6.0 and 0.6.1 has a heap-based buffer overflow (8 bytes) in __bpf_object__open (called from bpf_object__open_mem and bpf-object-fuzzer.c).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-45941",
            "severity": "Medium",
            "fixedby": ""
        },
        {
            "featurename": "perl",
            "featureversion": "5.32.1-4+deb11u3",
            "vulnerability": "CVE-2020-16156",
            "namespace": "debian:11",
            "description": "CPAN 2.28 allows Signature Verification Bypass.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-16156",
            "severity": "Medium",
            "fixedby": ""
        },
        {
            "featurename": "libgcrypt20",
            "featureversion": "1.8.7-6",
            "vulnerability": "CVE-2021-33560",
            "namespace": "debian:11",
            "description": "Libgcrypt before 1.8.8 and 1.9.x before 1.9.3 mishandles ElGamal encryption because it lacks exponent blinding to address a side-channel attack against mpi_powm, and the window size is not chosen appropriately. This, for example, affects use of ElGamal in OpenPGP.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-33560",
            "severity": "Medium",
            "fixedby": ""
        },
        {
            "featurename": "e2fsprogs",
            "featureversion": "1.46.2-2",
            "vulnerability": "CVE-2022-1304",
            "namespace": "debian:11",
            "description": "An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-1304",
            "severity": "Medium",
            "fixedby": ""
        },
        {
            "featurename": "libgd2",
            "featureversion": "2.3.0-2",
            "vulnerability": "CVE-2021-38115",
            "namespace": "debian:11",
            "description": "read_header_tga in gd_tga.c in the GD Graphics Library (aka LibGD) through 2.3.2 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted TGA file.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-38115",
            "severity": "Medium",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2019-19449",
            "namespace": "debian:11",
            "description": "In the Linux kernel 5.0.21, mounting a crafted f2fs filesystem image can lead to slab-out-of-bounds read access in f2fs_build_segment_manager in fs/f2fs/segment.c, related to init_min_max_mtime in fs/f2fs/segment.c (because the second argument to get_seg_entry is not validated).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-19449",
            "severity": "Medium",
            "fixedby": ""
        },
        {
            "featurename": "libgd2",
            "featureversion": "2.3.0-2",
            "vulnerability": "CVE-2021-40812",
            "namespace": "debian:11",
            "description": "The GD Graphics Library (aka LibGD) through 2.3.2 has an out-of-bounds read because of the lack of certain gdGetBuf and gdPutBuf return value checks.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-40812",
            "severity": "Medium",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2019-20794",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel 4.18 through 5.6.11 when unprivileged user namespaces are allowed. A user can create their own PID namespace, and mount a FUSE filesystem. Upon interaction with this FUSE filesystem, if the userspace component is terminated via a kill of the PID namespace's pid 1, it will result in a hung task, and resources being permanently locked up until system reboot. This can result in resource exhaustion.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-20794",
            "severity": "Medium",
            "fixedby": ""
        },
        {
            "featurename": "libsepol",
            "featureversion": "3.1-1",
            "vulnerability": "CVE-2021-36087",
            "namespace": "debian:11",
            "description": "The CIL compiler in SELinux 3.2 has a heap-based buffer over-read in ebitmap_match_any (called indirectly from cil_check_neverallow). This occurs because there is sometimes a lack of checks for invalid statements in an optional block.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-36087",
            "severity": "Low",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2020-12364",
            "namespace": "debian:11",
            "description": "Null pointer reference in some Intel(R) Graphics Drivers for Windows* before version 26.20.100.7212 and before version Linux kernel version 5.5 may allow a privileged user to potentially enable a denial of service via local access.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-12364",
            "severity": "Low",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2020-12363",
            "namespace": "debian:11",
            "description": "Improper input validation in some Intel(R) Graphics Drivers for Windows* before version 26.20.100.7212 and before Linux kernel version 5.5 may allow a privileged user to potentially enable a denial of service via local access.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-12363",
            "severity": "Low",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2020-14304",
            "namespace": "debian:11",
            "description": "A memory disclosure flaw was found in the Linux kernel's ethernet drivers, in the way it read data from the EEPROM of the device. This flaw allows a local user to read uninitialized values from the kernel memory. The highest threat from this vulnerability is to confidentiality.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-14304",
            "severity": "Low",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2018-12928",
            "namespace": "debian:11",
            "description": "In the Linux kernel 4.15.0, a NULL pointer dereference was discovered in hfs_ext_read_extent in hfs.ko. This can occur during a mount of a crafted hfs filesystem.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2018-12928",
            "severity": "Low",
            "fixedby": ""
        },
        {
            "featurename": "coreutils",
            "featureversion": "8.32-4",
            "vulnerability": "CVE-2016-2781",
            "namespace": "debian:11",
            "description": "chroot in GNU coreutils, when used with --userspec, allows local users to escape to the parent session via a crafted TIOCSTI ioctl call, which pushes characters to the terminal's input buffer.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2016-2781",
            "severity": "Low",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2021-33061",
            "namespace": "debian:11",
            "description": "Insufficient control flow management for the Intel(R) 82599 Ethernet Controllers and Adapters may allow an authenticated user to potentially enable denial of service via local access.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-33061",
            "severity": "Low",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2022-1280",
            "namespace": "debian:11",
            "description": "A use-after-free vulnerability was found in drm_lease_held in drivers/gpu/drm/drm_lease.c in the Linux kernel due to a race problem. This flaw allows a local user privilege attacker to cause a denial of service (DoS) or a kernel information leak.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-1280",
            "severity": "Low",
            "fixedby": ""
        },
        {
            "featurename": "libsepol",
            "featureversion": "3.1-1",
            "vulnerability": "CVE-2021-36084",
            "namespace": "debian:11",
            "description": "The CIL compiler in SELinux 3.2 has a use-after-free in __cil_verify_classperms (called from __cil_verify_classpermission and __cil_pre_verify_helper).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-36084",
            "severity": "Low",
            "fixedby": ""
        },
        {
            "featurename": "libsepol",
            "featureversion": "3.1-1",
            "vulnerability": "CVE-2021-36085",
            "namespace": "debian:11",
            "description": "The CIL compiler in SELinux 3.2 has a use-after-free in __cil_verify_classperms (called from __verify_map_perm_classperms and hashtab_map).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-36085",
            "severity": "Low",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2021-4149",
            "namespace": "debian:11",
            "description": "A vulnerability was found in btrfs_alloc_tree_b in fs/btrfs/extent-tree.c in the Linux kernel due to an improper lock operation in btrfs. In this flaw, a user with a local privilege may cause a denial of service (DOS) due to a deadlock problem.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-4149",
            "severity": "Low",
            "fixedby": ""
        },
        {
            "featurename": "libsepol",
            "featureversion": "3.1-1",
            "vulnerability": "CVE-2021-36086",
            "namespace": "debian:11",
            "description": "The CIL compiler in SELinux 3.2 has a use-after-free in cil_reset_classpermission (called from cil_reset_classperms_set and cil_reset_classperms_list).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-36086",
            "severity": "Low",
            "fixedby": ""
        },
        {
            "featurename": "libpng1.6",
            "featureversion": "1.6.37-3",
            "vulnerability": "CVE-2019-6129",
            "namespace": "debian:11",
            "description": "png_create_info_struct in png.c in libpng 1.6.36 has a memory leak, as demonstrated by pngcp. NOTE: a third party has stated \"I don't think it is libpng's job to free this buffer.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-6129",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2021-26934",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel 4.18 through 5.10.16, as used by Xen. The backend allocation (aka be-alloc) mode of the drm_xen_front drivers was not meant to be a supported configuration, but this wasn't stated accordingly in its support status entry.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-26934",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2022-1247",
            "namespace": "debian:11",
            "description": "An issue found in linux-kernel that leads to a race condition in rose_connect(). The rose driver uses rose_neigh-\u003euse to represent how many objects are using the rose_neigh. When a user wants to delete a rose_route via rose_ioctl(), the rose driver calls rose_del_node() and removes neighbours only if their “count” and “use” are zero.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-1247",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2019-12382",
            "namespace": "debian:11",
            "description": "An issue was discovered in drm_load_edid_firmware in drivers/gpu/drm/drm_edid_load.c in the Linux kernel through 5.1.5. There is an unchecked kstrdup of fwstr, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: The vendor disputes this issues as not being a vulnerability because kstrdup() returning NULL is handled sufficiently and there is no chance for a NULL pointer dereference",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-12382",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "expat",
            "featureversion": "2.2.10-2+deb11u5",
            "vulnerability": "CVE-2023-52426",
            "namespace": "debian:11",
            "description": "libexpat through 2.5.0 allows recursive XML Entity Expansion if XML_DTD is undefined at compile time.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52426",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2019-12455",
            "namespace": "debian:11",
            "description": "An issue was discovered in sunxi_divs_clk_setup in drivers/clk/sunxi/clk-sunxi.c in the Linux kernel through 5.1.5. There is an unchecked kstrndup of derived_name, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: This id is disputed as not being an issue because “The memory allocation that was not checked is part of a code that only runs at boot time, before user processes are started. Therefore, there is no possibility for an unprivileged user to control it, and no denial of service.”",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-12455",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "expat",
            "featureversion": "2.2.10-2+deb11u5",
            "vulnerability": "CVE-2013-0340",
            "namespace": "debian:11",
            "description": "expat 2.1.0 and earlier does not properly handle entities expansion unless an application developer uses the XML_SetEntityDeclHandler function, which allows remote attackers to cause a denial of service (resource consumption), send HTTP requests to intranet servers, or read arbitrary files via a crafted XML document, aka an XML External Entity (XXE) issue.  NOTE: it could be argued that because expat already provides the ability to disable external entity expansion, the responsibility for resolving this issue lies with application developers; according to this argument, this entry should be REJECTed, and each affected application would need its own CVE.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2013-0340",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2016-10723",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 4.17.2. Since the page allocator does not yield CPU resources to the owner of the oom_lock mutex, a local unprivileged user can trivially lock up the system forever by wasting CPU resources from the page allocator (e.g., via concurrent page fault events) when the global OOM killer is invoked. NOTE: the software maintainer has not accepted certain proposed patches, in part because of a viewpoint that \"the underlying problem is non-trivial to handle.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2016-10723",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2022-2961",
            "namespace": "debian:11",
            "description": "A use-after-free flaw was found in the Linux kernel’s PLP Rose functionality in the way a user triggers a race condition by calling bind while simultaneously triggering the rose_bind() function. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-2961",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "openssl",
            "featureversion": "1.1.1w-0+deb11u1",
            "vulnerability": "CVE-2010-0928",
            "namespace": "debian:11",
            "description": "OpenSSL 0.9.8i on the Gaisler Research LEON3 SoC on the Xilinx Virtex-II Pro FPGA uses a Fixed Width Exponentiation (FWE) algorithm for certain signature calculations, and does not verify the signature before providing it to a caller, which makes it easier for physically proximate attackers to determine the private key via a modified supply voltage for the microprocessor, related to a \"fault-based attack.\"",
            "link": "https://security-tracker.debian.org/tracker/CVE-2010-0928",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2022-45884",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvbdev.c has a use-after-free, related to dvb_register_device dynamically allocating fops.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-45884",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "libgd2",
            "featureversion": "2.3.0-2",
            "vulnerability": "CVE-2021-40145",
            "namespace": "debian:11",
            "description": "gdImageGd2Ptr in gd_gd2.c in the GD Graphics Library (aka LibGD) through 2.3.2 has a double free. NOTE: the vendor's position is \"The GD2 image format is a proprietary image format of libgd. It has to be regarded as being obsolete, and should only be used for development and testing purposes.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-40145",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "openssl",
            "featureversion": "1.1.1w-0+deb11u1",
            "vulnerability": "CVE-2007-6755",
            "namespace": "debian:11",
            "description": "The NIST SP 800-90A default statement of the Dual Elliptic Curve Deterministic Random Bit Generation (Dual_EC_DRBG) algorithm contains point Q constants with a possible relationship to certain \"skeleton key\" values, which might allow context-dependent attackers to defeat cryptographic protection mechanisms by leveraging knowledge of those values.  NOTE: this is a preliminary CVE for Dual_EC_DRBG; future research may provide additional details about point Q and associated attacks, and could potentially lead to a RECAST or REJECT of this CVE.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2007-6755",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "shadow",
            "featureversion": "1:4.8.1-1",
            "vulnerability": "CVE-2007-5686",
            "namespace": "debian:11",
            "description": "initscripts in rPath Linux 1 sets insecure permissions for the /var/log/btmp file, which allows local users to obtain sensitive information regarding authentication attempts.  NOTE: because sshd detects the insecure permissions and does not log certain events, this also prevents sshd from logging failed authentication attempts by remote attackers.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2007-5686",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52489",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  mm/sparsemem: fix race in accessing memory_section-\u003eusage  The below race is observed on a PFN which falls into the device memory region with the system memory configuration where PFN's are such that [ZONE_NORMAL ZONE_DEVICE ZONE_NORMAL].  Since normal zone start and end pfn contains the device memory PFN's as well, the compaction triggered will try on the device memory PFN's too though they end up in NOP(because pfn_to_online_page() returns NULL for ZONE_DEVICE memory sections).  When from other core, the section mappings are being removed for the ZONE_DEVICE region, that the PFN in question belongs to, on which compaction is currently being operated is resulting into the kernel crash with CONFIG_SPASEMEM_VMEMAP enabled.  The crash logs can be seen at [1].  compact_zone()\t\t\tmemunmap_pages -------------\t\t\t--------------- __pageblock_pfn_to_page    ......  (a)pfn_valid():      valid_section()//return true \t\t\t      (b)__remove_pages()-\u003e \t\t\t\t  sparse_remove_section()-\u003e \t\t\t\t    section_deactivate(): \t\t\t\t    [Free the array ms-\u003eusage and set \t\t\t\t     ms-\u003eusage = NULL]      pfn_section_valid()      [Access ms-\u003eusage which      is NULL]  NOTE: From the above it can be said that the race is reduced to between the pfn_valid()/pfn_section_valid() and the section deactivate with SPASEMEM_VMEMAP enabled.  The commit b943f045a9af(\"mm/sparse: fix kernel crash with pfn_section_valid check\") tried to address the same problem by clearing the SECTION_HAS_MEM_MAP with the expectation of valid_section() returns false thus ms-\u003eusage is not accessed.  Fix this issue by the below steps:  a) Clear SECTION_HAS_MEM_MAP before freeing the -\u003eusage.  b) RCU protected read side critical section will either return NULL    when SECTION_HAS_MEM_MAP is cleared or can successfully access -\u003eusage.  c) Free the -\u003eusage with kfree_rcu() and set ms-\u003eusage = NULL.  No    attempt will be made to access -\u003eusage after this as the    SECTION_HAS_MEM_MAP is cleared thus valid_section() return false.  Thanks to David/Pavan for their inputs on this patch.  [1] https://lore.kernel.org/linux-mm/994410bb-89aa-d987-1f50-f514903c55aa@quicinc.com/  On Snapdragon SoC, with the mentioned memory configuration of PFN's as [ZONE_NORMAL ZONE_DEVICE ZONE_NORMAL], we are able to see bunch of issues daily while testing on a device farm.  For this particular issue below is the log.  Though the below log is not directly pointing to the pfn_section_valid(){ ms-\u003eusage;}, when we loaded this dump on T32 lauterbach tool, it is pointing.  [  540.578056] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000 [  540.578068] Mem abort info: [  540.578070]   ESR = 0x0000000096000005 [  540.578073]   EC = 0x25: DABT (current EL), IL = 32 bits [  540.578077]   SET = 0, FnV = 0 [  540.578080]   EA = 0, S1PTW = 0 [  540.578082]   FSC = 0x05: level 1 translation fault [  540.578085] Data abort info: [  540.578086]   ISV = 0, ISS = 0x00000005 [  540.578088]   CM = 0, WnR = 0 [  540.579431] pstate: 82400005 (Nzcv daif +PAN -UAO +TCO -DIT -SSBSBTYPE=--) [  540.579436] pc : __pageblock_pfn_to_page+0x6c/0x14c [  540.579454] lr : compact_zone+0x994/0x1058 [  540.579460] sp : ffffffc03579b510 [  540.579463] x29: ffffffc03579b510 x28: 0000000000235800 x27:000000000000000c [  540.579470] x26: 0000000000235c00 x25: 0000000000000068 x24:ffffffc03579b640 [  540.579477] x23: 0000000000000001 x22: ffffffc03579b660 x21:0000000000000000 [  540.579483] x20: 0000000000235bff x19: ffffffdebf7e3940 x18:ffffffdebf66d140 [  540.579489] x17: 00000000739ba063 x16: 00000000739ba063 x15:00000000009f4bff [  540.579495] x14: 0000008000000000 x13: 0000000000000000 x12:0000000000000001 [  540.579501] x11: 0000000000000000 x10: 0000000000000000 x9 :ffffff897d2cd440 [  540.579507] x8 : 0000000000000000 x7 : 0000000000000000 x6 :ffffffc03579b5b4 [  540.579512] x5 : 0000000000027f25 x4 : ffffffc03579b5b8 x3 :0000000000000 ---truncated---",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52489",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2021-47028",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  mt76: mt7915: fix txrate reporting  Properly check rate_info to fix unexpected reporting.  [ 1215.161863] Call trace: [ 1215.164307]  cfg80211_calculate_bitrate+0x124/0x200 [cfg80211] [ 1215.170139]  ieee80211s_update_metric+0x80/0xc0 [mac80211] [ 1215.175624]  ieee80211_tx_status_ext+0x508/0x838 [mac80211] [ 1215.181190]  mt7915_mcu_get_rx_rate+0x28c/0x8d0 [mt7915e] [ 1215.186580]  mt7915_mac_tx_free+0x324/0x7c0 [mt7915e] [ 1215.191623]  mt7915_queue_rx_skb+0xa8/0xd0 [mt7915e] [ 1215.196582]  mt76_dma_cleanup+0x7b0/0x11d0 [mt76] [ 1215.201276]  __napi_poll+0x38/0xf8 [ 1215.204668]  napi_workfn+0x40/0x80 [ 1215.208062]  process_one_work+0x1fc/0x390 [ 1215.212062]  worker_thread+0x48/0x4d0 [ 1215.215715]  kthread+0x120/0x128 [ 1215.218935]  ret_from_fork+0x10/0x1c",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-47028",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26627",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: core: Move scsi_host_busy() out of host lock for waking up EH handler  Inside scsi_eh_wakeup(), scsi_host_busy() is called \u0026 checked with host lock every time for deciding if error handler kthread needs to be waken up.  This can be too heavy in case of recovery, such as:   - N hardware queues   - queue depth is M for each hardware queue   - each scsi_host_busy() iterates over (N * M) tag/requests  If recovery is triggered in case that all requests are in-flight, each scsi_eh_wakeup() is strictly serialized, when scsi_eh_wakeup() is called for the last in-flight request, scsi_host_busy() has been run for (N * M - 1) times, and request has been iterated for (N*M - 1) * (N * M) times.  If both N and M are big enough, hard lockup can be triggered on acquiring host lock, and it is observed on mpi3mr(128 hw queues, queue depth 8169).  Fix the issue by calling scsi_host_busy() outside the host lock. We don't need the host lock for getting busy count because host the lock never covers that.  [mkp: Drop unnecessary 'busy' variables pointed out by Bart]",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26627",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-23039",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 6.2.0-rc2. drivers/tty/vcc.c has a race condition and resultant use-after-free if a physically proximate attacker removes a VCC device while calling open(), aka a race condition between vcc_open() and vcc_remove().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-23039",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "shadow",
            "featureversion": "1:4.8.1-1",
            "vulnerability": "CVE-2013-4235",
            "namespace": "debian:11",
            "description": "shadow: TOCTOU (time-of-check time-of-use) race condition when copying and removing directory trees",
            "link": "https://security-tracker.debian.org/tracker/CVE-2013-4235",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26601",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  ext4: regenerate buddy after block freeing failed if under fc replay  This mostly reverts commit 6bd97bf273bd (\"ext4: remove redundant mb_regenerate_buddy()\") and reintroduces mb_regenerate_buddy(). Based on code in mb_free_blocks(), fast commit replay can end up marking as free blocks that are already marked as such. This causes corruption of the buddy bitmap so we need to regenerate it in that case.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26601",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2019-12378",
            "namespace": "debian:11",
            "description": "An issue was discovered in ip6_ra_control in net/ipv6/ipv6_sockglue.c in the Linux kernel through 5.1.5. There is an unchecked kmalloc of new_ra, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: This has been disputed as not an issue",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-12378",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "shadow",
            "featureversion": "1:4.8.1-1",
            "vulnerability": "CVE-2019-19882",
            "namespace": "debian:11",
            "description": "shadow 4.8, in certain circumstances affecting at least Gentoo, Arch Linux, and Void Linux, allows local users to obtain root access because setuid programs are misconfigured. Specifically, this affects shadow 4.8 when compiled using --with-libpam but without explicitly passing --disable-account-tools-setuid, and without a PAM configuration suitable for use with setuid account management tools. This combination leads to account management tools (groupadd, groupdel, groupmod, useradd, userdel, usermod) that can easily be used by unprivileged local users to escalate privileges to root in multiple ways. This issue became much more relevant in approximately December 2019 when an unrelated bug was fixed (i.e., the chmod calls to suidusbins were fixed in the upstream Makefile which is now included in the release version 4.8).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-19882",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "pcre2",
            "featureversion": "10.36-2+deb11u1",
            "vulnerability": "CVE-2022-41409",
            "namespace": "debian:11",
            "description": "Integer overflow vulnerability in pcre2test before 10.41 allows attackers to cause a denial of service or other unspecified impacts via negative input.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-41409",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "libcap2",
            "featureversion": "1:2.44-1",
            "vulnerability": "CVE-2023-2603",
            "namespace": "debian:11",
            "description": "A vulnerability was found in libcap. This issue occurs in the _libcap_strdup() function and can lead to an integer overflow if the input string is close to 4GiB.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-2603",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2019-16231",
            "namespace": "debian:11",
            "description": "drivers/net/fjes/fjes_main.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-16231",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "libcap2",
            "featureversion": "1:2.44-1",
            "vulnerability": "CVE-2023-2602",
            "namespace": "debian:11",
            "description": "A vulnerability was found in the pthread_create() function in libcap. This issue may allow a malicious actor to use cause __real_pthread_create() to return an error, which can exhaust the process memory.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-2602",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "gnupg2",
            "featureversion": "2.2.27-2+deb11u2",
            "vulnerability": "CVE-2022-3219",
            "namespace": "debian:11",
            "description": "GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-3219",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2022-44032",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 6.0.6. drivers/char/pcmcia/cm4000_cs.c has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling open(), aka a race condition between cmm_open() and cm4000_detach().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-44032",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2020-35501",
            "namespace": "debian:11",
            "description": "A flaw was found in the Linux kernels implementation of audit rules, where a syscall can unexpectedly not be correctly not be logged by the audit subsystem",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-35501",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "tcpdump",
            "featureversion": "4.99.0-2+deb11u1",
            "vulnerability": "CVE-2018-19519",
            "namespace": "debian:11",
            "description": "In tcpdump 4.9.2, a stack-based buffer over-read exists in the print_prefix function of print-hncp.c via crafted packet data because of missing initialization.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2018-19519",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "tcpdump",
            "featureversion": "4.99.0-2+deb11u1",
            "vulnerability": "CVE-2023-1801",
            "namespace": "debian:11",
            "description": "The SMB protocol decoder in tcpdump version 4.99.3 can perform an out-of-bounds write when decoding a crafted network packet.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1801",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "systemd",
            "featureversion": "247.3-7+deb11u4",
            "vulnerability": "CVE-2013-4392",
            "namespace": "debian:11",
            "description": "systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2013-4392",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "systemd",
            "featureversion": "247.3-7+deb11u4",
            "vulnerability": "CVE-2023-31439",
            "namespace": "debian:11",
            "description": "An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-31439",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "systemd",
            "featureversion": "247.3-7+deb11u4",
            "vulnerability": "CVE-2020-13529",
            "namespace": "debian:11",
            "description": "An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-13529",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "systemd",
            "featureversion": "247.3-7+deb11u4",
            "vulnerability": "CVE-2023-31438",
            "namespace": "debian:11",
            "description": "An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-31438",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2022-38457",
            "namespace": "debian:11",
            "description": "A use-after-free(UAF) vulnerability was found in function 'vmw_cmd_res_check' in drivers/gpu/vmxgfx/vmxgfx_execbuf.c in Linux kernel's vmwgfx driver with device file '/dev/dri/renderD128 (or Dxxx)'. This flaw allows a local attacker with a user account on the system to gain privilege, causing a denial of service(DoS).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-38457",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "systemd",
            "featureversion": "247.3-7+deb11u4",
            "vulnerability": "CVE-2023-31437",
            "namespace": "debian:11",
            "description": "An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-31437",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26595",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  mlxsw: spectrum_acl_tcam: Fix NULL pointer dereference in error path  When calling mlxsw_sp_acl_tcam_region_destroy() from an error path after failing to attach the region to an ACL group, we hit a NULL pointer dereference upon 'region-\u003egroup-\u003etcam' [1].  Fix by retrieving the 'tcam' pointer using mlxsw_sp_acl_to_tcam().  [1] BUG: kernel NULL pointer dereference, address: 0000000000000000 [...] RIP: 0010:mlxsw_sp_acl_tcam_region_destroy+0xa0/0xd0 [...] Call Trace:  mlxsw_sp_acl_tcam_vchunk_get+0x88b/0xa20  mlxsw_sp_acl_tcam_ventry_add+0x25/0xe0  mlxsw_sp_acl_rule_add+0x47/0x240  mlxsw_sp_flower_replace+0x1a9/0x1d0  tc_setup_cb_add+0xdc/0x1c0  fl_hw_replace_filter+0x146/0x1f0  fl_change+0xc17/0x1360  tc_new_tfilter+0x472/0xb90  rtnetlink_rcv_msg+0x313/0x3b0  netlink_rcv_skb+0x58/0x100  netlink_unicast+0x244/0x390  netlink_sendmsg+0x1e4/0x440  ____sys_sendmsg+0x164/0x260  ___sys_sendmsg+0x9a/0xe0  __sys_sendmsg+0x7a/0xc0  do_syscall_64+0x40/0xe0  entry_SYSCALL_64_after_hwframe+0x63/0x6b",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26595",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "tcpdump",
            "featureversion": "4.99.0-2+deb11u1",
            "vulnerability": "CVE-2019-1010220",
            "namespace": "debian:11",
            "description": "tcpdump.org tcpdump 4.9.2 is affected by: CWE-126: Buffer Over-read. The impact is: May expose Saved Frame Pointer, Return Address etc. on stack. The component is: line 234: \"ND_PRINT((ndo, \"%s\", buf));\", in function named \"print_prefix\", in \"print-hncp.c\". The attack vector is: The victim must open a specially crafted pcap file.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-1010220",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "freetype",
            "featureversion": "2.10.4+dfsg-1+deb11u1",
            "vulnerability": "CVE-2022-31782",
            "namespace": "debian:11",
            "description": "ftbench.c in FreeType Demo Programs through 2.12.1 has a heap-based buffer overflow.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-31782",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "apt",
            "featureversion": "2.2.4",
            "vulnerability": "CVE-2011-3374",
            "namespace": "debian:11",
            "description": "It was found that apt-key in apt, all versions, do not correctly validate gpg keys with the master keyring, leading to a potential man-in-the-middle attack.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2011-3374",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2011-4915",
            "namespace": "debian:11",
            "description": "fs/proc/base.c in the Linux kernel through 3.1 allows local users to obtain sensitive keystroke information via access to /proc/interrupts.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2011-4915",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2019-12380",
            "namespace": "debian:11",
            "description": "**DISPUTED** An issue was discovered in the efi subsystem in the Linux kernel through 5.1.5. phys_efi_set_virtual_address_map in arch/x86/platform/efi/efi.c and efi_call_phys_prolog in arch/x86/platform/efi/efi_64.c mishandle memory allocation failures. NOTE: This id is disputed as not being an issue because “All the code touched by the referenced commit runs only at boot, before any user processes are started. Therefore, there is no possibility for an unprivileged user to control it.”.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-12380",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "tiff",
            "featureversion": "4.2.0-1+deb11u5",
            "vulnerability": "CVE-2023-3164",
            "namespace": "debian:11",
            "description": "A heap-buffer-overflow vulnerability was found in LibTIFF, in extractImageSection() at tools/tiffcrop.c:7916 and tools/tiffcrop.c:7801. This flaw allows attackers to cause a denial of service via a crafted tiff file.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3164",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52452",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Fix accesses to uninit stack slots  Privileged programs are supposed to be able to read uninitialized stack memory (ever since 6715df8d5) but, before this patch, these accesses were permitted inconsistently. In particular, accesses were permitted above state-\u003eallocated_stack, but not below it. In other words, if the stack was already \"large enough\", the access was permitted, but otherwise the access was rejected instead of being allowed to \"grow the stack\". This undesired rejection was happening in two places: - in check_stack_slot_within_bounds() - in check_stack_range_initialized() This patch arranges for these accesses to be permitted. A bunch of tests that were relying on the old rejection had to change; all of them were changed to add also run unprivileged, in which case the old behavior persists. One tests couldn't be updated - global_func16 - because it can't run unprivileged for other reasons.  This patch also fixes the tracking of the stack size for variable-offset reads. This second fix is bundled in the same commit as the first one because they're inter-related. Before this patch, writes to the stack using registers containing a variable offset (as opposed to registers with fixed, known values) were not properly contributing to the function's needed stack size. As a result, it was possible for a program to verify, but then to attempt to read out-of-bounds data at runtime because a too small stack had been allocated for it.  Each function tracks the size of the stack it needs in bpf_subprog_info.stack_depth, which is maintained by update_stack_depth(). For regular memory accesses, check_mem_access() was calling update_state_depth() but it was passing in only the fixed part of the offset register, ignoring the variable offset. This was incorrect; the minimum possible value of that register should be used instead.  This tracking is now fixed by centralizing the tracking of stack size in grow_stack_state(), and by lifting the calls to grow_stack_state() to check_stack_access_within_bounds() as suggested by Andrii. The code is now simpler and more convincingly tracks the correct maximum stack size. check_stack_range_initialized() can now rely on enough stack having been allocated for the access; this helps with the fix for the first issue.  A few tests were changed to also check the stack depth computation. The one that fails without this patch is verifier_var_off:stack_write_priv_vs_unpriv.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52452",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2019-12456",
            "namespace": "debian:11",
            "description": "An issue was discovered in the MPT3COMMAND case in _ctl_ioctl_main in drivers/scsi/mpt3sas/mpt3sas_ctl.c in the Linux kernel through 5.1.5. It allows local users to cause a denial of service or possibly have unspecified other impact by changing the value of ioc_number between two kernel reads of that value, aka a \"double fetch\" vulnerability. NOTE: a third party reports that this is unexploitable because the doubly fetched value is not used",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-12456",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "tiff",
            "featureversion": "4.2.0-1+deb11u5",
            "vulnerability": "CVE-2018-10126",
            "namespace": "debian:11",
            "description": "LibTIFF 4.0.9 has a NULL pointer dereference in the jpeg_fdct_16x16 function in jfdctint.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2018-10126",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "tiff",
            "featureversion": "4.2.0-1+deb11u5",
            "vulnerability": "CVE-2023-6228",
            "namespace": "debian:11",
            "description": "An issue was found in the tiffcp utility distributed by the libtiff package where a crafted TIFF file on processing may cause a heap-based buffer overflow leads to an application crash.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-6228",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2005-3660",
            "namespace": "debian:11",
            "description": "Linux kernel 2.4 and 2.6 allows attackers to cause a denial of service (memory exhaustion and panic) by creating a large number of connected file descriptors or socketpairs and setting a large data transfer buffer, then preventing Linux from being able to finish the transfer by causing the process to become a zombie, or closing the file descriptor without closing an associated reference.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2005-3660",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "tiff",
            "featureversion": "4.2.0-1+deb11u5",
            "vulnerability": "CVE-2023-1916",
            "namespace": "debian:11",
            "description": "A flaw was found in tiffcrop, a program distributed by the libtiff package. A specially crafted tiff file can lead to an out-of-bounds read in the extractImageSection function in tools/tiffcrop.c, resulting in a denial of service and limited information disclosure. This issue affects libtiff versions 4.x.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1916",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2016-8660",
            "namespace": "debian:11",
            "description": "The XFS subsystem in the Linux kernel through 4.8.2 allows local users to cause a denial of service (fdatasync failure and system hang) by using the vfs syscall group in the trinity program, related to a \"page lock order bug in the XFS seek hole/data implementation.\"",
            "link": "https://security-tracker.debian.org/tracker/CVE-2016-8660",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2022-45885",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvb_frontend.c has a race condition that can cause a use-after-free when a device is disconnected.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-45885",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "tiff",
            "featureversion": "4.2.0-1+deb11u5",
            "vulnerability": "CVE-2023-30775",
            "namespace": "debian:11",
            "description": "A vulnerability was found in the libtiff library. This security flaw causes a heap buffer overflow in extractContigSamples32bits, tiffcrop.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-30775",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26585",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  tls: fix race between tx work scheduling and socket close  Similarly to previous commit, the submitting thread (recvmsg/sendmsg) may exit as soon as the async crypto handler calls complete(). Reorder scheduling the work before calling complete(). This seems more logical in the first place, as it's the inverse order of what the submitting thread will do.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26585",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "tiff",
            "featureversion": "4.2.0-1+deb11u5",
            "vulnerability": "CVE-2017-5563",
            "namespace": "debian:11",
            "description": "LibTIFF version 4.0.7 is vulnerable to a heap-based buffer over-read in tif_lzw.c resulting in DoS or code execution via a crafted bmp image to tools/bmp2tiff.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2017-5563",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "tiff",
            "featureversion": "4.2.0-1+deb11u5",
            "vulnerability": "CVE-2017-16232",
            "namespace": "debian:11",
            "description": "LibTIFF 4.0.8 has multiple memory leak vulnerabilities, which allow attackers to cause a denial of service (memory consumption), as demonstrated by tif_open.c, tif_lzw.c, and tif_aux.c. NOTE: Third parties were unable to reproduce the issue",
            "link": "https://security-tracker.debian.org/tracker/CVE-2017-16232",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2007-3719",
            "namespace": "debian:11",
            "description": "The process scheduler in the Linux kernel 2.6.16 gives preference to \"interactive\" processes that perform voluntary sleeps, which allows local users to cause a denial of service (CPU consumption), as described in \"Secretly Monopolizing the CPU Without Superuser Privileges.\"",
            "link": "https://security-tracker.debian.org/tracker/CVE-2007-3719",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-23850",
            "namespace": "debian:11",
            "description": "In btrfs_get_root_ref in fs/btrfs/disk-io.c in the Linux kernel through 6.7.1, there can be an assertion failure and crash because a subvolume can be read out too soon after its root item is inserted upon subvolume creation.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-23850",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "tiff",
            "featureversion": "4.2.0-1+deb11u5",
            "vulnerability": "CVE-2022-1056",
            "namespace": "debian:11",
            "description": "Out-of-bounds Read error in tiffcrop in libtiff 4.3.0 allows attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit 46dc8fcd.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-1056",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "tiff",
            "featureversion": "4.2.0-1+deb11u5",
            "vulnerability": "CVE-2022-1210",
            "namespace": "debian:11",
            "description": "A vulnerability classified as problematic was found in LibTIFF 4.3.0. Affected by this vulnerability is the TIFF File Handler of tiff2ps. Opening a malicious file leads to a denial of service. The attack can be launched remotely but requires user interaction. The exploit has been disclosed to the public and may be used.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-1210",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2014-9900",
            "namespace": "debian:11",
            "description": "The ethtool_get_wol function in net/core/ethtool.c in the Linux kernel through 4.7, as used in Android before 2016-08-05 on Nexus 5 and 7 (2013) devices, does not initialize a certain data structure, which allows local users to obtain sensitive information via a crafted application, aka Android internal bug 28803952 and Qualcomm internal bug CR570754.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2014-9900",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "tiff",
            "featureversion": "4.2.0-1+deb11u5",
            "vulnerability": "CVE-2017-9117",
            "namespace": "debian:11",
            "description": "In LibTIFF 4.0.7, the program processes BMP images without verifying that biWidth and biHeight in the bitmap-information header match the actual input, leading to a heap-based buffer over-read in bmp2tiff.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2017-9117",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "tiff",
            "featureversion": "4.2.0-1+deb11u5",
            "vulnerability": "CVE-2017-17973",
            "namespace": "debian:11",
            "description": "In LibTIFF 4.0.8, there is a heap-based use-after-free in the t2p_writeproc function in tiff2pdf.c. NOTE: there is a third-party report of inability to reproduce this issue",
            "link": "https://security-tracker.debian.org/tracker/CVE-2017-17973",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "sudo",
            "featureversion": "1.9.5p2-3+deb11u1",
            "vulnerability": "CVE-2005-1119",
            "namespace": "debian:11",
            "description": "Sudo VISudo 1.6.8 and earlier allows local users to corrupt arbitrary files via a symlink attack on temporary files.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2005-1119",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2014-9892",
            "namespace": "debian:11",
            "description": "The snd_compr_tstamp function in sound/core/compress_offload.c in the Linux kernel through 4.7, as used in Android before 2016-08-05 on Nexus 5 and 7 (2013) devices, does not properly initialize a timestamp data structure, which allows attackers to obtain sensitive information via a crafted application, aka Android internal bug 28770164 and Qualcomm internal bug CR568717.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2014-9892",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "sudo",
            "featureversion": "1.9.5p2-3+deb11u1",
            "vulnerability": "CVE-2022-43995",
            "namespace": "debian:11",
            "description": "Sudo 1.8.0 through 1.9.12, with the crypt() password backend, contains a plugins/sudoers/auth/passwd.c array-out-of-bounds error that can result in a heap-based buffer over-read. This can be triggered by arbitrary local users with access to Sudo by entering a password of seven characters or fewer. The impact could vary depending on the system libraries, compiler, and processor architecture.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-43995",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2021-4204",
            "namespace": "debian:11",
            "description": "An out-of-bounds (OOB) memory access flaw was found in the Linux kernel's eBPF due to an Improper Input Validation. This flaw allows a local attacker with a special privilege to crash the system or leak internal information.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-4204",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52447",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Defer the free of inner map when necessary  When updating or deleting an inner map in map array or map htab, the map may still be accessed by non-sleepable program or sleepable program. However bpf_map_fd_put_ptr() decreases the ref-counter of the inner map directly through bpf_map_put(), if the ref-counter is the last one (which is true for most cases), the inner map will be freed by ops-\u003emap_free() in a kworker. But for now, most .map_free() callbacks don't use synchronize_rcu() or its variants to wait for the elapse of a RCU grace period, so after the invocation of ops-\u003emap_free completes, the bpf program which is accessing the inner map may incur use-after-free problem.  Fix the free of inner map by invoking bpf_map_free_deferred() after both one RCU grace period and one tasks trace RCU grace period if the inner map has been removed from the outer map before. The deferment is accomplished by using call_rcu() or call_rcu_tasks_trace() when releasing the last ref-counter of bpf map. The newly-added rcu_head field in bpf_map shares the same storage space with work field to reduce the size of bpf_map.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52447",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "db5.3",
            "featureversion": "5.3.28+dfsg1-0.8",
            "vulnerability": "CVE-2019-8457",
            "namespace": "debian:11",
            "description": "SQLite3 from 3.6.0 to and including 3.27.2 is vulnerable to heap out-of-bound read in the rtreenode() function when handling invalid rtree tables.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-8457",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26610",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: iwlwifi: fix a memory corruption  iwl_fw_ini_trigger_tlv::data is a pointer to a __le32, which means that if we copy to iwl_fw_ini_trigger_tlv::data + offset while offset is in bytes, we'll write past the buffer.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26610",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "pcre3",
            "featureversion": "2:8.39-13",
            "vulnerability": "CVE-2017-16231",
            "namespace": "debian:11",
            "description": "In PCRE 8.41, after compiling, a pcretest load test PoC produces a crash overflow in the function match() in pcre_exec.c because of a self-recursive call. NOTE: third parties dispute the relevance of this report, noting that there are options that can be used to limit the amount of stack that is used",
            "link": "https://security-tracker.debian.org/tracker/CVE-2017-16231",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "perl",
            "featureversion": "5.32.1-4+deb11u3",
            "vulnerability": "CVE-2023-31486",
            "namespace": "debian:11",
            "description": "HTTP::Tiny before 0.083, a Perl core module since 5.13.9 and available standalone on CPAN, has an insecure default TLS configuration where users must opt in to verify certificates.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-31486",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "perl",
            "featureversion": "5.32.1-4+deb11u3",
            "vulnerability": "CVE-2011-4116",
            "namespace": "debian:11",
            "description": "_is_safe in the File::Temp module for Perl does not properly handle symlinks.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2011-4116",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2022-44033",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 6.0.6. drivers/char/pcmcia/cm4040_cs.c has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling open(), aka a race condition between cm4040_open() and reader_detach().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-44033",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2022-41848",
            "namespace": "debian:11",
            "description": "drivers/char/pcmcia/synclink_cs.c in the Linux kernel through 5.19.12 has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling ioctl, aka a race condition between mgslpc_ioctl and mgslpc_detach.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-41848",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "glibc",
            "featureversion": "2.31-13+deb11u8",
            "vulnerability": "CVE-2010-4756",
            "namespace": "debian:11",
            "description": "The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2010-4756",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2021-47094",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  KVM: x86/mmu: Don't advance iterator after restart due to yielding  After dropping mmu_lock in the TDP MMU, restart the iterator during tdp_iter_next() and do not advance the iterator.  Advancing the iterator results in skipping the top-level SPTE and all its children, which is fatal if any of the skipped SPTEs were not visited before yielding.  When zapping all SPTEs, i.e. when min_level == root_level, restarting the iter and then invoking tdp_iter_next() is always fatal if the current gfn has as a valid SPTE, as advancing the iterator results in try_step_side() skipping the current gfn, which wasn't visited before yielding.  Sprinkle WARNs on iter-\u003eyielded being true in various helpers that are often used in conjunction with yielding, and tag the helper with __must_check to reduce the probabily of improper usage.  Failing to zap a top-level SPTE manifests in one of two ways.  If a valid SPTE is skipped by both kvm_tdp_mmu_zap_all() and kvm_tdp_mmu_put_root(), the shadow page will be leaked and KVM will WARN accordingly.    WARNING: CPU: 1 PID: 3509 at arch/x86/kvm/mmu/tdp_mmu.c:46 [kvm]   RIP: 0010:kvm_mmu_uninit_tdp_mmu+0x3e/0x50 [kvm]   Call Trace:    \u003cTASK\u003e    kvm_arch_destroy_vm+0x130/0x1b0 [kvm]    kvm_destroy_vm+0x162/0x2a0 [kvm]    kvm_vcpu_release+0x34/0x60 [kvm]    __fput+0x82/0x240    task_work_run+0x5c/0x90    do_exit+0x364/0xa10    ? futex_unqueue+0x38/0x60    do_group_exit+0x33/0xa0    get_signal+0x155/0x850    arch_do_signal_or_restart+0xed/0x750    exit_to_user_mode_prepare+0xc5/0x120    syscall_exit_to_user_mode+0x1d/0x40    do_syscall_64+0x48/0xc0    entry_SYSCALL_64_after_hwframe+0x44/0xae  If kvm_tdp_mmu_zap_all() skips a gfn/SPTE but that SPTE is then zapped by kvm_tdp_mmu_put_root(), KVM triggers a use-after-free in the form of marking a struct page as dirty/accessed after it has been put back on the free list.  This directly triggers a WARN due to encountering a page with page_count() == 0, but it can also lead to data corruption and additional errors in the kernel.    WARNING: CPU: 7 PID: 1995658 at arch/x86/kvm/../../../virt/kvm/kvm_main.c:171   RIP: 0010:kvm_is_zone_device_pfn.part.0+0x9e/0xd0 [kvm]   Call Trace:    \u003cTASK\u003e    kvm_set_pfn_dirty+0x120/0x1d0 [kvm]    __handle_changed_spte+0x92e/0xca0 [kvm]    __handle_changed_spte+0x63c/0xca0 [kvm]    __handle_changed_spte+0x63c/0xca0 [kvm]    __handle_changed_spte+0x63c/0xca0 [kvm]    zap_gfn_range+0x549/0x620 [kvm]    kvm_tdp_mmu_put_root+0x1b6/0x270 [kvm]    mmu_free_root_page+0x219/0x2c0 [kvm]    kvm_mmu_free_roots+0x1b4/0x4e0 [kvm]    kvm_mmu_unload+0x1c/0xa0 [kvm]    kvm_arch_destroy_vm+0x1f2/0x5c0 [kvm]    kvm_put_kvm+0x3b1/0x8b0 [kvm]    kvm_vcpu_release+0x4e/0x70 [kvm]    __fput+0x1f7/0x8c0    task_work_run+0xf8/0x1a0    do_exit+0x97b/0x2230    do_group_exit+0xda/0x2a0    get_signal+0x3be/0x1e50    arch_do_signal_or_restart+0x244/0x17f0    exit_to_user_mode_prepare+0xcb/0x120    syscall_exit_to_user_mode+0x1d/0x40    do_syscall_64+0x4d/0x90    entry_SYSCALL_64_after_hwframe+0x44/0xae  Note, the underlying bug existed even before commit 1af4a96025b3 (\"KVM: x86/mmu: Yield in TDU MMU iter even if no SPTES changed\") moved calls to tdp_mmu_iter_cond_resched() to the beginning of loops, as KVM could still incorrectly advance past a top-level entry when yielding on a lower-level entry.  But with respect to leaking shadow pages, the bug was introduced by yielding before processing the current gfn.  Alternatively, tdp_mmu_iter_cond_resched() could simply fall through, or callers could jump to their \"retry\" label.  The downside of that approach is that tdp_mmu_iter_cond_resched() _must_ be called before anything else in the loop, and there's no easy way to enfornce that requirement.  Ideally, KVM would handling the cond_resched() fully within the iterator macro (the code is actually quite clean) and avoid this entire class of bugs, but that is extremely difficult do wh ---truncated---",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-47094",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-0841",
            "namespace": "debian:11",
            "description": "A null pointer dereference flaw was found in the hugetlbfs_fill_super function in the Linux kernel hugetlbfs (HugeTLB pages) functionality. This issue may allow a local user to crash the system or potentially escalate their privileges on the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-0841",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "glibc",
            "featureversion": "2.31-13+deb11u8",
            "vulnerability": "CVE-2019-9192",
            "namespace": "debian:11",
            "description": "In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\\\1\\\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-9192",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "glibc",
            "featureversion": "2.31-13+deb11u8",
            "vulnerability": "CVE-2018-20796",
            "namespace": "debian:11",
            "description": "In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\\227|)(\\\\1\\\\1|t1|\\\\\\2537)+' in grep.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2018-20796",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "glibc",
            "featureversion": "2.31-13+deb11u8",
            "vulnerability": "CVE-2019-1010025",
            "namespace": "debian:11",
            "description": "GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor's position is \"ASLR bypass itself is not a vulnerability.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-1010025",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2011-4917",
            "namespace": "debian:11",
            "description": "In the Linux kernel through 3.1 there is an information disclosure issue via /proc/stat.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2011-4917",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2008-2544",
            "namespace": "debian:11",
            "description": "Mounting /proc filesystem via chroot command silently mounts it in read-write mode. The user could bypass the chroot environment and gain write access to files, he would never have otherwise.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2008-2544",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "glibc",
            "featureversion": "2.31-13+deb11u8",
            "vulnerability": "CVE-2019-1010024",
            "namespace": "debian:11",
            "description": "GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate \"this is being treated as a non-security bug and no real threat.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-1010024",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "glibc",
            "featureversion": "2.31-13+deb11u8",
            "vulnerability": "CVE-2019-1010022",
            "namespace": "debian:11",
            "description": "GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate \"this is being treated as a non-security bug and no real threat.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-1010022",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2019-19378",
            "namespace": "debian:11",
            "description": "In the Linux kernel 5.0.21, mounting a crafted btrfs filesystem image can lead to slab-out-of-bounds write access in index_rbio_pages in fs/btrfs/raid56.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-19378",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "glibc",
            "featureversion": "2.31-13+deb11u8",
            "vulnerability": "CVE-2019-1010023",
            "namespace": "debian:11",
            "description": "GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate \"this is being treated as a non-security bug and no real threat.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-1010023",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2017-13693",
            "namespace": "debian:11",
            "description": "The acpi_ds_create_operands() function in drivers/acpi/acpica/dsutils.c in the Linux kernel through 4.12.9 does not flush the operand cache and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2017-13693",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26639",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  mm, kmsan: fix infinite recursion due to RCU critical section  Alexander Potapenko writes in [1]: \"For every memory access in the code instrumented by KMSAN we call kmsan_get_metadata() to obtain the metadata for the memory being accessed.  For virtual memory the metadata pointers are stored in the corresponding `struct page`, therefore we need to call virt_to_page() to get them.  According to the comment in arch/x86/include/asm/page.h, virt_to_page(kaddr) returns a valid pointer iff virt_addr_valid(kaddr) is true, so KMSAN needs to call virt_addr_valid() as well.  To avoid recursion, kmsan_get_metadata() must not call instrumented code, therefore ./arch/x86/include/asm/kmsan.h forks parts of arch/x86/mm/physaddr.c to check whether a virtual address is valid or not.  But the introduction of rcu_read_lock() to pfn_valid() added instrumented RCU API calls to virt_to_page_or_null(), which is called by kmsan_get_metadata(), so there is an infinite recursion now.  I do not think it is correct to stop that recursion by doing kmsan_enter_runtime()/kmsan_exit_runtime() in kmsan_get_metadata(): that would prevent instrumented functions called from within the runtime from tracking the shadow values, which might introduce false positives.\"  Fix the issue by switching pfn_valid() to the _sched() variant of rcu_read_lock/unlock(), which does not require calling into RCU.  Given the critical section in pfn_valid() is very small, this is a reasonable trade-off (with preemptible RCU).  KMSAN further needs to be careful to suppress calls into the scheduler, which would be another source of recursion.  This can be done by wrapping the call to pfn_valid() into preempt_disable/enable_no_resched().  The downside is that this sacrifices breaking scheduling guarantees; however, a kernel compiled with KMSAN has already given up any performance guarantees due to being heavily instrumented.  Note, KMSAN code already disables tracing via Makefile, and since mmzone.h is included, it is not necessary to use the notrace variant, which is generally preferred in all other cases.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26639",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2019-16233",
            "namespace": "debian:11",
            "description": "drivers/scsi/qla2xxx/qla_os.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-16233",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "iptables",
            "featureversion": "1.8.7-1",
            "vulnerability": "CVE-2012-2663",
            "namespace": "debian:11",
            "description": "extensions/libxt_tcp.c in iptables through 1.4.21 does not match TCP SYN+FIN packets in --syn rules, which might allow remote attackers to bypass intended firewall restrictions via crafted packets.  NOTE: the CVE-2012-6638 fix makes this issue less relevant.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2012-2663",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-6610",
            "namespace": "debian:11",
            "description": "An out-of-bounds read vulnerability was found in smb2_dump_detail in fs/smb/client/smb2ops.c in the Linux Kernel. This issue could allow a local attacker to crash the system or leak internal kernel information.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-6610",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26589",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Reject variable offset alu on PTR_TO_FLOW_KEYS  For PTR_TO_FLOW_KEYS, check_flow_keys_access() only uses fixed off for validation. However, variable offset ptr alu is not prohibited for this ptr kind. So the variable offset is not checked.  The following prog is accepted:    func#0 @0   0: R1=ctx() R10=fp0   0: (bf) r6 = r1                       ; R1=ctx() R6_w=ctx()   1: (79) r7 = *(u64 *)(r6 +144)        ; R6_w=ctx() R7_w=flow_keys()   2: (b7) r8 = 1024                     ; R8_w=1024   3: (37) r8 /= 1                       ; R8_w=scalar()   4: (57) r8 \u0026= 1024                    ; R8_w=scalar(smin=smin32=0,   smax=umax=smax32=umax32=1024,var_off=(0x0; 0x400))   5: (0f) r7 += r8   mark_precise: frame0: last_idx 5 first_idx 0 subseq_idx -1   mark_precise: frame0: regs=r8 stack= before 4: (57) r8 \u0026= 1024   mark_precise: frame0: regs=r8 stack= before 3: (37) r8 /= 1   mark_precise: frame0: regs=r8 stack= before 2: (b7) r8 = 1024   6: R7_w=flow_keys(smin=smin32=0,smax=umax=smax32=umax32=1024,var_off   =(0x0; 0x400)) R8_w=scalar(smin=smin32=0,smax=umax=smax32=umax32=1024,   var_off=(0x0; 0x400))   6: (79) r0 = *(u64 *)(r7 +0)          ; R0_w=scalar()   7: (95) exit  This prog loads flow_keys to r7, and adds the variable offset r8 to r7, and finally causes out-of-bounds access:    BUG: unable to handle page fault for address: ffffc90014c80038   [...]   Call Trace:    \u003cTASK\u003e    bpf_dispatcher_nop_func include/linux/bpf.h:1231 [inline]    __bpf_prog_run include/linux/filter.h:651 [inline]    bpf_prog_run include/linux/filter.h:658 [inline]    bpf_prog_run_pin_on_cpu include/linux/filter.h:675 [inline]    bpf_flow_dissect+0x15f/0x350 net/core/flow_dissector.c:991    bpf_prog_test_run_flow_dissector+0x39d/0x620 net/bpf/test_run.c:1359    bpf_prog_test_run kernel/bpf/syscall.c:4107 [inline]    __sys_bpf+0xf8f/0x4560 kernel/bpf/syscall.c:5475    __do_sys_bpf kernel/bpf/syscall.c:5561 [inline]    __se_sys_bpf kernel/bpf/syscall.c:5559 [inline]    __x64_sys_bpf+0x73/0xb0 kernel/bpf/syscall.c:5559    do_syscall_x64 arch/x86/entry/common.c:52 [inline]    do_syscall_64+0x3f/0x110 arch/x86/entry/common.c:83    entry_SYSCALL_64_after_hwframe+0x63/0x6b  Fix this by rejecting ptr alu with variable offset on flow_keys. Applying the patch rejects the program with \"R7 pointer arithmetic on flow_keys prohibited\".",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26589",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "apparmor",
            "featureversion": "2.13.6-10",
            "vulnerability": "CVE-2016-1585",
            "namespace": "debian:11",
            "description": "In all versions of AppArmor mount rules are accidentally widened when compiled.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2016-1585",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "bash",
            "featureversion": "5.1-2+deb11u1",
            "vulnerability": "CVE-2022-3715",
            "namespace": "debian:11",
            "description": "A flaw was found in the bash package, where a heap-buffer overflow can occur in valid parameter_transform. This issue may lead to memory problems.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-3715",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26581",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  netfilter: nft_set_rbtree: skip end interval element from gc  rbtree lazy gc on insert might collect an end interval element that has been just added in this transactions, skip end interval elements that are not yet active.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26581",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2022-40133",
            "namespace": "debian:11",
            "description": "A use-after-free(UAF) vulnerability was found in function 'vmw_execbuf_tie_context' in drivers/gpu/vmxgfx/vmxgfx_execbuf.c in Linux kernel's vmwgfx driver with device file '/dev/dri/renderD128 (or Dxxx)'. This flaw allows a local attacker with a user account on the system to gain privilege, causing a denial of service(DoS).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-40133",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "util-linux",
            "featureversion": "2.36.1-8+deb11u1",
            "vulnerability": "CVE-2022-0563",
            "namespace": "debian:11",
            "description": "A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an \"INPUTRC\" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-0563",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2018-1121",
            "namespace": "debian:11",
            "description": "procps-ng, procps is vulnerable to a process hiding through race condition. Since the kernel's proc_pid_readdir() returns PID entries in ascending numeric order, a process occupying a high PID can use inotify events to determine when the process list is being scanned, and fork/exec to obtain a lower PID, thus avoiding enumeration. An unprivileged attacker can hide a process from procps-ng's utilities by exploiting a race condition in reading /proc/PID entries. This vulnerability affects procps and procps-ng up to version 3.3.15, newer versions might be affected also.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2018-1121",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2015-2877",
            "namespace": "debian:11",
            "description": "Kernel Samepage Merging (KSM) in the Linux kernel 2.6.32 through 4.x does not prevent use of a write-timing side channel, which allows guest OS users to defeat the ASLR protection mechanism on other guest OS instances via a Cross-VM ASL INtrospection (CAIN) attack.  NOTE: the vendor states \"Basically if you care about this attack vector, disable deduplication.\" Share-until-written approaches for memory conservation among mutually untrusting tenants are inherently detectable for information disclosure, and can be classified as potentially misunderstood behaviors rather than vulnerabilities",
            "link": "https://security-tracker.debian.org/tracker/CVE-2015-2877",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "libgcrypt20",
            "featureversion": "1.8.7-6",
            "vulnerability": "CVE-2018-6829",
            "namespace": "debian:11",
            "description": "cipher/elgamal.c in Libgcrypt through 1.8.2, when used to encrypt messages directly, improperly encodes plaintexts, which allows attackers to obtain sensitive information by reading ciphertext data (i.e., it does not have semantic security in face of a ciphertext-only attack). The Decisional Diffie-Hellman (DDH) assumption does not hold for Libgcrypt's ElGamal implementation.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2018-6829",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "pcre3",
            "featureversion": "2:8.39-13",
            "vulnerability": "CVE-2019-20838",
            "namespace": "debian:11",
            "description": "libpcre in PCRE before 8.43 allows a subject buffer over-read in JIT when UTF is disabled, and \\X or \\R has more than one fixed quantifier, a related issue to CVE-2019-20454.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-20838",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "krb5",
            "featureversion": "1.18.3-6+deb11u4",
            "vulnerability": "CVE-2018-5709",
            "namespace": "debian:11",
            "description": "An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable \"dbentry-\u003en_key_data\" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a \"u4\" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2018-5709",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "gnutls28",
            "featureversion": "3.7.1-5+deb11u4",
            "vulnerability": "CVE-2024-0567",
            "namespace": "debian:11",
            "description": "A vulnerability was found in GnuTLS, where a cockpit (which uses gnuTLS) rejects a certificate chain with distributed trust. This issue occurs when validating a certificate chain with cockpit-certificate-ensure. This flaw allows an unauthenticated, remote client or attacker to initiate a denial of service attack.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-0567",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "gnutls28",
            "featureversion": "3.7.1-5+deb11u4",
            "vulnerability": "CVE-2011-3389",
            "namespace": "debian:11",
            "description": "The SSL protocol, as used in certain configurations in Microsoft Windows and Microsoft Internet Explorer, Mozilla Firefox, Google Chrome, Opera, and other products, encrypts data by using CBC mode with chained initialization vectors, which allows man-in-the-middle attackers to obtain plaintext HTTP headers via a blockwise chosen-boundary attack (BCBA) on an HTTPS session, in conjunction with JavaScript code that uses (1) the HTML5 WebSocket API, (2) the Java URLConnection API, or (3) the Silverlight WebClient API, aka a \"BEAST\" attack.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2011-3389",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "tar",
            "featureversion": "1.34+dfsg-1+deb11u1",
            "vulnerability": "CVE-2005-2541",
            "namespace": "debian:11",
            "description": "Tar 1.15.1 does not properly warn the user when extracting setuid or setgid files, which may allow local users or remote attackers to gain privileges.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2005-2541",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "jbigkit",
            "featureversion": "2.1-3.1",
            "vulnerability": "CVE-2017-9937",
            "namespace": "debian:11",
            "description": "In LibTIFF 4.0.8, there is a memory malloc failure in tif_jbig.c. A crafted TIFF document can lead to an abort resulting in a remote denial of service attack.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2017-9937",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "libpng1.6",
            "featureversion": "1.6.37-3",
            "vulnerability": "CVE-2021-4214",
            "namespace": "debian:11",
            "description": "A heap overflow flaw was found in libpngs' pngimage.c program. This flaw allows an attacker with local network access to pass a specially crafted PNG file to the pngimage utility, causing an application to crash, leading to a denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-4214",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2019-16234",
            "namespace": "debian:11",
            "description": "drivers/net/wireless/intel/iwlwifi/pcie/trans.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-16234",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2021-47070",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  uio_hv_generic: Fix another memory leak in error handling paths  Memory allocated by 'vmbus_alloc_ring()' at the beginning of the probe function is never freed in the error handling path.  Add the missing 'vmbus_free_ring()' call.  Note that it is already freed in the .remove function.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-47070",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52494",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  bus: mhi: host: Add alignment check for event ring read pointer  Though we do check the event ring read pointer by \"is_valid_ring_ptr\" to make sure it is in the buffer range, but there is another risk the pointer may be not aligned.  Since we are expecting event ring elements are 128 bits(struct mhi_ring_element) aligned, an unaligned read pointer could lead to multiple issues like DoS or ring buffer memory corruption.  So add a alignment check for event ring read pointer.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52494",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2019-16230",
            "namespace": "debian:11",
            "description": "drivers/gpu/drm/radeon/radeon_display.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference. NOTE: A third-party software maintainer states that the work queue allocation is happening during device initialization, which for a graphics card occurs during boot. It is not attacker controllable and OOM at that time is highly unlikely",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-16230",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "coreutils",
            "featureversion": "8.32-4",
            "vulnerability": "CVE-2017-18018",
            "namespace": "debian:11",
            "description": "In GNU Coreutils through 8.29, chown-core.c in chown and chgrp does not prevent replacement of a plain file with a symlink during use of the POSIX \"-R -L\" options, which allows local users to modify the ownership of arbitrary files by leveraging a race condition.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2017-18018",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26607",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/bridge: sii902x: Fix probing race issue  A null pointer dereference crash has been observed rarely on TI platforms using sii9022 bridge:  [   53.271356]  sii902x_get_edid+0x34/0x70 [sii902x] [   53.276066]  sii902x_bridge_get_edid+0x14/0x20 [sii902x] [   53.281381]  drm_bridge_get_edid+0x20/0x34 [drm] [   53.286305]  drm_bridge_connector_get_modes+0x8c/0xcc [drm_kms_helper] [   53.292955]  drm_helper_probe_single_connector_modes+0x190/0x538 [drm_kms_helper] [   53.300510]  drm_client_modeset_probe+0x1f0/0xbd4 [drm] [   53.305958]  __drm_fb_helper_initial_config_and_unlock+0x50/0x510 [drm_kms_helper] [   53.313611]  drm_fb_helper_initial_config+0x48/0x58 [drm_kms_helper] [   53.320039]  drm_fbdev_dma_client_hotplug+0x84/0xd4 [drm_dma_helper] [   53.326401]  drm_client_register+0x5c/0xa0 [drm] [   53.331216]  drm_fbdev_dma_setup+0xc8/0x13c [drm_dma_helper] [   53.336881]  tidss_probe+0x128/0x264 [tidss] [   53.341174]  platform_probe+0x68/0xc4 [   53.344841]  really_probe+0x188/0x3c4 [   53.348501]  __driver_probe_device+0x7c/0x16c [   53.352854]  driver_probe_device+0x3c/0x10c [   53.357033]  __device_attach_driver+0xbc/0x158 [   53.361472]  bus_for_each_drv+0x88/0xe8 [   53.365303]  __device_attach+0xa0/0x1b4 [   53.369135]  device_initial_probe+0x14/0x20 [   53.373314]  bus_probe_device+0xb0/0xb4 [   53.377145]  deferred_probe_work_func+0xcc/0x124 [   53.381757]  process_one_work+0x1f0/0x518 [   53.385770]  worker_thread+0x1e8/0x3dc [   53.389519]  kthread+0x11c/0x120 [   53.392750]  ret_from_fork+0x10/0x20  The issue here is as follows:  - tidss probes, but is deferred as sii902x is still missing. - sii902x starts probing and enters sii902x_init(). - sii902x calls drm_bridge_add(). Now the sii902x bridge is ready from   DRM's perspective. - sii902x calls sii902x_audio_codec_init() and   platform_device_register_data() - The registration of the audio platform device causes probing of the   deferred devices. - tidss probes, which eventually causes sii902x_bridge_get_edid() to be   called. - sii902x_bridge_get_edid() tries to use the i2c to read the edid.   However, the sii902x driver has not set up the i2c part yet, leading   to the crash.  Fix this by moving the drm_bridge_add() to the end of the sii902x_init(), which is also at the very end of sii902x_probe().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26607",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "pcre3",
            "featureversion": "2:8.39-13",
            "vulnerability": "CVE-2017-7246",
            "namespace": "debian:11",
            "description": "Stack-based buffer overflow in the pcre32_copy_substring function in pcre_get.c in libpcre1 in PCRE 8.40 allows remote attackers to cause a denial of service (WRITE of size 268) or possibly have unspecified other impact via a crafted file.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2017-7246",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-1192",
            "namespace": "debian:11",
            "description": "A use-after-free flaw was found in smb2_is_status_io_timeout() in CIFS in the Linux Kernel. After CIFS transfers response data to a system call, there are still local variable points to the memory region, and if the system call frees it faster than CIFS uses it, CIFS will access a free memory region, leading to a denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1192",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26643",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  netfilter: nf_tables: mark set as dead when unbinding anonymous set with timeout  While the rhashtable set gc runs asynchronously, a race allows it to collect elements from anonymous sets with timeouts while it is being released from the commit path.  Mingi Cho originally reported this issue in a different path in 6.1.x with a pipapo set with low timeouts which is not possible upstream since 7395dfacfff6 (\"netfilter: nf_tables: use timestamp to check for set element timeout\").  Fix this by setting on the dead flag for anonymous sets to skip async gc in this case.  According to 08e4c8c5919f (\"netfilter: nf_tables: mark newset as dead on transaction abort\"), Florian plans to accelerate abort path by releasing objects via workqueue, therefore, this sets on the dead flag for abort path too.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26643",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-1075",
            "namespace": "debian:11",
            "description": "A flaw was found in the Linux Kernel. The tls_is_tx_ready() incorrectly checks for list emptiness, potentially accessing a type confused entry to the list_head, leaking the last byte of the confused field that overlaps with rec-\u003etx_ready.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-1075",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2021-47178",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: target: core: Avoid smp_processor_id() in preemptible code  The BUG message \"BUG: using smp_processor_id() in preemptible [00000000] code\" was observed for TCMU devices with kernel config DEBUG_PREEMPT.  The message was observed when blktests block/005 was run on TCMU devices with fileio backend or user:zbc backend [1]. The commit 1130b499b4a7 (\"scsi: target: tcm_loop: Use LIO wq cmd submission helper\") triggered the symptom. The commit modified work queue to handle commands and changed 'current-\u003enr_cpu_allowed' at smp_processor_id() call.  The message was also observed at system shutdown when TCMU devices were not cleaned up [2]. The function smp_processor_id() was called in SCSI host work queue for abort handling, and triggered the BUG message. This symptom was observed regardless of the commit 1130b499b4a7 (\"scsi: target: tcm_loop: Use LIO wq cmd submission helper\").  To avoid the preemptible code check at smp_processor_id(), get CPU ID with raw_smp_processor_id() instead. The CPU ID is used for performance improvement then thread move to other CPU will not affect the code.  [1]  [   56.468103] run blktests block/005 at 2021-05-12 14:16:38 [   57.369473] check_preemption_disabled: 85 callbacks suppressed [   57.369480] BUG: using smp_processor_id() in preemptible [00000000] code: fio/1511 [   57.369506] BUG: using smp_processor_id() in preemptible [00000000] code: fio/1510 [   57.369512] BUG: using smp_processor_id() in preemptible [00000000] code: fio/1506 [   57.369552] caller is __target_init_cmd+0x157/0x170 [target_core_mod] [   57.369606] CPU: 4 PID: 1506 Comm: fio Not tainted 5.13.0-rc1+ #34 [   57.369613] Hardware name: System manufacturer System Product Name/PRIME Z270-A, BIOS 1302 03/15/2018 [   57.369617] Call Trace: [   57.369621] BUG: using smp_processor_id() in preemptible [00000000] code: fio/1507 [   57.369628]  dump_stack+0x6d/0x89 [   57.369642]  check_preemption_disabled+0xc8/0xd0 [   57.369628] caller is __target_init_cmd+0x157/0x170 [target_core_mod] [   57.369655]  __target_init_cmd+0x157/0x170 [target_core_mod] [   57.369695]  target_init_cmd+0x76/0x90 [target_core_mod] [   57.369732]  tcm_loop_queuecommand+0x109/0x210 [tcm_loop] [   57.369744]  scsi_queue_rq+0x38e/0xc40 [   57.369761]  __blk_mq_try_issue_directly+0x109/0x1c0 [   57.369779]  blk_mq_try_issue_directly+0x43/0x90 [   57.369790]  blk_mq_submit_bio+0x4e5/0x5d0 [   57.369812]  submit_bio_noacct+0x46e/0x4e0 [   57.369830]  __blkdev_direct_IO_simple+0x1a3/0x2d0 [   57.369859]  ? set_init_blocksize.isra.0+0x60/0x60 [   57.369880]  generic_file_read_iter+0x89/0x160 [   57.369898]  blkdev_read_iter+0x44/0x60 [   57.369906]  new_sync_read+0x102/0x170 [   57.369929]  vfs_read+0xd4/0x160 [   57.369941]  __x64_sys_pread64+0x6e/0xa0 [   57.369946]  ? lockdep_hardirqs_on+0x79/0x100 [   57.369958]  do_syscall_64+0x3a/0x70 [   57.369965]  entry_SYSCALL_64_after_hwframe+0x44/0xae [   57.369973] RIP: 0033:0x7f7ed4c1399f [   57.369979] Code: 08 89 3c 24 48 89 4c 24 18 e8 7d f3 ff ff 4c 8b 54 24 18 48 8b 54 24 10 41 89 c0 48 8b 74 24 08 8b 3c 24 b8 11 00 00 00 0f 05 \u003c48\u003e 3d 00 f0 ff ff 77 31 44 89 c7 48 89 04 24 e8 cd f3 ff ff 48 8b [   57.369983] RSP: 002b:00007ffd7918c580 EFLAGS: 00000293 ORIG_RAX: 0000000000000011 [   57.369990] RAX: ffffffffffffffda RBX: 00000000015b4540 RCX: 00007f7ed4c1399f [   57.369993] RDX: 0000000000001000 RSI: 00000000015de000 RDI: 0000000000000009 [   57.369996] RBP: 00000000015b4540 R08: 0000000000000000 R09: 0000000000000001 [   57.369999] R10: 0000000000e5c000 R11: 0000000000000293 R12: 00007f7eb5269a70 [   57.370002] R13: 0000000000000000 R14: 0000000000001000 R15: 00000000015b4568 [   57.370031] CPU: 7 PID: 1507 Comm: fio Not tainted 5.13.0-rc1+ #34 [   57.370036] Hardware name: System manufacturer System Product Name/PRIME Z270-A, BIOS 1302 03/15/2018 [   57.370039] Call Trace: [   57.370045]  dump_stack+0x6d/0x89 [   57.370056]  ch ---truncated---",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-47178",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2022-25265",
            "namespace": "debian:11",
            "description": "In the Linux kernel through 5.16.10, certain binary files may have the exec-all attribute if they were built in approximately 2003 (e.g., with GCC 3.2.2 and Linux kernel 2.4.20). This can cause execution of bytes located in supposedly non-executable regions of a file.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-25265",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52627",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  iio: adc: ad7091r: Allow users to configure device events  AD7091R-5 devices are supported by the ad7091r-5 driver together with the ad7091r-base driver. Those drivers declared iio events for notifying user space when ADC readings fall bellow the thresholds of low limit registers or above the values set in high limit registers. However, to configure iio events and their thresholds, a set of callback functions must be implemented and those were not present until now. The consequence of trying to configure ad7091r-5 events without the proper callback functions was a null pointer dereference in the kernel because the pointers to the callback functions were not set.  Implement event configuration callbacks allowing users to read/write event thresholds and enable/disable event generation.  Since the event spec structs are generic to AD7091R devices, also move those from the ad7091r-5 driver the base driver so they can be reused when support for ad7091r-2/-4/-8 be added.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52627",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2004-0230",
            "namespace": "debian:11",
            "description": "TCP, when using a large Window Size, makes it easier for remote attackers to guess sequence numbers and cause a denial of service (connection loss) to persistent TCP connections by repeatedly injecting a TCP RST packet, especially in protocols that use long-lived connections, such as BGP.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2004-0230",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "pcre3",
            "featureversion": "2:8.39-13",
            "vulnerability": "CVE-2017-11164",
            "namespace": "debian:11",
            "description": "In PCRE 8.41, the OP_KETRMAX feature in the match function in pcre_exec.c allows stack exhaustion (uncontrolled recursion) when processing a crafted regular expression.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2017-11164",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52497",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  erofs: fix lz4 inplace decompression  Currently EROFS can map another compressed buffer for inplace decompression, that was used to handle the cases that some pages of compressed data are actually not in-place I/O.  However, like most simple LZ77 algorithms, LZ4 expects the compressed data is arranged at the end of the decompressed buffer and it explicitly uses memmove() to handle overlapping:   __________________________________________________________  |_ direction of decompression --\u003e ____ |_ compressed data _|  Although EROFS arranges compressed data like this, it typically maps two individual virtual buffers so the relative order is uncertain. Previously, it was hardly observed since LZ4 only uses memmove() for short overlapped literals and x86/arm64 memmove implementations seem to completely cover it up and they don't have this issue.  Juhyung reported that EROFS data corruption can be found on a new Intel x86 processor. After some analysis, it seems that recent x86 processors with the new FSRM feature expose this issue with \"rep movsb\".  Let's strictly use the decompressed buffer for lz4 inplace decompression for now.  Later, as an useful improvement, we could try to tie up these two buffers together in the correct order.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52497",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-26242",
            "namespace": "debian:11",
            "description": "afu_mmio_region_get_by_offset in drivers/fpga/dfl-afu-region.c in the Linux kernel through 6.1.12 has an integer overflow.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-26242",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2017-0630",
            "namespace": "debian:11",
            "description": "An information disclosure vulnerability in the kernel trace subsystem could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it first requires compromising a privileged process. Product: Android. Versions: Kernel-3.10, Kernel-3.18. Android ID: A-34277115.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2017-0630",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2021-47037",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  ASoC: q6afe-clocks: fix reprobing of the driver  Q6afe-clocks driver can get reprobed. For example if the APR services are restarted after the firmware crash. However currently Q6afe-clocks driver will oops because hw.init will get cleared during first _probe call. Rewrite the driver to fill the clock data at runtime rather than using big static array of clocks.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-47037",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "pcre3",
            "featureversion": "2:8.39-13",
            "vulnerability": "CVE-2017-7245",
            "namespace": "debian:11",
            "description": "Stack-based buffer overflow in the pcre32_copy_substring function in pcre_get.c in libpcre1 in PCRE 8.40 allows remote attackers to cause a denial of service (WRITE of size 4) or possibly have unspecified other impact via a crafted file.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2017-7245",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2021-46937",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  mm/damon/dbgfs: fix 'struct pid' leaks in 'dbgfs_target_ids_write()'  DAMON debugfs interface increases the reference counts of 'struct pid's for targets from the 'target_ids' file write callback ('dbgfs_target_ids_write()'), but decreases the counts only in DAMON monitoring termination callback ('dbgfs_before_terminate()').  Therefore, when 'target_ids' file is repeatedly written without DAMON monitoring start/termination, the reference count is not decreased and therefore memory for the 'struct pid' cannot be freed.  This commit fixes this issue by decreasing the reference counts when 'target_ids' is written.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-46937",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2019-19070",
            "namespace": "debian:11",
            "description": "A memory leak in the spi_gpio_probe() function in drivers/spi/spi-gpio.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering devm_add_action_or_reset() failures, aka CID-d3b0ffa1d75d. NOTE: third parties dispute the relevance of this because the system must have already been out of memory before the probe began",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-19070",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "libzstd",
            "featureversion": "1.4.8+dfsg-2.1",
            "vulnerability": "CVE-2022-4899",
            "namespace": "debian:11",
            "description": "A vulnerability was found in zstd v1.4.10, where an attacker can supply empty string as an argument to the command line tool to cause buffer overrun.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-4899",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-3640",
            "namespace": "debian:11",
            "description": "A possible unauthorized memory access flaw was found in the Linux kernel's cpu_entry_area mapping of X86 CPU data to memory, where a user may guess the location of exception stacks or other important data. Based on the previous CVE-2023-0597, the 'Randomize per-cpu entry area' feature was implemented in /arch/x86/mm/cpu_entry_area.c, which works through the init_cea_offsets() function when KASLR is enabled. However, despite this feature, there is still a risk of per-cpu entry area leaks. This issue could allow a local user to gain access to some important data with memory in an expected location and potentially escalate their privileges on the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3640",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2012-4542",
            "namespace": "debian:11",
            "description": "block/scsi_ioctl.c in the Linux kernel through 3.8 does not properly consider the SCSI device class during authorization of SCSI commands, which allows local users to bypass intended access restrictions via an SG_IO ioctl call that leverages overlapping opcodes.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2012-4542",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26583",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  tls: fix race between async notify and socket close  The submitting thread (one which called recvmsg/sendmsg) may exit as soon as the async crypto handler calls complete() so any code past that point risks touching already freed data.  Try to avoid the locking and extra flags altogether. Have the main thread hold an extra reference, this way we can depend solely on the atomic ref counter for synchronization.  Don't futz with reiniting the completion, either, we are now tightly controlling when completion fires.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26583",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2021-32078",
            "namespace": "debian:11",
            "description": "An Out-of-Bounds Read was discovered in arch/arm/mach-footbridge/personal-pci.c in the Linux kernel through 5.12.11 because of the lack of a check for a value that shouldn't be negative, e.g., access to element -2 of an array, aka CID-298a58e165e4.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-32078",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2021-4023",
            "namespace": "debian:11",
            "description": "A flaw was found in the io-workqueue implementation in the Linux kernel versions prior to 5.15-rc1. The kernel can panic when an improper cancellation operation triggers the submission of new io-uring operations during a shortage of free space. This flaw allows a local user with permissions to execute io-uring requests to possibly crash the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-4023",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2019-11191",
            "namespace": "debian:11",
            "description": "The Linux kernel through 5.0.7, when CONFIG_IA32_AOUT is enabled and ia32_aout is loaded, allows local users to bypass ASLR on setuid a.out programs (if any exist) because install_exec_creds() is called too late in load_aout_binary() in fs/binfmt_aout.c, and thus the ptrace_may_access() check has a race condition when reading /proc/pid/stat. NOTE: the software maintainer disputes that this is a vulnerability because ASLR for a.out format executables has never been supported",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-11191",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2021-47105",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  ice: xsk: return xsk buffers back to pool when cleaning the ring  Currently we only NULL the xdp_buff pointer in the internal SW ring but we never give it back to the xsk buffer pool. This means that buffers can be leaked out of the buff pool and never be used again.  Add missing xsk_buff_free() call to the routine that is supposed to clean the entries that are left in the ring so that these buffers in the umem can be used by other sockets.  Also, only go through the space that is actually left to be cleaned instead of a whole ring.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-47105",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2022-0400",
            "namespace": "debian:11",
            "description": "An out-of-bounds read vulnerability was discovered in linux kernel in the smc protocol stack, causing remote dos.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-0400",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2020-24504",
            "namespace": "debian:11",
            "description": "Uncontrolled resource consumption in some Intel(R) Ethernet E810 Adapter drivers for Linux before version 1.0.4 may allow an authenticated user to potentially enable denial of service via local access.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-24504",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2020-11725",
            "namespace": "debian:11",
            "description": "snd_ctl_elem_add in sound/core/control.c in the Linux kernel through 5.6.3 has a count=info-\u003eowner line, which later affects a private_size*count multiplication for unspecified \"interesting side effects.\" NOTE: kernel engineers dispute this finding, because it could be relevant only if new callers were added that were unfamiliar with the misuse of the info-\u003eowner field to represent data unrelated to the \"owner\" concept. The existing callers, SNDRV_CTL_IOCTL_ELEM_ADD and SNDRV_CTL_IOCTL_ELEM_REPLACE, have been designed to misuse the info-\u003eowner field in a safe way",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-11725",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-23003",
            "namespace": "debian:11",
            "description": "In the Linux kernel before 5.16, tools/perf/util/expr.c lacks a check for the hashmap__new return value.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-23003",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-31081",
            "namespace": "debian:11",
            "description": "An issue was discovered in drivers/media/test-drivers/vidtv/vidtv_bridge.c in the Linux kernel 6.2. There is a NULL pointer dereference in vidtv_mux_stop_thread. In vidtv_stop_streaming, after dvb-\u003emux=NULL occurs, it executes vidtv_mux_stop_thread(dvb-\u003emux).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-31081",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2018-17977",
            "namespace": "debian:11",
            "description": "The Linux kernel 4.14.67 mishandles certain interaction among XFRM Netlink messages, IPPROTO_AH packets, and IPPROTO_IP packets, which allows local users to cause a denial of service (memory consumption and system hang) by leveraging root access to execute crafted applications, as demonstrated on CentOS 7.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2018-17977",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-23000",
            "namespace": "debian:11",
            "description": "In the Linux kernel before 5.17, drivers/phy/tegra/xusb.c mishandles the tegra_xusb_find_port_node return value. Callers expect NULL in the error case, but an error pointer is used.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-23000",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2022-3114",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 5.16-rc6. imx_register_uart_clocks in drivers/clk/imx/clk.c lacks check of the return value of kcalloc() and will cause the null pointer dereference.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-3114",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2011-4916",
            "namespace": "debian:11",
            "description": "Linux kernel through 3.1 allows local users to obtain sensitive keystroke information via access to /dev/pts/ and /dev/tty*.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2011-4916",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2017-13694",
            "namespace": "debian:11",
            "description": "The acpi_ps_complete_final_op() function in drivers/acpi/acpica/psobject.c in the Linux kernel through 4.12.9 does not flush the node and node_ext caches and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2017-13694",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2008-4609",
            "namespace": "debian:11",
            "description": "The TCP implementation in (1) Linux, (2) platforms based on BSD Unix, (3) Microsoft Windows, (4) Cisco products, and probably other operating systems allows remote attackers to cause a denial of service (connection queue exhaustion) via multiple vectors that manipulate information in the TCP state table, as demonstrated by sockstress.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2008-4609",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-28746",
            "namespace": "debian:11",
            "description": "Information exposure through microarchitectural state after transient execution from some register files for some Intel(R) Atom(R) Processors may allow an authenticated user to potentially enable information disclosure via local access.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-28746",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-31085",
            "namespace": "debian:11",
            "description": "An issue was discovered in drivers/mtd/ubi/cdev.c in the Linux kernel 6.2. There is a divide-by-zero error in do_div(sz,mtd-\u003eerasesize), used indirectly by ctrl_cdev_ioctl, when mtd-\u003eerasesize is 0.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-31085",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52492",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  dmaengine: fix NULL pointer in channel unregistration function  __dma_async_device_channel_register() can fail. In case of failure, chan-\u003elocal is freed (with free_percpu()), and chan-\u003elocal is nullified. When dma_async_device_unregister() is called (because of managed API or intentionally by DMA controller driver), channels are unconditionally unregistered, leading to this NULL pointer: [    1.318693] Unable to handle kernel NULL pointer dereference at virtual address 00000000000000d0 [...] [    1.484499] Call trace: [    1.486930]  device_del+0x40/0x394 [    1.490314]  device_unregister+0x20/0x7c [    1.494220]  __dma_async_device_channel_unregister+0x68/0xc0  Look at dma_async_device_register() function error path, channel device unregistration is done only if chan-\u003elocal is not NULL.  Then add the same condition at the beginning of __dma_async_device_channel_unregister() function, to avoid NULL pointer issue whatever the API used to reach this function.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52492",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26593",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  i2c: i801: Fix block process call transactions  According to the Intel datasheets, software must reset the block buffer index twice for block process call transactions: once before writing the outgoing data to the buffer, and once again before reading the incoming data from the buffer.  The driver is currently missing the second reset, causing the wrong portion of the block buffer to be read.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26593",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2021-47014",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  net/sched: act_ct: fix wild memory access when clearing fragments  while testing re-assembly/re-fragmentation using act_ct, it's possible to observe a crash like the following one:   KASAN: maybe wild-memory-access in range [0x0001000000000448-0x000100000000044f]  CPU: 50 PID: 0 Comm: swapper/50 Tainted: G S                5.12.0-rc7+ #424  Hardware name: Dell Inc. PowerEdge R730/072T6D, BIOS 2.4.3 01/17/2017  RIP: 0010:inet_frag_rbtree_purge+0x50/0xc0  Code: 00 fc ff df 48 89 c3 31 ed 48 89 df e8 a9 7a 38 ff 4c 89 fe 48 89 df 49 89 c6 e8 5b 3a 38 ff 48 8d 7b 40 48 89 f8 48 c1 e8 03 \u003c42\u003e 80 3c 20 00 75 59 48 8d bb d0 00 00 00 4c 8b 6b 40 48 89 f8 48  RSP: 0018:ffff888c31449db8 EFLAGS: 00010203  RAX: 0000200000000089 RBX: 000100000000040e RCX: ffffffff989eb960  RDX: 0000000000000140 RSI: ffffffff97cfb977 RDI: 000100000000044e  RBP: 0000000000000900 R08: 0000000000000000 R09: ffffed1186289350  R10: 0000000000000003 R11: ffffed1186289350 R12: dffffc0000000000  R13: 000100000000040e R14: 0000000000000000 R15: ffff888155e02160  FS:  0000000000000000(0000) GS:ffff888c31440000(0000) knlGS:0000000000000000  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033  CR2: 00005600cb70a5b8 CR3: 0000000a2c014005 CR4: 00000000003706e0  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400  Call Trace:   \u003cIRQ\u003e   inet_frag_destroy+0xa9/0x150   call_timer_fn+0x2d/0x180   run_timer_softirq+0x4fe/0xe70   __do_softirq+0x197/0x5a0   irq_exit_rcu+0x1de/0x200   sysvec_apic_timer_interrupt+0x6b/0x80   \u003c/IRQ\u003e  when act_ct temporarily stores an IP fragment, restoring the skb qdisc cb results in putting random data in FRAG_CB(), and this causes those \"wild\" memory accesses later, when the rbtree is purged. Never overwrite the skb cb in case tcf_ct_handle_fragments() returns -EINPROGRESS.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-47014",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2021-3714",
            "namespace": "debian:11",
            "description": "A flaw was found in the Linux kernels memory deduplication mechanism. Previous work has shown that memory deduplication can be attacked via a local exploitation mechanism. The same technique can be used if an attacker can upload page sized files and detect the change in access time from a networked service to determine if the page has been merged.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-3714",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-2193",
            "namespace": "debian:11",
            "description": "A Speculative Race Condition (SRC) vulnerability that impacts modern CPU architectures supporting speculative execution (related to Spectre V1) has been disclosed. An unauthenticated attacker can exploit this vulnerability to disclose arbitrary data from the CPU using race conditions to access the speculative executable code paths.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-2193",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-22995",
            "namespace": "debian:11",
            "description": "In the Linux kernel before 5.17, an error path in dwc3_qcom_acpi_register_core in drivers/usb/dwc3/dwc3-qcom.c lacks certain platform_device_put and kfree calls.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-22995",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2022-27672",
            "namespace": "debian:11",
            "description": "When SMT is enabled, certain AMD processors may speculatively execute instructions using a target from the sibling thread after an SMT mode switch potentially resulting in information disclosure.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-27672",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2019-16229",
            "namespace": "debian:11",
            "description": "drivers/gpu/drm/amd/amdkfd/kfd_interrupt.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference. NOTE: The security community disputes this issues as not being serious enough to be deserving a CVE id",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-16229",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2019-12381",
            "namespace": "debian:11",
            "description": "An issue was discovered in ip_ra_control in net/ipv4/ip_sockglue.c in the Linux kernel through 5.1.5. There is an unchecked kmalloc of new_ra, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: this is disputed because new_ra is never used if it is NULL",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-12381",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "elfutils",
            "featureversion": "0.183-1",
            "vulnerability": "CVE-2024-25260",
            "namespace": "debian:11",
            "description": "elfutils v0.189 was discovered to contain a NULL pointer dereference via the handle_verdef() function at readelf.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-25260",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52608",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  firmware: arm_scmi: Check mailbox/SMT channel for consistency  On reception of a completion interrupt the shared memory area is accessed to retrieve the message header at first and then, if the message sequence number identifies a transaction which is still pending, the related payload is fetched too.  When an SCMI command times out the channel ownership remains with the platform until eventually a late reply is received and, as a consequence, any further transmission attempt remains pending, waiting for the channel to be relinquished by the platform.  Once that late reply is received the channel ownership is given back to the agent and any pending request is then allowed to proceed and overwrite the SMT area of the just delivered late reply; then the wait for the reply to the new request starts.  It has been observed that the spurious IRQ related to the late reply can be wrongly associated with the freshly enqueued request: when that happens the SCMI stack in-flight lookup procedure is fooled by the fact that the message header now present in the SMT area is related to the new pending transaction, even though the real reply has still to arrive.  This race-condition on the A2P channel can be detected by looking at the channel status bits: a genuine reply from the platform will have set the channel free bit before triggering the completion IRQ.  Add a consistency check to validate such condition in the A2P ISR.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52608",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52610",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  net/sched: act_ct: fix skb leak and crash on ooo frags  act_ct adds skb-\u003eusers before defragmentation. If frags arrive in order, the last frag's reference is reset in:    inet_frag_reasm_prepare     skb_morph  which is not straightforward.  However when frags arrive out of order, nobody unref the last frag, and all frags are leaked. The situation is even worse, as initiating packet capture can lead to a crash[0] when skb has been cloned and shared at the same time.  Fix the issue by removing skb_get() before defragmentation. act_ct returns TC_ACT_CONSUMED when defrag failed or in progress.  [0]: [  843.804823] ------------[ cut here ]------------ [  843.809659] kernel BUG at net/core/skbuff.c:2091! [  843.814516] invalid opcode: 0000 [#1] PREEMPT SMP [  843.819296] CPU: 7 PID: 0 Comm: swapper/7 Kdump: loaded Tainted: G S 6.7.0-rc3 #2 [  843.824107] Hardware name: XFUSION 1288H V6/BC13MBSBD, BIOS 1.29 11/25/2022 [  843.828953] RIP: 0010:pskb_expand_head+0x2ac/0x300 [  843.833805] Code: 8b 70 28 48 85 f6 74 82 48 83 c6 08 bf 01 00 00 00 e8 38 bd ff ff 8b 83 c0 00 00 00 48 03 83 c8 00 00 00 e9 62 ff ff ff 0f 0b \u003c0f\u003e 0b e8 8d d0 ff ff e9 b3 fd ff ff 81 7c 24 14 40 01 00 00 4c 89 [  843.843698] RSP: 0018:ffffc9000cce07c0 EFLAGS: 00010202 [  843.848524] RAX: 0000000000000002 RBX: ffff88811a211d00 RCX: 0000000000000820 [  843.853299] RDX: 0000000000000640 RSI: 0000000000000000 RDI: ffff88811a211d00 [  843.857974] RBP: ffff888127d39518 R08: 00000000bee97314 R09: 0000000000000000 [  843.862584] R10: 0000000000000000 R11: ffff8881109f0000 R12: 0000000000000880 [  843.867147] R13: ffff888127d39580 R14: 0000000000000640 R15: ffff888170f7b900 [  843.871680] FS:  0000000000000000(0000) GS:ffff889ffffc0000(0000) knlGS:0000000000000000 [  843.876242] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [  843.880778] CR2: 00007fa42affcfb8 CR3: 000000011433a002 CR4: 0000000000770ef0 [  843.885336] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [  843.889809] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [  843.894229] PKRU: 55555554 [  843.898539] Call Trace: [  843.902772]  \u003cIRQ\u003e [  843.906922]  ? __die_body+0x1e/0x60 [  843.911032]  ? die+0x3c/0x60 [  843.915037]  ? do_trap+0xe2/0x110 [  843.918911]  ? pskb_expand_head+0x2ac/0x300 [  843.922687]  ? do_error_trap+0x65/0x80 [  843.926342]  ? pskb_expand_head+0x2ac/0x300 [  843.929905]  ? exc_invalid_op+0x50/0x60 [  843.933398]  ? pskb_expand_head+0x2ac/0x300 [  843.936835]  ? asm_exc_invalid_op+0x1a/0x20 [  843.940226]  ? pskb_expand_head+0x2ac/0x300 [  843.943580]  inet_frag_reasm_prepare+0xd1/0x240 [  843.946904]  ip_defrag+0x5d4/0x870 [  843.950132]  nf_ct_handle_fragments+0xec/0x130 [nf_conntrack] [  843.953334]  tcf_ct_act+0x252/0xd90 [act_ct] [  843.956473]  ? tcf_mirred_act+0x516/0x5a0 [act_mirred] [  843.959657]  tcf_action_exec+0xa1/0x160 [  843.962823]  fl_classify+0x1db/0x1f0 [cls_flower] [  843.966010]  ? skb_clone+0x53/0xc0 [  843.969173]  tcf_classify+0x24d/0x420 [  843.972333]  tc_run+0x8f/0xf0 [  843.975465]  __netif_receive_skb_core+0x67a/0x1080 [  843.978634]  ? dev_gro_receive+0x249/0x730 [  843.981759]  __netif_receive_skb_list_core+0x12d/0x260 [  843.984869]  netif_receive_skb_list_internal+0x1cb/0x2f0 [  843.987957]  ? mlx5e_handle_rx_cqe_mpwrq_rep+0xfa/0x1a0 [mlx5_core] [  843.991170]  napi_complete_done+0x72/0x1a0 [  843.994305]  mlx5e_napi_poll+0x28c/0x6d0 [mlx5_core] [  843.997501]  __napi_poll+0x25/0x1b0 [  844.000627]  net_rx_action+0x256/0x330 [  844.003705]  __do_softirq+0xb3/0x29b [  844.006718]  irq_exit_rcu+0x9e/0xc0 [  844.009672]  common_interrupt+0x86/0xa0 [  844.012537]  \u003c/IRQ\u003e [  844.015285]  \u003cTASK\u003e [  844.017937]  asm_common_interrupt+0x26/0x40 [  844.020591] RIP: 0010:acpi_safe_halt+0x1b/0x20 [  844.023247] Code: ff 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 65 48 8b 04 25 00 18 03 00 48 8b 00 a8 08 75 0c 66 90 0f 00 2d 81 d0 44 00 fb ---truncated---",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52610",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-4134",
            "namespace": "debian:11",
            "description": "",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4134",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2010-4563",
            "namespace": "debian:11",
            "description": "The Linux kernel, when using IPv6, allows remote attackers to determine whether a host is sniffing the network by sending an ICMPv6 Echo Request to a multicast address and determining whether an Echo Reply is sent, as demonstrated by thcping.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2010-4563",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2022-0500",
            "namespace": "debian:11",
            "description": "A flaw was found in unrestricted eBPF usage by the BPF_BTF_LOAD, leading to a possible out-of-bounds memory write in the Linux kernel’s BPF subsystem due to the way a user loads BTF. This flaw allows a local user to crash or escalate their privileges on the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-0500",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52493",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  bus: mhi: host: Drop chan lock before queuing buffers  Ensure read and write locks for the channel are not taken in succession by dropping the read lock from parse_xfer_event() such that a callback given to client can potentially queue buffers and acquire the write lock in that process. Any queueing of buffers should be done without channel read lock acquired as it can result in multiple locks and a soft lockup.  [mani: added fixes tag and cc'ed stable]",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52493",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2019-12379",
            "namespace": "debian:11",
            "description": "An issue was discovered in con_insert_unipair in drivers/tty/vt/consolemap.c in the Linux kernel through 5.1.5. There is a memory leak in a certain case of an ENOMEM outcome of kmalloc. NOTE: This id is disputed as not being an issue",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-12379",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "elfutils",
            "featureversion": "0.183-1",
            "vulnerability": "CVE-2021-33294",
            "namespace": "debian:11",
            "description": "In elfutils 0.183, an infinite loop was found in the function handle_symtab in readelf.c .Which allows attackers to cause a denial of service (infinite loop) via crafted file.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-33294",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2010-5321",
            "namespace": "debian:11",
            "description": "Memory leak in drivers/media/video/videobuf-core.c in the videobuf subsystem in the Linux kernel 2.6.x through 4.x allows local users to cause a denial of service (memory consumption) by leveraging /dev/video access for a series of mmap calls that require new allocations, a different vulnerability than CVE-2007-6761.  NOTE: as of 2016-06-18, this affects only 11 drivers that have not been updated to use videobuf2 instead of videobuf.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2010-5321",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2021-46987",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: fix deadlock when cloning inline extents and using qgroups  There are a few exceptional cases where cloning an inline extent needs to copy the inline extent data into a page of the destination inode.  When this happens, we end up starting a transaction while having a dirty page for the destination inode and while having the range locked in the destination's inode iotree too. Because when reserving metadata space for a transaction we may need to flush existing delalloc in case there is not enough free space, we have a mechanism in place to prevent a deadlock, which was introduced in commit 3d45f221ce627d (\"btrfs: fix deadlock when cloning inline extent and low on free metadata space\").  However when using qgroups, a transaction also reserves metadata qgroup space, which can also result in flushing delalloc in case there is not enough available space at the moment. When this happens we deadlock, since flushing delalloc requires locking the file range in the inode's iotree and the range was already locked at the very beginning of the clone operation, before attempting to start the transaction.  When this issue happens, stack traces like the following are reported:    [72747.556262] task:kworker/u81:9   state:D stack:    0 pid:  225 ppid:     2 flags:0x00004000   [72747.556268] Workqueue: writeback wb_workfn (flush-btrfs-1142)   [72747.556271] Call Trace:   [72747.556273]  __schedule+0x296/0x760   [72747.556277]  schedule+0x3c/0xa0   [72747.556279]  io_schedule+0x12/0x40   [72747.556284]  __lock_page+0x13c/0x280   [72747.556287]  ? generic_file_readonly_mmap+0x70/0x70   [72747.556325]  extent_write_cache_pages+0x22a/0x440 [btrfs]   [72747.556331]  ? __set_page_dirty_nobuffers+0xe7/0x160   [72747.556358]  ? set_extent_buffer_dirty+0x5e/0x80 [btrfs]   [72747.556362]  ? update_group_capacity+0x25/0x210   [72747.556366]  ? cpumask_next_and+0x1a/0x20   [72747.556391]  extent_writepages+0x44/0xa0 [btrfs]   [72747.556394]  do_writepages+0x41/0xd0   [72747.556398]  __writeback_single_inode+0x39/0x2a0   [72747.556403]  writeback_sb_inodes+0x1ea/0x440   [72747.556407]  __writeback_inodes_wb+0x5f/0xc0   [72747.556410]  wb_writeback+0x235/0x2b0   [72747.556414]  ? get_nr_inodes+0x35/0x50   [72747.556417]  wb_workfn+0x354/0x490   [72747.556420]  ? newidle_balance+0x2c5/0x3e0   [72747.556424]  process_one_work+0x1aa/0x340   [72747.556426]  worker_thread+0x30/0x390   [72747.556429]  ? create_worker+0x1a0/0x1a0   [72747.556432]  kthread+0x116/0x130   [72747.556435]  ? kthread_park+0x80/0x80   [72747.556438]  ret_from_fork+0x1f/0x30    [72747.566958] Workqueue: btrfs-flush_delalloc btrfs_work_helper [btrfs]   [72747.566961] Call Trace:   [72747.566964]  __schedule+0x296/0x760   [72747.566968]  ? finish_wait+0x80/0x80   [72747.566970]  schedule+0x3c/0xa0   [72747.566995]  wait_extent_bit.constprop.68+0x13b/0x1c0 [btrfs]   [72747.566999]  ? finish_wait+0x80/0x80   [72747.567024]  lock_extent_bits+0x37/0x90 [btrfs]   [72747.567047]  btrfs_invalidatepage+0x299/0x2c0 [btrfs]   [72747.567051]  ? find_get_pages_range_tag+0x2cd/0x380   [72747.567076]  __extent_writepage+0x203/0x320 [btrfs]   [72747.567102]  extent_write_cache_pages+0x2bb/0x440 [btrfs]   [72747.567106]  ? update_load_avg+0x7e/0x5f0   [72747.567109]  ? enqueue_entity+0xf4/0x6f0   [72747.567134]  extent_writepages+0x44/0xa0 [btrfs]   [72747.567137]  ? enqueue_task_fair+0x93/0x6f0   [72747.567140]  do_writepages+0x41/0xd0   [72747.567144]  __filemap_fdatawrite_range+0xc7/0x100   [72747.567167]  btrfs_run_delalloc_work+0x17/0x40 [btrfs]   [72747.567195]  btrfs_work_helper+0xc2/0x300 [btrfs]   [72747.567200]  process_one_work+0x1aa/0x340   [72747.567202]  worker_thread+0x30/0x390   [72747.567205]  ? create_worker+0x1a0/0x1a0   [72747.567208]  kthread+0x116/0x130   [72747.567211]  ? kthread_park+0x80/0x80   [72747.567214]  ret_from_fork+0x1f/0x30    [72747.569686] task:fsstress        state:D stack:     ---truncated---",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-46987",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2021-47036",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  udp: skip L4 aggregation for UDP tunnel packets  If NETIF_F_GRO_FRAGLIST or NETIF_F_GRO_UDP_FWD are enabled, and there are UDP tunnels available in the system, udp_gro_receive() could end-up doing L4 aggregation (either SKB_GSO_UDP_L4 or SKB_GSO_FRAGLIST) at the outer UDP tunnel level for packets effectively carrying and UDP tunnel header.  That could cause inner protocol corruption. If e.g. the relevant packets carry a vxlan header, different vxlan ids will be ignored/ aggregated to the same GSO packet. Inner headers will be ignored, too, so that e.g. TCP over vxlan push packets will be held in the GRO engine till the next flush, etc.  Just skip the SKB_GSO_UDP_L4 and SKB_GSO_FRAGLIST code path if the current packet could land in a UDP tunnel, and let udp_gro_receive() do GRO via udp_sk(sk)-\u003egro_receive.  The check implemented in this patch is broader than what is strictly needed, as the existing UDP tunnel could be e.g. configured on top of a different device: we could end-up skipping GRO at-all for some packets.  Anyhow, that is a very thin corner case and covering it will add quite a bit of complexity.  v1 -\u003e v2:  - hopefully clarify the commit message",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-47036",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52616",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  crypto: lib/mpi - Fix unexpected pointer access in mpi_ec_init  When the mpi_ec_ctx structure is initialized, some fields are not cleared, causing a crash when referencing the field when the structure was released. Initially, this issue was ignored because memory for mpi_ec_ctx is allocated with the __GFP_ZERO flag. For example, this error will be triggered when calculating the Za value for SM2 separately.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52616",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2022-44034",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 6.0.6. drivers/char/pcmcia/scr24x_cs.c has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling open(), aka a race condition between scr24x_open() and scr24x_remove().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-44034",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2019-16232",
            "namespace": "debian:11",
            "description": "drivers/net/wireless/marvell/libertas/if_sdio.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2019-16232",
            "severity": "Negligible",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2022-48628",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  ceph: drop messages from MDS when unmounting  When unmounting all the dirty buffers will be flushed and after the last osd request is finished the last reference of the i_count will be released. Then it will flush the dirty cap/snap to MDSs, and the unmounting won't wait the possible acks, which will ihold the inodes when updating the metadata locally but makes no sense any more, of this. This will make the evict_inodes() to skip these inodes.  If encrypt is enabled the kernel generate a warning when removing the encrypt keys when the skipped inodes still hold the keyring:  WARNING: CPU: 4 PID: 168846 at fs/crypto/keyring.c:242 fscrypt_destroy_keyring+0x7e/0xd0 CPU: 4 PID: 168846 Comm: umount Tainted: G S  6.1.0-rc5-ceph-g72ead199864c #1 Hardware name: Supermicro SYS-5018R-WR/X10SRW-F, BIOS 2.0 12/17/2015 RIP: 0010:fscrypt_destroy_keyring+0x7e/0xd0 RSP: 0018:ffffc9000b277e28 EFLAGS: 00010202 RAX: 0000000000000002 RBX: ffff88810d52ac00 RCX: ffff88810b56aa00 RDX: 0000000080000000 RSI: ffffffff822f3a09 RDI: ffff888108f59000 RBP: ffff8881d394fb88 R08: 0000000000000028 R09: 0000000000000000 R10: 0000000000000001 R11: 11ff4fe6834fcd91 R12: ffff8881d394fc40 R13: ffff888108f59000 R14: ffff8881d394f800 R15: 0000000000000000 FS:  00007fd83f6f1080(0000) GS:ffff88885fd00000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f918d417000 CR3: 000000017f89a005 CR4: 00000000003706e0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: \u003cTASK\u003e generic_shutdown_super+0x47/0x120 kill_anon_super+0x14/0x30 ceph_kill_sb+0x36/0x90 [ceph] deactivate_locked_super+0x29/0x60 cleanup_mnt+0xb8/0x140 task_work_run+0x67/0xb0 exit_to_user_mode_prepare+0x23d/0x240 syscall_exit_to_user_mode+0x25/0x60 do_syscall_64+0x40/0x80 entry_SYSCALL_64_after_hwframe+0x63/0xcd RIP: 0033:0x7fd83dc39e9b  Later the kernel will crash when iput() the inodes and dereferencing the \"sb-\u003es_master_keys\", which has been released by the generic_shutdown_super().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-48628",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-23849",
            "namespace": "debian:11",
            "description": "In rds_recv_track_latency in net/rds/af_rds.c in the Linux kernel through 6.7.1, there is an off-by-one error for an RDS_MSG_RX_DGRAM_TRACE_MAX comparison, resulting in out-of-bounds access.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-23849",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52429",
            "namespace": "debian:11",
            "description": "dm_table_create in drivers/md/dm-table.c in the Linux kernel through 6.7.4 can attempt to (in alloc_targets) allocate more than INT_MAX bytes, and crash, because of a missing check for struct dm_ioctl.target_count.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52429",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52625",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Refactor DMCUB enter/exit idle interface  [Why] We can hang in place trying to send commands when the DMCUB isn't powered on.  [How] We need to exit out of the idle state prior to sending a command, but the process that performs the exit also invokes a command itself.  Fixing this issue involves the following:  1. Using a software state to track whether or not we need to start    the process to exit idle or notify idle.  It's possible for the hardware to have exited an idle state without driver knowledge, but entering one is always restricted to a driver allow - which makes the SW state vs HW state mismatch issue purely one of optimization, which should seldomly be hit, if at all.  2. Refactor any instances of exit/notify idle to use a single wrapper    that maintains this SW state.  This works simialr to dc_allow_idle_optimizations, but works at the DMCUB level and makes sure the state is marked prior to any notify/exit idle so we don't enter an infinite loop.  3. Make sure we exit out of idle prior to sending any commands or    waiting for DMCUB idle.  This patch takes care of 1/2. A future patch will take care of wrapping DMCUB command submission with calls to this new interface.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52625",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52458",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  block: add check that partition length needs to be aligned with block size  Before calling add partition or resize partition, there is no check on whether the length is aligned with the logical block size. If the logical block size of the disk is larger than 512 bytes, then the partition size maybe not the multiple of the logical block size, and when the last sector is read, bio_truncate() will adjust the bio size, resulting in an IO error if the size of the read command is smaller than the logical block size.If integrity data is supported, this will also result in a null pointer dereference when calling bio_integrity_free.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52458",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-47233",
            "namespace": "debian:11",
            "description": "The brcm80211 component in the Linux kernel through 6.5.10 has a brcmf_cfg80211_detach use-after-free in the device unplugging (disconnect the USB by hotplug) code. For physically proximate attackers with local access, this \"could be exploited in a real world scenario.\" This is related to brcmf_cfg80211_escan_timeout_worker in drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-47233",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-0340",
            "namespace": "debian:11",
            "description": "A vulnerability was found in vhost_new_msg in drivers/vhost/vhost.c in the Linux kernel, which does not properly initialize memory in messages passed between virtual guests and the host operating system in the vhost/vhost.c:vhost_new_msg() function. This issue can allow local privileged users to read some kernel memory contents when reading from the /dev/vhost-net device file.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-0340",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52604",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  FS:JFS:UBSAN:array-index-out-of-bounds in dbAdjTree  Syzkaller reported the following issue:  UBSAN: array-index-out-of-bounds in fs/jfs/jfs_dmap.c:2867:6 index 196694 is out of range for type 's8[1365]' (aka 'signed char[1365]') CPU: 1 PID: 109 Comm: jfsCommit Not tainted 6.6.0-rc3-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/04/2023 Call Trace:  \u003cTASK\u003e  __dump_stack lib/dump_stack.c:88 [inline]  dump_stack_lvl+0x1e7/0x2d0 lib/dump_stack.c:106  ubsan_epilogue lib/ubsan.c:217 [inline]  __ubsan_handle_out_of_bounds+0x11c/0x150 lib/ubsan.c:348  dbAdjTree+0x474/0x4f0 fs/jfs/jfs_dmap.c:2867  dbJoin+0x210/0x2d0 fs/jfs/jfs_dmap.c:2834  dbFreeBits+0x4eb/0xda0 fs/jfs/jfs_dmap.c:2331  dbFreeDmap fs/jfs/jfs_dmap.c:2080 [inline]  dbFree+0x343/0x650 fs/jfs/jfs_dmap.c:402  txFreeMap+0x798/0xd50 fs/jfs/jfs_txnmgr.c:2534  txUpdateMap+0x342/0x9e0  txLazyCommit fs/jfs/jfs_txnmgr.c:2664 [inline]  jfs_lazycommit+0x47a/0xb70 fs/jfs/jfs_txnmgr.c:2732  kthread+0x2d3/0x370 kernel/kthread.c:388  ret_from_fork+0x48/0x80 arch/x86/kernel/process.c:147  ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:304  \u003c/TASK\u003e ================================================================================ Kernel panic - not syncing: UBSAN: panic_on_warn set ... CPU: 1 PID: 109 Comm: jfsCommit Not tainted 6.6.0-rc3-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/04/2023 Call Trace:  \u003cTASK\u003e  __dump_stack lib/dump_stack.c:88 [inline]  dump_stack_lvl+0x1e7/0x2d0 lib/dump_stack.c:106  panic+0x30f/0x770 kernel/panic.c:340  check_panic_on_warn+0x82/0xa0 kernel/panic.c:236  ubsan_epilogue lib/ubsan.c:223 [inline]  __ubsan_handle_out_of_bounds+0x13c/0x150 lib/ubsan.c:348  dbAdjTree+0x474/0x4f0 fs/jfs/jfs_dmap.c:2867  dbJoin+0x210/0x2d0 fs/jfs/jfs_dmap.c:2834  dbFreeBits+0x4eb/0xda0 fs/jfs/jfs_dmap.c:2331  dbFreeDmap fs/jfs/jfs_dmap.c:2080 [inline]  dbFree+0x343/0x650 fs/jfs/jfs_dmap.c:402  txFreeMap+0x798/0xd50 fs/jfs/jfs_txnmgr.c:2534  txUpdateMap+0x342/0x9e0  txLazyCommit fs/jfs/jfs_txnmgr.c:2664 [inline]  jfs_lazycommit+0x47a/0xb70 fs/jfs/jfs_txnmgr.c:2732  kthread+0x2d3/0x370 kernel/kthread.c:388  ret_from_fork+0x48/0x80 arch/x86/kernel/process.c:147  ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:304  \u003c/TASK\u003e Kernel Offset: disabled Rebooting in 86400 seconds..  The issue is caused when the value of lp becomes greater than CTLTREESIZE which is the max size of stree. Adding a simple check solves this issue.  Dave: As the function returns a void, good error handling would require a more intrusive code reorganization, so I modified Osama's patch at use WARN_ON_ONCE for lack of a cleaner option.  The patch is tested via syzbot.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52604",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52593",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: wfx: fix possible NULL pointer dereference in wfx_set_mfp_ap()  Since 'ieee80211_beacon_get()' can return NULL, 'wfx_set_mfp_ap()' should check the return value before examining skb data. So convert the latter to return an appropriate error code and propagate it to return from 'wfx_start_ap()' as well. Compile tested only.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52593",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52508",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  nvme-fc: Prevent null pointer dereference in nvme_fc_io_getuuid()  The nvme_fc_fcp_op structure describing an AEN operation is initialized with a null request structure pointer. An FC LLDD may make a call to nvme_fc_io_getuuid passing a pointer to an nvmefc_fcp_req for an AEN operation.  Add validation of the request structure pointer before dereference.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52508",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-1151",
            "namespace": "debian:11",
            "description": "A vulnerability was reported in the Open vSwitch sub-component in the Linux Kernel. The flaw occurs when a recursive operation of code push recursively calls into the code block. The OVS module does not validate the stack depth, pushing too many frames and causing a stack overflow. As a result, this can lead to a crash or other related issues.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-1151",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2021-3864",
            "namespace": "debian:11",
            "description": "A flaw was found in the way the dumpable flag setting was handled when certain SUID binaries executed its descendants. The prerequisite is a SUID binary that sets real UID equal to effective UID, and real GID equal to effective GID. The descendant will then have a dumpable value set to 1. As a result, if the descendant process crashes and core_pattern is set to a relative value, its core dump is stored in the current directory with uid:gid permissions. An unprivileged local user with eligible root SUID binary could use this flaw to place core dumps into root-owned directories, potentially resulting in escalation of privileges.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-3864",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52598",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  s390/ptrace: handle setting of fpc register correctly  If the content of the floating point control (fpc) register of a traced process is modified with the ptrace interface the new value is tested for validity by temporarily loading it into the fpc register.  This may lead to corruption of the fpc register of the tracing process: if an interrupt happens while the value is temporarily loaded into the fpc register, and within interrupt context floating point or vector registers are used, the current fp/vx registers are saved with save_fpu_regs() assuming they belong to user space and will be loaded into fp/vx registers when returning to user space.  test_fp_ctl() restores the original user space fpc register value, however it will be discarded, when returning to user space.  In result the tracer will incorrectly continue to run with the value that was supposed to be used for the traced process.  Fix this by saving fpu register contents with save_fpu_regs() before using test_fp_ctl().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52598",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52618",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  block/rnbd-srv: Check for unlikely string overflow  Since \"dev_search_path\" can technically be as large as PATH_MAX, there was a risk of truncation when copying it and a second string into \"full_path\" since it was also PATH_MAX sized. The W=1 builds were reporting this warning:  drivers/block/rnbd/rnbd-srv.c: In function 'process_msg_open.isra': drivers/block/rnbd/rnbd-srv.c:616:51: warning: '%s' directive output may be truncated writing up to 254 bytes into a region of size between 0 and 4095 [-Wformat-truncation=]   616 |                 snprintf(full_path, PATH_MAX, \"%s/%s\",       |                                                   ^~ In function 'rnbd_srv_get_full_path',     inlined from 'process_msg_open.isra' at drivers/block/rnbd/rnbd-srv.c:721:14: drivers/block/rnbd/rnbd-srv.c:616:17: note: 'snprintf' output between 2 and 4351 bytes into a destination of size 4096   616 |                 snprintf(full_path, PATH_MAX, \"%s/%s\",       |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   617 |                          dev_search_path, dev_name);       |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~  To fix this, unconditionally check for truncation (as was already done for the case where \"%SESSNAME%\" was present).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52618",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26606",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  binder: signal epoll threads of self-work  In (e)poll mode, threads often depend on I/O events to determine when data is ready for consumption. Within binder, a thread may initiate a command via BINDER_WRITE_READ without a read buffer and then make use of epoll_wait() or similar to consume any responses afterwards.  It is then crucial that epoll threads are signaled via wakeup when they queue their own work. Otherwise, they risk waiting indefinitely for an event leaving their work unhandled. What is worse, subsequent commands won't trigger a wakeup either as the thread has pending work.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26606",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52481",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  arm64: errata: Add Cortex-A520 speculative unprivileged load workaround  Implement the workaround for ARM Cortex-A520 erratum 2966298. On an affected Cortex-A520 core, a speculatively executed unprivileged load might leak data from a privileged load via a cache side channel. The issue only exists for loads within a translation regime with the same translation (e.g. same ASID and VMID). Therefore, the issue only affects the return to EL0.  The workaround is to execute a TLBI before returning to EL0 after all loads of privileged data. A non-shareable TLBI to any address is sufficient.  The workaround isn't necessary if page table isolation (KPTI) is enabled, but for simplicity it will be. Page table isolation should normally be disabled for Cortex-A520 as it supports the CSV3 feature and the E0PD feature (used when KASLR is enabled).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52481",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-23307",
            "namespace": "debian:11",
            "description": "Integer Overflow or Wraparound vulnerability in Linux Linux kernel kernel on Linux, x86, ARM (md, raid, raid5 modules) allows Forced Integer Overflow.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-23307",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52485",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Wake DMCUB before sending a command  [Why] We can hang in place trying to send commands when the DMCUB isn't powered on.  [How] For functions that execute within a DC context or DC lock we can wrap the direct calls to dm_execute_dmub_cmd/list with code that exits idle power optimizations and reallows once we're done with the command submission on success.  For DM direct submissions the DM will need to manage the enter/exit sequencing manually.  We cannot invoke a DMCUB command directly within the DM execution helper or we can deadlock.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52485",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2022-4543",
            "namespace": "debian:11",
            "description": "A flaw named \"EntryBleed\" was found in the Linux Kernel Page Table Isolation (KPTI). This issue could allow a local attacker to leak KASLR base via prefetch side-channels based on TLB timing for Intel systems.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-4543",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52584",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  spmi: mediatek: Fix UAF on device remove  The pmif driver data that contains the clocks is allocated along with spmi_controller. On device remove, spmi_controller will be freed first, and then devres , including the clocks, will be cleanup. This leads to UAF because putting the clocks will access the clocks in the pmif driver data, which is already freed along with spmi_controller.  This can be reproduced by enabling DEBUG_TEST_DRIVER_REMOVE and building the kernel with KASAN.  Fix the UAF issue by using unmanaged clk_bulk_get() and putting the clocks before freeing spmi_controller.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52584",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-0160",
            "namespace": "debian:11",
            "description": "A deadlock flaw was found in the Linux kernel’s BPF subsystem. This flaw allows a local user to potentially crash the system.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-0160",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2021-47076",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  RDMA/rxe: Return CQE error if invalid lkey was supplied  RXE is missing update of WQE status in LOCAL_WRITE failures.  This caused the following kernel panic if someone sent an atomic operation with an explicitly wrong lkey.  [leonro@vm ~]$ mkt test test_atomic_invalid_lkey (tests.test_atomic.AtomicTest) ...  WARNING: CPU: 5 PID: 263 at drivers/infiniband/sw/rxe/rxe_comp.c:740 rxe_completer+0x1a6d/0x2e30 [rdma_rxe]  Modules linked in: crc32_generic rdma_rxe ip6_udp_tunnel udp_tunnel rdma_ucm rdma_cm ib_umad ib_ipoib iw_cm ib_cm mlx5_ib ib_uverbs ib_core mlx5_core ptp pps_core  CPU: 5 PID: 263 Comm: python3 Not tainted 5.13.0-rc1+ #2936  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014  RIP: 0010:rxe_completer+0x1a6d/0x2e30 [rdma_rxe]  Code: 03 0f 8e 65 0e 00 00 3b 93 10 06 00 00 0f 84 82 0a 00 00 4c 89 ff 4c 89 44 24 38 e8 2d 74 a9 e1 4c 8b 44 24 38 e9 1c f5 ff ff \u003c0f\u003e 0b e9 0c e8 ff ff b8 05 00 00 00 41 bf 05 00 00 00 e9 ab e7 ff  RSP: 0018:ffff8880158af090 EFLAGS: 00010246  RAX: 0000000000000000 RBX: ffff888016a78000 RCX: ffffffffa0cf1652  RDX: 1ffff9200004b442 RSI: 0000000000000004 RDI: ffffc9000025a210  RBP: dffffc0000000000 R08: 00000000ffffffea R09: ffff88801617740b  R10: ffffed1002c2ee81 R11: 0000000000000007 R12: ffff88800f3b63e8  R13: ffff888016a78008 R14: ffffc9000025a180 R15: 000000000000000c  FS:  00007f88b622a740(0000) GS:ffff88806d540000(0000) knlGS:0000000000000000  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033  CR2: 00007f88b5a1fa10 CR3: 000000000d848004 CR4: 0000000000370ea0  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400  Call Trace:   rxe_do_task+0x130/0x230 [rdma_rxe]   rxe_rcv+0xb11/0x1df0 [rdma_rxe]   rxe_loopback+0x157/0x1e0 [rdma_rxe]   rxe_responder+0x5532/0x7620 [rdma_rxe]   rxe_do_task+0x130/0x230 [rdma_rxe]   rxe_rcv+0x9c8/0x1df0 [rdma_rxe]   rxe_loopback+0x157/0x1e0 [rdma_rxe]   rxe_requester+0x1efd/0x58c0 [rdma_rxe]   rxe_do_task+0x130/0x230 [rdma_rxe]   rxe_post_send+0x998/0x1860 [rdma_rxe]   ib_uverbs_post_send+0xd5f/0x1220 [ib_uverbs]   ib_uverbs_write+0x847/0xc80 [ib_uverbs]   vfs_write+0x1c5/0x840   ksys_write+0x176/0x1d0   do_syscall_64+0x3f/0x80   entry_SYSCALL_64_after_hwframe+0x44/0xae",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-47076",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52480",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix race condition between session lookup and expire   Thread A                        +  Thread B  ksmbd_session_lookup            |  smb2_sess_setup    sess = xa_load                |                                  |                                  |    xa_erase(\u0026conn-\u003esessions, sess-\u003eid);                                  |                                  |    ksmbd_session_destroy(sess) --\u003e kfree(sess)                                  |    // UAF!                       |    sess-\u003elast_active = jiffies   |                                  +  This patch add rwsem to fix race condition between ksmbd_session_lookup and ksmbd_expire_session.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52480",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-31082",
            "namespace": "debian:11",
            "description": "An issue was discovered in drivers/tty/n_gsm.c in the Linux kernel 6.2. There is a sleeping function called from an invalid context in gsmld_write, which will block the kernel.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-31082",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-4569",
            "namespace": "debian:11",
            "description": "A memory leak flaw was found in nft_set_catchall_flush in net/netfilter/nf_tables_api.c in the Linux Kernel. This issue may allow a local attacker to cause double-deactivations of catchall elements, which can result in a memory leak.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4569",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2022-48626",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  moxart: fix potential use-after-free on remove path  It was reported that the mmc host structure could be accessed after it was freed in moxart_remove(), so fix this by saving the base register of the device and using it instead of the pointer dereference.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-48626",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52615",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  hwrng: core - Fix page fault dead lock on mmap-ed hwrng  There is a dead-lock in the hwrng device read path.  This triggers when the user reads from /dev/hwrng into memory also mmap-ed from /dev/hwrng.  The resulting page fault triggers a recursive read which then dead-locks.  Fix this by using a stack buffer when calling copy_to_user.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52615",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52596",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  sysctl: Fix out of bounds access for empty sysctl registers  When registering tables to the sysctl subsystem there is a check to see if header is a permanently empty directory (used for mounts). This check evaluates the first element of the ctl_table. This results in an out of bounds evaluation when registering empty directories.  The function register_sysctl_mount_point now passes a ctl_table of size 1 instead of size 0. It now relies solely on the type to identify a permanently empty register.  Make sure that the ctl_table has at least one element before testing for permanent emptiness.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52596",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52607",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  powerpc/mm: Fix null-pointer dereference in pgtable_cache_add  kasprintf() returns a pointer to dynamically allocated memory which can be NULL upon failure. Ensure the allocation was successful by checking the pointer validity.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52607",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52620",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  netfilter: nf_tables: disallow timeout for anonymous sets  Never used from userspace, disallow these parameters.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52620",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-25739",
            "namespace": "debian:11",
            "description": "create_empty_lvol in drivers/mtd/ubi/vtbl.c in the Linux kernel through 6.7.4 can attempt to allocate zero bytes, and crash, because of a missing check for ubi-\u003eleb_size.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-25739",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52586",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/msm/dpu: Add mutex lock in control vblank irq  Add a mutex lock to control vblank irq to synchronize vblank enable/disable operations happening from different threads to prevent race conditions while registering/unregistering the vblank irq callback.  v4: -Removed vblank_ctl_lock from dpu_encoder_virt, so it is only a     parameter of dpu_encoder_phys.     -Switch from atomic refcnt to a simple int counter as mutex has     now been added v3: Mistakenly did not change wording in last version. It is done now. v2: Slightly changed wording of commit message  Patchwork: https://patchwork.freedesktop.org/patch/571854/",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52586",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-24859",
            "namespace": "debian:11",
            "description": "A race condition was found in the Linux kernel's net/bluetooth in sniff_{min,max}_interval_set() function. This can result in a bluetooth sniffing exception issue, possibly leading denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-24859",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-24864",
            "namespace": "debian:11",
            "description": "A race condition was found in the Linux kernel's media/dvb-core in dvbdmx_write() function. This can result in a null pointer dereference issue, possibly leading to a kernel panic or denial of service issue.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-24864",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "gcc-10",
            "featureversion": "10.2.1-6",
            "vulnerability": "CVE-2023-4039",
            "namespace": "debian:11",
            "description": "**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains  that target AArch64 allows an attacker to exploit an existing buffer  overflow in dynamically-sized local variables in your application  without this being detected. This stack-protector failure only applies  to C99-style dynamically-sized local variables or those created using  alloca(). The stack-protector operates as intended for statically-sized  local variables.  The default behavior when the stack-protector  detects an overflow is to terminate your application, resulting in  controlled loss of availability. An attacker who can exploit a buffer  overflow without triggering the stack-protector might be able to change  program flow control to cause an uncontrolled loss of availability or to  go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4039",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26625",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  llc: call sock_orphan() at release time  syzbot reported an interesting trace [1] caused by a stale sk-\u003esk_wq pointer in a closed llc socket.  In commit ff7b11aa481f (\"net: socket: set sock-\u003esk to NULL after calling proto_ops::release()\") Eric Biggers hinted that some protocols are missing a sock_orphan(), we need to perform a full audit.  In net-next, I plan to clear sock-\u003esk from sock_orphan() and amend Eric patch to add a warning.  [1]  BUG: KASAN: slab-use-after-free in list_empty include/linux/list.h:373 [inline]  BUG: KASAN: slab-use-after-free in waitqueue_active include/linux/wait.h:127 [inline]  BUG: KASAN: slab-use-after-free in sock_def_write_space_wfree net/core/sock.c:3384 [inline]  BUG: KASAN: slab-use-after-free in sock_wfree+0x9a8/0x9d0 net/core/sock.c:2468 Read of size 8 at addr ffff88802f4fc880 by task ksoftirqd/1/27  CPU: 1 PID: 27 Comm: ksoftirqd/1 Not tainted 6.8.0-rc1-syzkaller-00049-g6098d87eaf31 #0 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.2-debian-1.16.2-1 04/01/2014 Call Trace:  \u003cTASK\u003e   __dump_stack lib/dump_stack.c:88 [inline]   dump_stack_lvl+0xd9/0x1b0 lib/dump_stack.c:106   print_address_description mm/kasan/report.c:377 [inline]   print_report+0xc4/0x620 mm/kasan/report.c:488   kasan_report+0xda/0x110 mm/kasan/report.c:601   list_empty include/linux/list.h:373 [inline]   waitqueue_active include/linux/wait.h:127 [inline]   sock_def_write_space_wfree net/core/sock.c:3384 [inline]   sock_wfree+0x9a8/0x9d0 net/core/sock.c:2468   skb_release_head_state+0xa3/0x2b0 net/core/skbuff.c:1080   skb_release_all net/core/skbuff.c:1092 [inline]   napi_consume_skb+0x119/0x2b0 net/core/skbuff.c:1404   e1000_unmap_and_free_tx_resource+0x144/0x200 drivers/net/ethernet/intel/e1000/e1000_main.c:1970   e1000_clean_tx_irq drivers/net/ethernet/intel/e1000/e1000_main.c:3860 [inline]   e1000_clean+0x4a1/0x26e0 drivers/net/ethernet/intel/e1000/e1000_main.c:3801   __napi_poll.constprop.0+0xb4/0x540 net/core/dev.c:6576   napi_poll net/core/dev.c:6645 [inline]   net_rx_action+0x956/0xe90 net/core/dev.c:6778   __do_softirq+0x21a/0x8de kernel/softirq.c:553   run_ksoftirqd kernel/softirq.c:921 [inline]   run_ksoftirqd+0x31/0x60 kernel/softirq.c:913   smpboot_thread_fn+0x660/0xa10 kernel/smpboot.c:164   kthread+0x2c6/0x3a0 kernel/kthread.c:388   ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:147   ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:242  \u003c/TASK\u003e  Allocated by task 5167:   kasan_save_stack+0x33/0x50 mm/kasan/common.c:47   kasan_save_track+0x14/0x30 mm/kasan/common.c:68   unpoison_slab_object mm/kasan/common.c:314 [inline]   __kasan_slab_alloc+0x81/0x90 mm/kasan/common.c:340   kasan_slab_alloc include/linux/kasan.h:201 [inline]   slab_post_alloc_hook mm/slub.c:3813 [inline]   slab_alloc_node mm/slub.c:3860 [inline]   kmem_cache_alloc_lru+0x142/0x6f0 mm/slub.c:3879   alloc_inode_sb include/linux/fs.h:3019 [inline]   sock_alloc_inode+0x25/0x1c0 net/socket.c:308   alloc_inode+0x5d/0x220 fs/inode.c:260   new_inode_pseudo+0x16/0x80 fs/inode.c:1005   sock_alloc+0x40/0x270 net/socket.c:634   __sock_create+0xbc/0x800 net/socket.c:1535   sock_create net/socket.c:1622 [inline]   __sys_socket_create net/socket.c:1659 [inline]   __sys_socket+0x14c/0x260 net/socket.c:1706   __do_sys_socket net/socket.c:1720 [inline]   __se_sys_socket net/socket.c:1718 [inline]   __x64_sys_socket+0x72/0xb0 net/socket.c:1718   do_syscall_x64 arch/x86/entry/common.c:52 [inline]   do_syscall_64+0xd3/0x250 arch/x86/entry/common.c:83  entry_SYSCALL_64_after_hwframe+0x63/0x6b  Freed by task 0:   kasan_save_stack+0x33/0x50 mm/kasan/common.c:47   kasan_save_track+0x14/0x30 mm/kasan/common.c:68   kasan_save_free_info+0x3f/0x60 mm/kasan/generic.c:640   poison_slab_object mm/kasan/common.c:241 [inline]   __kasan_slab_free+0x121/0x1b0 mm/kasan/common.c:257   kasan_slab_free include/linux/kasan.h:184 [inline]   slab_free_hook mm/slub.c:2121 [inlin ---truncated---",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26625",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52583",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  ceph: fix deadlock or deadcode of misusing dget()  The lock order is incorrect between denty and its parent, we should always make sure that the parent get the lock first.  But since this deadcode is never used and the parent dir will always be set from the callers, let's just remove it.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52583",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52435",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  net: prevent mss overflow in skb_segment()  Once again syzbot is able to crash the kernel in skb_segment() [1]  GSO_BY_FRAGS is a forbidden value, but unfortunately the following computation in skb_segment() can reach it quite easily :  \tmss = mss * partial_segs;  65535 = 3 * 5 * 17 * 257, so many initial values of mss can lead to a bad final result.  Make sure to limit segmentation so that the new mss value is smaller than GSO_BY_FRAGS.  [1]  general protection fault, probably for non-canonical address 0xdffffc000000000e: 0000 [#1] PREEMPT SMP KASAN KASAN: null-ptr-deref in range [0x0000000000000070-0x0000000000000077] CPU: 1 PID: 5079 Comm: syz-executor993 Not tainted 6.7.0-rc4-syzkaller-00141-g1ae4cd3cbdd0 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 11/10/2023 RIP: 0010:skb_segment+0x181d/0x3f30 net/core/skbuff.c:4551 Code: 83 e3 02 e9 fb ed ff ff e8 90 68 1c f9 48 8b 84 24 f8 00 00 00 48 8d 78 70 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03 \u003c0f\u003e b6 04 02 84 c0 74 08 3c 03 0f 8e 8a 21 00 00 48 8b 84 24 f8 00 RSP: 0018:ffffc900043473d0 EFLAGS: 00010202 RAX: dffffc0000000000 RBX: 0000000000010046 RCX: ffffffff886b1597 RDX: 000000000000000e RSI: ffffffff886b2520 RDI: 0000000000000070 RBP: ffffc90004347578 R08: 0000000000000005 R09: 000000000000ffff R10: 000000000000ffff R11: 0000000000000002 R12: ffff888063202ac0 R13: 0000000000010000 R14: 000000000000ffff R15: 0000000000000046 FS: 0000555556e7e380(0000) GS:ffff8880b9900000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000020010000 CR3: 0000000027ee2000 CR4: 00000000003506f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: \u003cTASK\u003e udp6_ufo_fragment+0xa0e/0xd00 net/ipv6/udp_offload.c:109 ipv6_gso_segment+0x534/0x17e0 net/ipv6/ip6_offload.c:120 skb_mac_gso_segment+0x290/0x610 net/core/gso.c:53 __skb_gso_segment+0x339/0x710 net/core/gso.c:124 skb_gso_segment include/net/gso.h:83 [inline] validate_xmit_skb+0x36c/0xeb0 net/core/dev.c:3626 __dev_queue_xmit+0x6f3/0x3d60 net/core/dev.c:4338 dev_queue_xmit include/linux/netdevice.h:3134 [inline] packet_xmit+0x257/0x380 net/packet/af_packet.c:276 packet_snd net/packet/af_packet.c:3087 [inline] packet_sendmsg+0x24c6/0x5220 net/packet/af_packet.c:3119 sock_sendmsg_nosec net/socket.c:730 [inline] __sock_sendmsg+0xd5/0x180 net/socket.c:745 __sys_sendto+0x255/0x340 net/socket.c:2190 __do_sys_sendto net/socket.c:2202 [inline] __se_sys_sendto net/socket.c:2198 [inline] __x64_sys_sendto+0xe0/0x1b0 net/socket.c:2198 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0x40/0x110 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x63/0x6b RIP: 0033:0x7f8692032aa9 Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 d1 19 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 \u003c48\u003e 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007fff8d685418 EFLAGS: 00000246 ORIG_RAX: 000000000000002c RAX: ffffffffffffffda RBX: 0000000000000003 RCX: 00007f8692032aa9 RDX: 0000000000010048 RSI: 00000000200000c0 RDI: 0000000000000003 RBP: 00000000000f4240 R08: 0000000020000540 R09: 0000000000000014 R10: 0000000000000000 R11: 0000000000000246 R12: 00007fff8d685480 R13: 0000000000000001 R14: 00007fff8d685480 R15: 0000000000000003 \u003c/TASK\u003e Modules linked in: ---[ end trace 0000000000000000 ]--- RIP: 0010:skb_segment+0x181d/0x3f30 net/core/skbuff.c:4551 Code: 83 e3 02 e9 fb ed ff ff e8 90 68 1c f9 48 8b 84 24 f8 00 00 00 48 8d 78 70 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03 \u003c0f\u003e b6 04 02 84 c0 74 08 3c 03 0f 8e 8a 21 00 00 48 8b 84 24 f8 00 RSP: 0018:ffffc900043473d0 EFLAGS: 00010202 RAX: dffffc0000000000 RBX: 0000000000010046 RCX: ffffffff886b1597 RDX: 000000000000000e RSI: ffffffff886b2520 RDI: 0000000000000070 RBP: ffffc90004347578 R0 ---truncated---",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52435",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52486",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  drm: Don't unref the same fb many times by mistake due to deadlock handling  If we get a deadlock after the fb lookup in drm_mode_page_flip_ioctl() we proceed to unref the fb and then retry the whole thing from the top. But we forget to reset the fb pointer back to NULL, and so if we then get another error during the retry, before the fb lookup, we proceed the unref the same fb again without having gotten another reference. The end result is that the fb will (eventually) end up being freed while it's still in use.  Reset fb to NULL once we've unreffed it to avoid doing it again until we've done another fb lookup.  This turned out to be pretty easy to hit on a DG2 when doing async flips (and CONFIG_DEBUG_WW_MUTEX_SLOWPATH=y). The first symptom I saw that drm_closefb() simply got stuck in a busy loop while walking the framebuffer list. Fortunately I was able to convince it to oops instead, and from there it was easier to track down the culprit.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52486",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52599",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  jfs: fix array-index-out-of-bounds in diNewExt  [Syz report] UBSAN: array-index-out-of-bounds in fs/jfs/jfs_imap.c:2360:2 index -878706688 is out of range for type 'struct iagctl[128]' CPU: 1 PID: 5065 Comm: syz-executor282 Not tainted 6.7.0-rc4-syzkaller-00009-gbee0e7762ad2 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 11/10/2023 Call Trace:  \u003cTASK\u003e  __dump_stack lib/dump_stack.c:88 [inline]  dump_stack_lvl+0x1e7/0x2d0 lib/dump_stack.c:106  ubsan_epilogue lib/ubsan.c:217 [inline]  __ubsan_handle_out_of_bounds+0x11c/0x150 lib/ubsan.c:348  diNewExt+0x3cf3/0x4000 fs/jfs/jfs_imap.c:2360  diAllocExt fs/jfs/jfs_imap.c:1949 [inline]  diAllocAG+0xbe8/0x1e50 fs/jfs/jfs_imap.c:1666  diAlloc+0x1d3/0x1760 fs/jfs/jfs_imap.c:1587  ialloc+0x8f/0x900 fs/jfs/jfs_inode.c:56  jfs_mkdir+0x1c5/0xb90 fs/jfs/namei.c:225  vfs_mkdir+0x2f1/0x4b0 fs/namei.c:4106  do_mkdirat+0x264/0x3a0 fs/namei.c:4129  __do_sys_mkdir fs/namei.c:4149 [inline]  __se_sys_mkdir fs/namei.c:4147 [inline]  __x64_sys_mkdir+0x6e/0x80 fs/namei.c:4147  do_syscall_x64 arch/x86/entry/common.c:51 [inline]  do_syscall_64+0x45/0x110 arch/x86/entry/common.c:82  entry_SYSCALL_64_after_hwframe+0x63/0x6b RIP: 0033:0x7fcb7e6a0b57 Code: ff ff 77 07 31 c0 c3 0f 1f 40 00 48 c7 c2 b8 ff ff ff f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 b8 53 00 00 00 0f 05 \u003c48\u003e 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007ffd83023038 EFLAGS: 00000286 ORIG_RAX: 0000000000000053 RAX: ffffffffffffffda RBX: 00000000ffffffff RCX: 00007fcb7e6a0b57 RDX: 00000000000a1020 RSI: 00000000000001ff RDI: 0000000020000140 RBP: 0000000020000140 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000286 R12: 00007ffd830230d0 R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000  [Analysis] When the agstart is too large, it can cause agno overflow.  [Fix] After obtaining agno, if the value is invalid, exit the subsequent process.   Modified the test from agno \u003e MAXAG to agno \u003e= MAXAG based on linux-next report by kernel test robot (Dan Carpenter).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52599",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52602",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  jfs: fix slab-out-of-bounds Read in dtSearch  Currently while searching for current page in the sorted entry table of the page there is a out of bound access. Added a bound check to fix the error.  Dave: Set return code to -EIO",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52602",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52511",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  spi: sun6i: reduce DMA RX transfer width to single byte  Through empirical testing it has been determined that sometimes RX SPI transfers with DMA enabled return corrupted data. This is down to single or even multiple bytes lost during DMA transfer from SPI peripheral to memory. It seems the RX FIFO within the SPI peripheral can become confused when performing bus read accesses wider than a single byte to it during an active SPI transfer.  This patch reduces the width of individual DMA read accesses to the RX FIFO to a single byte to mitigate that issue.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52511",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52601",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  jfs: fix array-index-out-of-bounds in dbAdjTree  Currently there is a bound check missing in the dbAdjTree while accessing the dmt_stree. To add the required check added the bool is_ctl which is required to determine the size as suggest in the following commit. https://lore.kernel.org/linux-kernel-mentees/f9475918-2186-49b8-b801-6f0f9e75f4fa@oracle.com/",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52601",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26642",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  netfilter: nf_tables: disallow anonymous set with timeout flag  Anonymous sets are never used with timeout from userspace, reject this. Exception to this rule is NFT_SET_EVAL to ensure legacy meters still work.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26642",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2022-0480",
            "namespace": "debian:11",
            "description": "A flaw was found in the filelock_init in fs/locks.c function in the Linux kernel. This issue can lead to host memory exhaustion due to memcg not limiting the number of Portable Operating System Interface (POSIX) file locks.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-0480",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2021-46926",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  ALSA: hda: intel-sdw-acpi: harden detection of controller  The existing code currently sets a pointer to an ACPI handle before checking that it's actually a SoundWire controller. This can lead to issues where the graph walk continues and eventually fails, but the pointer was set already.  This patch changes the logic so that the information provided to the caller is set when a controller is found.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-46926",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52530",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: mac80211: fix potential key use-after-free  When ieee80211_key_link() is called by ieee80211_gtk_rekey_add() but returns 0 due to KRACK protection (identical key reinstall), ieee80211_gtk_rekey_add() will still return a pointer into the key, in a potential use-after-free. This normally doesn't happen since it's only called by iwlwifi in case of WoWLAN rekey offload which has its own KRACK protection, but still better to fix, do that by returning an error code and converting that to success on the cfg80211 boundary only, leaving the error for bad callers of ieee80211_gtk_rekey_add().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52530",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26624",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  af_unix: fix lockdep positive in sk_diag_dump_icons()  syzbot reported a lockdep splat [1].  Blamed commit hinted about the possible lockdep violation, and code used unix_state_lock_nested() in an attempt to silence lockdep.  It is not sufficient, because unix_state_lock_nested() is already used from unix_state_double_lock().  We need to use a separate subclass.  This patch adds a distinct enumeration to make things more explicit.  Also use swap() in unix_state_double_lock() as a clean up.  v2: add a missing inline keyword to unix_state_lock_nested()  [1] WARNING: possible circular locking dependency detected 6.8.0-rc1-syzkaller-00356-g8a696a29c690 #0 Not tainted  syz-executor.1/2542 is trying to acquire lock:  ffff88808b5df9e8 (rlock-AF_UNIX){+.+.}-{2:2}, at: skb_queue_tail+0x36/0x120 net/core/skbuff.c:3863  but task is already holding lock:  ffff88808b5dfe70 (\u0026u-\u003elock/1){+.+.}-{2:2}, at: unix_dgram_sendmsg+0xfc7/0x2200 net/unix/af_unix.c:2089  which lock already depends on the new lock.  the existing dependency chain (in reverse order) is:  -\u003e #1 (\u0026u-\u003elock/1){+.+.}-{2:2}:         lock_acquire+0x1e3/0x530 kernel/locking/lockdep.c:5754         _raw_spin_lock_nested+0x31/0x40 kernel/locking/spinlock.c:378         sk_diag_dump_icons net/unix/diag.c:87 [inline]         sk_diag_fill+0x6ea/0xfe0 net/unix/diag.c:157         sk_diag_dump net/unix/diag.c:196 [inline]         unix_diag_dump+0x3e9/0x630 net/unix/diag.c:220         netlink_dump+0x5c1/0xcd0 net/netlink/af_netlink.c:2264         __netlink_dump_start+0x5d7/0x780 net/netlink/af_netlink.c:2370         netlink_dump_start include/linux/netlink.h:338 [inline]         unix_diag_handler_dump+0x1c3/0x8f0 net/unix/diag.c:319        sock_diag_rcv_msg+0xe3/0x400         netlink_rcv_skb+0x1df/0x430 net/netlink/af_netlink.c:2543         sock_diag_rcv+0x2a/0x40 net/core/sock_diag.c:280         netlink_unicast_kernel net/netlink/af_netlink.c:1341 [inline]         netlink_unicast+0x7e6/0x980 net/netlink/af_netlink.c:1367         netlink_sendmsg+0xa37/0xd70 net/netlink/af_netlink.c:1908         sock_sendmsg_nosec net/socket.c:730 [inline]         __sock_sendmsg net/socket.c:745 [inline]         sock_write_iter+0x39a/0x520 net/socket.c:1160         call_write_iter include/linux/fs.h:2085 [inline]         new_sync_write fs/read_write.c:497 [inline]         vfs_write+0xa74/0xca0 fs/read_write.c:590         ksys_write+0x1a0/0x2c0 fs/read_write.c:643         do_syscall_x64 arch/x86/entry/common.c:52 [inline]         do_syscall_64+0xf5/0x230 arch/x86/entry/common.c:83        entry_SYSCALL_64_after_hwframe+0x63/0x6b  -\u003e #0 (rlock-AF_UNIX){+.+.}-{2:2}:         check_prev_add kernel/locking/lockdep.c:3134 [inline]         check_prevs_add kernel/locking/lockdep.c:3253 [inline]         validate_chain+0x1909/0x5ab0 kernel/locking/lockdep.c:3869         __lock_acquire+0x1345/0x1fd0 kernel/locking/lockdep.c:5137         lock_acquire+0x1e3/0x530 kernel/locking/lockdep.c:5754         __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:110 [inline]         _raw_spin_lock_irqsave+0xd5/0x120 kernel/locking/spinlock.c:162         skb_queue_tail+0x36/0x120 net/core/skbuff.c:3863         unix_dgram_sendmsg+0x15d9/0x2200 net/unix/af_unix.c:2112         sock_sendmsg_nosec net/socket.c:730 [inline]         __sock_sendmsg net/socket.c:745 [inline]         ____sys_sendmsg+0x592/0x890 net/socket.c:2584         ___sys_sendmsg net/socket.c:2638 [inline]         __sys_sendmmsg+0x3b2/0x730 net/socket.c:2724         __do_sys_sendmmsg net/socket.c:2753 [inline]         __se_sys_sendmmsg net/socket.c:2750 [inline]         __x64_sys_sendmmsg+0xa0/0xb0 net/socket.c:2750         do_syscall_x64 arch/x86/entry/common.c:52 [inline]         do_syscall_64+0xf5/0x230 arch/x86/entry/common.c:83        entry_SYSCALL_64_after_hwframe+0x63/0x6b  other info that might help us debug this:   Possible unsafe locking scenario:         CPU0              ---truncated---",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26624",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52603",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  UBSAN: array-index-out-of-bounds in dtSplitRoot  Syzkaller reported the following issue:  oop0: detected capacity change from 0 to 32768  UBSAN: array-index-out-of-bounds in fs/jfs/jfs_dtree.c:1971:9 index -2 is out of range for type 'struct dtslot [128]' CPU: 0 PID: 3613 Comm: syz-executor270 Not tainted 6.0.0-syzkaller-09423-g493ffd6605b2 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/22/2022 Call Trace:  \u003cTASK\u003e  __dump_stack lib/dump_stack.c:88 [inline]  dump_stack_lvl+0x1b1/0x28e lib/dump_stack.c:106  ubsan_epilogue lib/ubsan.c:151 [inline]  __ubsan_handle_out_of_bounds+0xdb/0x130 lib/ubsan.c:283  dtSplitRoot+0x8d8/0x1900 fs/jfs/jfs_dtree.c:1971  dtSplitUp fs/jfs/jfs_dtree.c:985 [inline]  dtInsert+0x1189/0x6b80 fs/jfs/jfs_dtree.c:863  jfs_mkdir+0x757/0xb00 fs/jfs/namei.c:270  vfs_mkdir+0x3b3/0x590 fs/namei.c:4013  do_mkdirat+0x279/0x550 fs/namei.c:4038  __do_sys_mkdirat fs/namei.c:4053 [inline]  __se_sys_mkdirat fs/namei.c:4051 [inline]  __x64_sys_mkdirat+0x85/0x90 fs/namei.c:4051  do_syscall_x64 arch/x86/entry/common.c:50 [inline]  do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80  entry_SYSCALL_64_after_hwframe+0x63/0xcd RIP: 0033:0x7fcdc0113fd9 Code: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 \u003c48\u003e 3d 01 f0 ff ff 73 01 c3 48 c7 c1 c0 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007ffeb8bc67d8 EFLAGS: 00000246 ORIG_RAX: 0000000000000102 RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fcdc0113fd9 RDX: 0000000000000000 RSI: 0000000020000340 RDI: 0000000000000003 RBP: 00007fcdc00d37a0 R08: 0000000000000000 R09: 00007fcdc00d37a0 R10: 00005555559a72c0 R11: 0000000000000246 R12: 00000000f8008000 R13: 0000000000000000 R14: 00083878000000f8 R15: 0000000000000000  \u003c/TASK\u003e  The issue is caused when the value of fsi becomes less than -1. The check to break the loop when fsi value becomes -1 is present but syzbot was able to produce value less than -1 which cause the error. This patch simply add the change for the values less than 0.  The patch is tested via syzbot.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52603",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52588",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: fix to tag gcing flag on page during block migration  It needs to add missing gcing flag on page during block migration, in order to garantee migrated data be persisted during checkpoint, otherwise out-of-order persistency between data and node may cause data corruption after SPOR.  Similar issue was fixed by commit 2d1fe8a86bf5 (\"f2fs: fix to tag gcing flag on page during file defragment\").",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52588",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2021-47101",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  asix: fix uninit-value in asix_mdio_read()  asix_read_cmd() may read less than sizeof(smsr) bytes and in this case smsr will be uninitialized.  Fail log: BUG: KMSAN: uninit-value in asix_check_host_enable drivers/net/usb/asix_common.c:82 [inline] BUG: KMSAN: uninit-value in asix_check_host_enable drivers/net/usb/asix_common.c:82 [inline] drivers/net/usb/asix_common.c:497 BUG: KMSAN: uninit-value in asix_mdio_read+0x3c1/0xb00 drivers/net/usb/asix_common.c:497 drivers/net/usb/asix_common.c:497  asix_check_host_enable drivers/net/usb/asix_common.c:82 [inline]  asix_check_host_enable drivers/net/usb/asix_common.c:82 [inline] drivers/net/usb/asix_common.c:497  asix_mdio_read+0x3c1/0xb00 drivers/net/usb/asix_common.c:497 drivers/net/usb/asix_common.c:497",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-47101",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-7042",
            "namespace": "debian:11",
            "description": "A null pointer dereference vulnerability was found in ath10k_wmi_tlv_op_pull_mgmt_tx_compl_ev() in drivers/net/wireless/ath/ath10k/wmi-tlv.c in the Linux kernel. This issue could be exploited to trigger a denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-7042",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2020-36694",
            "namespace": "debian:11",
            "description": "An issue was discovered in netfilter in the Linux kernel before 5.10. There can be a use-after-free in the packet processing context, because the per-CPU sequence count is mishandled during concurrent iptables rules replacement. This could be exploited with the CAP_NET_ADMIN capability in an unprivileged namespace. NOTE: cc00bca was reverted in 5.12.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2020-36694",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-22099",
            "namespace": "debian:11",
            "description": "NULL Pointer Dereference vulnerability in Linux Linux kernel kernel on Linux, x86, ARM (net, bluetooth modules) allows Overflow Buffers. This vulnerability is associated with program files /net/bluetooth/rfcomm/core.C.  This issue affects Linux kernel: v2.6.12-rc2.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-22099",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-24855",
            "namespace": "debian:11",
            "description": "A race condition was found in the Linux kernel's scsi device driver in lpfc_unregister_fcf_rescan() function. This can result in a null pointer dereference issue, possibly leading to a kernel panic or denial of service issue.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-24855",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-23848",
            "namespace": "debian:11",
            "description": "In the Linux kernel through 6.7.1, there is a use-after-free in cec_queue_msg_fh, related to drivers/media/cec/core/cec-adap.c and drivers/media/cec/core/cec-api.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-23848",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26584",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  net: tls: handle backlogging of crypto requests  Since we're setting the CRYPTO_TFM_REQ_MAY_BACKLOG flag on our requests to the crypto API, crypto_aead_{encrypt,decrypt} can return  -EBUSY instead of -EINPROGRESS in valid situations. For example, when the cryptd queue for AESNI is full (easy to trigger with an artificially low cryptd.cryptd_max_cpu_qlen), requests will be enqueued to the backlog but still processed. In that case, the async callback will also be called twice: first with err == -EINPROGRESS, which it seems we can just ignore, then with err == 0.  Compared to Sabrina's original patch this version uses the new tls_*crypt_async_wait() helpers and converts the EBUSY to EINPROGRESS to avoid having to modify all the error handling paths. The handling is identical.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26584",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26635",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  llc: Drop support for ETH_P_TR_802_2.  syzbot reported an uninit-value bug below. [0]  llc supports ETH_P_802_2 (0x0004) and used to support ETH_P_TR_802_2 (0x0011), and syzbot abused the latter to trigger the bug.    write$tun(r0, \u0026(0x7f0000000040)={@val={0x0, 0x11}, @val, @mpls={[], @llc={@snap={0xaa, 0x1, ')', \"90e5dd\"}}}}, 0x16)  llc_conn_handler() initialises local variables {saddr,daddr}.mac based on skb in llc_pdu_decode_sa()/llc_pdu_decode_da() and passes them to __llc_lookup().  However, the initialisation is done only when skb-\u003eprotocol is htons(ETH_P_802_2), otherwise, __llc_lookup_established() and __llc_lookup_listener() will read garbage.  The missing initialisation existed prior to commit 211ed865108e (\"net: delete all instances of special processing for token ring\").  It removed the part to kick out the token ring stuff but forgot to close the door allowing ETH_P_TR_802_2 packets to sneak into llc_rcv().  Let's remove llc_tr_packet_type and complete the deprecation.  [0]: BUG: KMSAN: uninit-value in __llc_lookup_established+0xe9d/0xf90  __llc_lookup_established+0xe9d/0xf90  __llc_lookup net/llc/llc_conn.c:611 [inline]  llc_conn_handler+0x4bd/0x1360 net/llc/llc_conn.c:791  llc_rcv+0xfbb/0x14a0 net/llc/llc_input.c:206  __netif_receive_skb_one_core net/core/dev.c:5527 [inline]  __netif_receive_skb+0x1a6/0x5a0 net/core/dev.c:5641  netif_receive_skb_internal net/core/dev.c:5727 [inline]  netif_receive_skb+0x58/0x660 net/core/dev.c:5786  tun_rx_batched+0x3ee/0x980 drivers/net/tun.c:1555  tun_get_user+0x53af/0x66d0 drivers/net/tun.c:2002  tun_chr_write_iter+0x3af/0x5d0 drivers/net/tun.c:2048  call_write_iter include/linux/fs.h:2020 [inline]  new_sync_write fs/read_write.c:491 [inline]  vfs_write+0x8ef/0x1490 fs/read_write.c:584  ksys_write+0x20f/0x4c0 fs/read_write.c:637  __do_sys_write fs/read_write.c:649 [inline]  __se_sys_write fs/read_write.c:646 [inline]  __x64_sys_write+0x93/0xd0 fs/read_write.c:646  do_syscall_x64 arch/x86/entry/common.c:51 [inline]  do_syscall_64+0x44/0x110 arch/x86/entry/common.c:82  entry_SYSCALL_64_after_hwframe+0x63/0x6b  Local variable daddr created at:  llc_conn_handler+0x53/0x1360 net/llc/llc_conn.c:783  llc_rcv+0xfbb/0x14a0 net/llc/llc_input.c:206  CPU: 1 PID: 5004 Comm: syz-executor994 Not tainted 6.6.0-syzkaller-14500-g1c41041124bd #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/09/2023",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26635",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26651",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  sr9800: Add check for usbnet_get_endpoints  Add check for usbnet_get_endpoints() and return the error if it fails in order to transfer the error.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26651",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26644",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: don't abort filesystem when attempting to snapshot deleted subvolume  If the source file descriptor to the snapshot ioctl refers to a deleted subvolume, we get the following abort:    BTRFS: Transaction aborted (error -2)   WARNING: CPU: 0 PID: 833 at fs/btrfs/transaction.c:1875 create_pending_snapshot+0x1040/0x1190 [btrfs]   Modules linked in: pata_acpi btrfs ata_piix libata scsi_mod virtio_net blake2b_generic xor net_failover virtio_rng failover scsi_common rng_core raid6_pq libcrc32c   CPU: 0 PID: 833 Comm: t_snapshot_dele Not tainted 6.7.0-rc6 #2   Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-1.fc39 04/01/2014   RIP: 0010:create_pending_snapshot+0x1040/0x1190 [btrfs]   RSP: 0018:ffffa09c01337af8 EFLAGS: 00010282   RAX: 0000000000000000 RBX: ffff9982053e7c78 RCX: 0000000000000027   RDX: ffff99827dc20848 RSI: 0000000000000001 RDI: ffff99827dc20840   RBP: ffffa09c01337c00 R08: 0000000000000000 R09: ffffa09c01337998   R10: 0000000000000003 R11: ffffffffb96da248 R12: fffffffffffffffe   R13: ffff99820535bb28 R14: ffff99820b7bd000 R15: ffff99820381ea80   FS:  00007fe20aadabc0(0000) GS:ffff99827dc00000(0000) knlGS:0000000000000000   CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033   CR2: 0000559a120b502f CR3: 00000000055b6000 CR4: 00000000000006f0   Call Trace:    \u003cTASK\u003e    ? create_pending_snapshot+0x1040/0x1190 [btrfs]    ? __warn+0x81/0x130    ? create_pending_snapshot+0x1040/0x1190 [btrfs]    ? report_bug+0x171/0x1a0    ? handle_bug+0x3a/0x70    ? exc_invalid_op+0x17/0x70    ? asm_exc_invalid_op+0x1a/0x20    ? create_pending_snapshot+0x1040/0x1190 [btrfs]    ? create_pending_snapshot+0x1040/0x1190 [btrfs]    create_pending_snapshots+0x92/0xc0 [btrfs]    btrfs_commit_transaction+0x66b/0xf40 [btrfs]    btrfs_mksubvol+0x301/0x4d0 [btrfs]    btrfs_mksnapshot+0x80/0xb0 [btrfs]    __btrfs_ioctl_snap_create+0x1c2/0x1d0 [btrfs]    btrfs_ioctl_snap_create_v2+0xc4/0x150 [btrfs]    btrfs_ioctl+0x8a6/0x2650 [btrfs]    ? kmem_cache_free+0x22/0x340    ? do_sys_openat2+0x97/0xe0    __x64_sys_ioctl+0x97/0xd0    do_syscall_64+0x46/0xf0    entry_SYSCALL_64_after_hwframe+0x6e/0x76   RIP: 0033:0x7fe20abe83af   RSP: 002b:00007ffe6eff1360 EFLAGS: 00000246 ORIG_RAX: 0000000000000010   RAX: ffffffffffffffda RBX: 0000000000000004 RCX: 00007fe20abe83af   RDX: 00007ffe6eff23c0 RSI: 0000000050009417 RDI: 0000000000000003   RBP: 0000000000000003 R08: 0000000000000000 R09: 00007fe20ad16cd0   R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000   R13: 00007ffe6eff13c0 R14: 00007fe20ad45000 R15: 0000559a120b6d58    \u003c/TASK\u003e   ---[ end trace 0000000000000000 ]---   BTRFS: error (device vdc: state A) in create_pending_snapshot:1875: errno=-2 No such entry   BTRFS info (device vdc: state EA): forced readonly   BTRFS warning (device vdc: state EA): Skipping commit of aborted transaction.   BTRFS: error (device vdc: state EA) in cleanup_transaction:2055: errno=-2 No such entry  This happens because create_pending_snapshot() initializes the new root item as a copy of the source root item. This includes the refs field, which is 0 for a deleted subvolume. The call to btrfs_insert_root() therefore inserts a root with refs == 0. btrfs_get_new_fs_root() then finds the root and returns -ENOENT if refs == 0, which causes create_pending_snapshot() to abort.  Fix it by checking the source root's refs before attempting the snapshot, but after locking subvol_sem to avoid racing with deletion.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26644",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52622",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  ext4: avoid online resizing failures due to oversized flex bg  When we online resize an ext4 filesystem with a oversized flexbg_size,       mkfs.ext4 -F -G 67108864 $dev -b 4096 100M      mount $dev $dir      resize2fs $dev 16G  the following WARN_ON is triggered: ================================================================== WARNING: CPU: 0 PID: 427 at mm/page_alloc.c:4402 __alloc_pages+0x411/0x550 Modules linked in: sg(E) CPU: 0 PID: 427 Comm: resize2fs Tainted: G  E  6.6.0-rc5+ #314 RIP: 0010:__alloc_pages+0x411/0x550 Call Trace:  \u003cTASK\u003e  __kmalloc_large_node+0xa2/0x200  __kmalloc+0x16e/0x290  ext4_resize_fs+0x481/0xd80  __ext4_ioctl+0x1616/0x1d90  ext4_ioctl+0x12/0x20  __x64_sys_ioctl+0xf0/0x150  do_syscall_64+0x3b/0x90 ==================================================================  This is because flexbg_size is too large and the size of the new_group_data array to be allocated exceeds MAX_ORDER. Currently, the minimum value of MAX_ORDER is 8, the minimum value of PAGE_SIZE is 4096, the corresponding maximum number of groups that can be allocated is:   (PAGE_SIZE \u003c\u003c MAX_ORDER) / sizeof(struct ext4_new_group_data) ≈ 21845  And the value that is down-aligned to the power of 2 is 16384. Therefore, this value is defined as MAX_RESIZE_BG, and the number of groups added each time does not exceed this value during resizing, and is added multiple times to complete the online resizing. The difference is that the metadata in a flex_bg may be more dispersed.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52622",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52621",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Check rcu_read_lock_trace_held() before calling bpf map helpers  These three bpf_map_{lookup,update,delete}_elem() helpers are also available for sleepable bpf program, so add the corresponding lock assertion for sleepable bpf program, otherwise the following warning will be reported when a sleepable bpf program manipulates bpf map under interpreter mode (aka bpf_jit_enable=0):    WARNING: CPU: 3 PID: 4985 at kernel/bpf/helpers.c:40 ......   CPU: 3 PID: 4985 Comm: test_progs Not tainted 6.6.0+ #2   Hardware name: QEMU Standard PC (i440FX + PIIX, 1996) ......   RIP: 0010:bpf_map_lookup_elem+0x54/0x60   ......   Call Trace:    \u003cTASK\u003e    ? __warn+0xa5/0x240    ? bpf_map_lookup_elem+0x54/0x60    ? report_bug+0x1ba/0x1f0    ? handle_bug+0x40/0x80    ? exc_invalid_op+0x18/0x50    ? asm_exc_invalid_op+0x1b/0x20    ? __pfx_bpf_map_lookup_elem+0x10/0x10    ? rcu_lockdep_current_cpu_online+0x65/0xb0    ? rcu_is_watching+0x23/0x50    ? bpf_map_lookup_elem+0x54/0x60    ? __pfx_bpf_map_lookup_elem+0x10/0x10    ___bpf_prog_run+0x513/0x3b70    __bpf_prog_run32+0x9d/0xd0    ? __bpf_prog_enter_sleepable_recur+0xad/0x120    ? __bpf_prog_enter_sleepable_recur+0x3e/0x120    bpf_trampoline_6442580665+0x4d/0x1000    __x64_sys_getpgid+0x5/0x30    ? do_syscall_64+0x36/0xb0    entry_SYSCALL_64_after_hwframe+0x6e/0x76    \u003c/TASK\u003e",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52621",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26647",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Fix late derefrence 'dsc' check in 'link_set_dsc_pps_packet()'  In link_set_dsc_pps_packet(), 'struct display_stream_compressor *dsc' was dereferenced in a DC_LOGGER_INIT(dsc-\u003ectx-\u003elogger); before the 'dsc' NULL pointer check.  Fixes the below: drivers/gpu/drm/amd/amdgpu/../display/dc/link/link_dpms.c:905 link_set_dsc_pps_packet() warn: variable dereferenced before check 'dsc' (see line 903)",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26647",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-4133",
            "namespace": "debian:11",
            "description": "A use-after-free vulnerability was found in the cxgb4 driver in the Linux kernel. The bug occurs when the cxgb4 device is detaching due to a possible rearming of the flower_stats_timer from the work queue. This flaw allows a local user to crash the system, causing a denial of service condition.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4133",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26615",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  net/smc: fix illegal rmb_desc access in SMC-D connection dump  A crash was found when dumping SMC-D connections. It can be reproduced by following steps:  - run nginx/wrk test:   smc_run nginx   smc_run wrk -t 16 -c 1000 -d \u003cduration\u003e -H 'Connection: Close' \u003cURL\u003e  - continuously dump SMC-D connections in parallel:   watch -n 1 'smcss -D'   BUG: kernel NULL pointer dereference, address: 0000000000000030  CPU: 2 PID: 7204 Comm: smcss Kdump: loaded Tainted: G\tE      6.7.0+ #55  RIP: 0010:__smc_diag_dump.constprop.0+0x5e5/0x620 [smc_diag]  Call Trace:   \u003cTASK\u003e   ? __die+0x24/0x70   ? page_fault_oops+0x66/0x150   ? exc_page_fault+0x69/0x140   ? asm_exc_page_fault+0x26/0x30   ? __smc_diag_dump.constprop.0+0x5e5/0x620 [smc_diag]   ? __kmalloc_node_track_caller+0x35d/0x430   ? __alloc_skb+0x77/0x170   smc_diag_dump_proto+0xd0/0xf0 [smc_diag]   smc_diag_dump+0x26/0x60 [smc_diag]   netlink_dump+0x19f/0x320   __netlink_dump_start+0x1dc/0x300   smc_diag_handler_dump+0x6a/0x80 [smc_diag]   ? __pfx_smc_diag_dump+0x10/0x10 [smc_diag]   sock_diag_rcv_msg+0x121/0x140   ? __pfx_sock_diag_rcv_msg+0x10/0x10   netlink_rcv_skb+0x5a/0x110   sock_diag_rcv+0x28/0x40   netlink_unicast+0x22a/0x330   netlink_sendmsg+0x1f8/0x420   __sock_sendmsg+0xb0/0xc0   ____sys_sendmsg+0x24e/0x300   ? copy_msghdr_from_user+0x62/0x80   ___sys_sendmsg+0x7c/0xd0   ? __do_fault+0x34/0x160   ? do_read_fault+0x5f/0x100   ? do_fault+0xb0/0x110   ? __handle_mm_fault+0x2b0/0x6c0   __sys_sendmsg+0x4d/0x80   do_syscall_64+0x69/0x180   entry_SYSCALL_64_after_hwframe+0x6e/0x76  It is possible that the connection is in process of being established when we dump it. Assumed that the connection has been registered in a link group by smc_conn_create() but the rmb_desc has not yet been initialized by smc_buf_create(), thus causing the illegal access to conn-\u003ermb_desc. So fix it by checking before dump.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26615",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2022-3567",
            "namespace": "debian:11",
            "description": "A vulnerability has been found in Linux Kernel and classified as problematic. This vulnerability affects the function inet6_stream_ops/inet6_dgram_ops of the component IPv6 Handler. The manipulation leads to race condition. It is recommended to apply a patch to fix this issue. VDB-211090 is the identifier assigned to this vulnerability.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-3567",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52624",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Wake DMCUB before executing GPINT commands  [Why] DMCUB can be in idle when we attempt to interface with the HW through the GPINT mailbox resulting in a system hang.  [How] Add dc_wake_and_execute_gpint() to wrap the wake, execute, sleep sequence.  If the GPINT executes successfully then DMCUB will be put back into sleep after the optional response is returned.  It functions similar to the inbox command interface.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52624",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26648",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Fix variable deferencing before NULL check in edp_setup_replay()  In edp_setup_replay(), 'struct dc *dc' \u0026 'struct dmub_replay *replay' was dereferenced before the pointer 'link' \u0026 'replay' NULL check.  Fixes the below: drivers/gpu/drm/amd/amdgpu/../display/dc/link/protocols/link_edp_panel_control.c:947 edp_setup_replay() warn: variable dereferenced before check 'link' (see line 933)",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26648",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26646",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  thermal: intel: hfi: Add syscore callbacks for system-wide PM  The kernel allocates a memory buffer and provides its location to the hardware, which uses it to update the HFI table. This allocation occurs during boot and remains constant throughout runtime.  When resuming from hibernation, the restore kernel allocates a second memory buffer and reprograms the HFI hardware with the new location as part of a normal boot. The location of the second memory buffer may differ from the one allocated by the image kernel.  When the restore kernel transfers control to the image kernel, its HFI buffer becomes invalid, potentially leading to memory corruption if the hardware writes to it (the hardware continues to use the buffer from the restore kernel).  It is also possible that the hardware \"forgets\" the address of the memory buffer when resuming from \"deep\" suspend. Memory corruption may also occur in such a scenario.  To prevent the described memory corruption, disable HFI when preparing to suspend or hibernate. Enable it when resuming.  Add syscore callbacks to handle the package of the boot CPU (packages of non-boot CPUs are handled via CPU offline). Syscore ops always run on the boot CPU. Additionally, HFI only needs to be disabled during \"deep\" suspend and hibernation. Syscore ops only run in these cases.  [ rjw: Comment adjustment, subject and changelog edits ]",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26646",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52623",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  SUNRPC: Fix a suspicious RCU usage warning  I received the following warning while running cthon against an ontap server running pNFS:  [   57.202521] ============================= [   57.202522] WARNING: suspicious RCU usage [   57.202523] 6.7.0-rc3-g2cc14f52aeb7 #41492 Not tainted [   57.202525] ----------------------------- [   57.202525] net/sunrpc/xprtmultipath.c:349 RCU-list traversed in non-reader section!! [   57.202527]                other info that might help us debug this:  [   57.202528]                rcu_scheduler_active = 2, debug_locks = 1 [   57.202529] no locks held by test5/3567. [   57.202530]                stack backtrace: [   57.202532] CPU: 0 PID: 3567 Comm: test5 Not tainted 6.7.0-rc3-g2cc14f52aeb7 #41492 5b09971b4965c0aceba19f3eea324a4a806e227e [   57.202534] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS unknown 2/2/2022 [   57.202536] Call Trace: [   57.202537]  \u003cTASK\u003e [   57.202540]  dump_stack_lvl+0x77/0xb0 [   57.202551]  lockdep_rcu_suspicious+0x154/0x1a0 [   57.202556]  rpc_xprt_switch_has_addr+0x17c/0x190 [sunrpc ebe02571b9a8ceebf7d98e71675af20c19bdb1f6] [   57.202596]  rpc_clnt_setup_test_and_add_xprt+0x50/0x180 [sunrpc ebe02571b9a8ceebf7d98e71675af20c19bdb1f6] [   57.202621]  ? rpc_clnt_add_xprt+0x254/0x300 [sunrpc ebe02571b9a8ceebf7d98e71675af20c19bdb1f6] [   57.202646]  rpc_clnt_add_xprt+0x27a/0x300 [sunrpc ebe02571b9a8ceebf7d98e71675af20c19bdb1f6] [   57.202671]  ? __pfx_rpc_clnt_setup_test_and_add_xprt+0x10/0x10 [sunrpc ebe02571b9a8ceebf7d98e71675af20c19bdb1f6] [   57.202696]  nfs4_pnfs_ds_connect+0x345/0x760 [nfsv4 c716d88496ded0ea6d289bbea684fa996f9b57a9] [   57.202728]  ? __pfx_nfs4_test_session_trunk+0x10/0x10 [nfsv4 c716d88496ded0ea6d289bbea684fa996f9b57a9] [   57.202754]  nfs4_fl_prepare_ds+0x75/0xc0 [nfs_layout_nfsv41_files e3a4187f18ae8a27b630f9feae6831b584a9360a] [   57.202760]  filelayout_write_pagelist+0x4a/0x200 [nfs_layout_nfsv41_files e3a4187f18ae8a27b630f9feae6831b584a9360a] [   57.202765]  pnfs_generic_pg_writepages+0xbe/0x230 [nfsv4 c716d88496ded0ea6d289bbea684fa996f9b57a9] [   57.202788]  __nfs_pageio_add_request+0x3fd/0x520 [nfs 6c976fa593a7c2976f5a0aeb4965514a828e6902] [   57.202813]  nfs_pageio_add_request+0x18b/0x390 [nfs 6c976fa593a7c2976f5a0aeb4965514a828e6902] [   57.202831]  nfs_do_writepage+0x116/0x1e0 [nfs 6c976fa593a7c2976f5a0aeb4965514a828e6902] [   57.202849]  nfs_writepages_callback+0x13/0x30 [nfs 6c976fa593a7c2976f5a0aeb4965514a828e6902] [   57.202866]  write_cache_pages+0x265/0x450 [   57.202870]  ? __pfx_nfs_writepages_callback+0x10/0x10 [nfs 6c976fa593a7c2976f5a0aeb4965514a828e6902] [   57.202891]  nfs_writepages+0x141/0x230 [nfs 6c976fa593a7c2976f5a0aeb4965514a828e6902] [   57.202913]  do_writepages+0xd2/0x230 [   57.202917]  ? filemap_fdatawrite_wbc+0x5c/0x80 [   57.202921]  filemap_fdatawrite_wbc+0x67/0x80 [   57.202924]  filemap_write_and_wait_range+0xd9/0x170 [   57.202930]  nfs_wb_all+0x49/0x180 [nfs 6c976fa593a7c2976f5a0aeb4965514a828e6902] [   57.202947]  nfs4_file_flush+0x72/0xb0 [nfsv4 c716d88496ded0ea6d289bbea684fa996f9b57a9] [   57.202969]  __se_sys_close+0x46/0xd0 [   57.202972]  do_syscall_64+0x68/0x100 [   57.202975]  ? do_syscall_64+0x77/0x100 [   57.202976]  ? do_syscall_64+0x77/0x100 [   57.202979]  entry_SYSCALL_64_after_hwframe+0x6e/0x76 [   57.202982] RIP: 0033:0x7fe2b12e4a94 [   57.202985] Code: 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 80 3d d5 18 0e 00 00 74 13 b8 03 00 00 00 0f 05 \u003c48\u003e 3d 00 f0 ff ff 77 44 c3 0f 1f 00 48 83 ec 18 89 7c 24 0c e8 c3 [   57.202987] RSP: 002b:00007ffe857ddb38 EFLAGS: 00000202 ORIG_RAX: 0000000000000003 [   57.202989] RAX: ffffffffffffffda RBX: 00007ffe857dfd68 RCX: 00007fe2b12e4a94 [   57.202991] RDX: 0000000000002000 RSI: 00007ffe857ddc40 RDI: 0000000000000003 [   57.202992] RBP: 00007ffe857dfc50 R08: 7fffffffffffffff R09: 0000000065650f49 [   57.202993] R10: 00007f ---truncated---",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52623",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26645",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  tracing: Ensure visibility when inserting an element into tracing_map  Running the following two commands in parallel on a multi-processor AArch64 machine can sporadically produce an unexpected warning about duplicate histogram entries:   $ while true; do      echo hist:key=id.syscall:val=hitcount \u003e \\        /sys/kernel/debug/tracing/events/raw_syscalls/sys_enter/trigger      cat /sys/kernel/debug/tracing/events/raw_syscalls/sys_enter/hist      sleep 0.001    done  $ stress-ng --sysbadaddr $(nproc)  The warning looks as follows:  [ 2911.172474] ------------[ cut here ]------------ [ 2911.173111] Duplicates detected: 1 [ 2911.173574] WARNING: CPU: 2 PID: 12247 at kernel/trace/tracing_map.c:983 tracing_map_sort_entries+0x3e0/0x408 [ 2911.174702] Modules linked in: iscsi_ibft(E) iscsi_boot_sysfs(E) rfkill(E) af_packet(E) nls_iso8859_1(E) nls_cp437(E) vfat(E) fat(E) ena(E) tiny_power_button(E) qemu_fw_cfg(E) button(E) fuse(E) efi_pstore(E) ip_tables(E) x_tables(E) xfs(E) libcrc32c(E) aes_ce_blk(E) aes_ce_cipher(E) crct10dif_ce(E) polyval_ce(E) polyval_generic(E) ghash_ce(E) gf128mul(E) sm4_ce_gcm(E) sm4_ce_ccm(E) sm4_ce(E) sm4_ce_cipher(E) sm4(E) sm3_ce(E) sm3(E) sha3_ce(E) sha512_ce(E) sha512_arm64(E) sha2_ce(E) sha256_arm64(E) nvme(E) sha1_ce(E) nvme_core(E) nvme_auth(E) t10_pi(E) sg(E) scsi_mod(E) scsi_common(E) efivarfs(E) [ 2911.174738] Unloaded tainted modules: cppc_cpufreq(E):1 [ 2911.180985] CPU: 2 PID: 12247 Comm: cat Kdump: loaded Tainted: G            E      6.7.0-default #2 1b58bbb22c97e4399dc09f92d309344f69c44a01 [ 2911.182398] Hardware name: Amazon EC2 c7g.8xlarge/, BIOS 1.0 11/1/2018 [ 2911.183208] pstate: 61400005 (nZCv daif +PAN -UAO -TCO +DIT -SSBS BTYPE=--) [ 2911.184038] pc : tracing_map_sort_entries+0x3e0/0x408 [ 2911.184667] lr : tracing_map_sort_entries+0x3e0/0x408 [ 2911.185310] sp : ffff8000a1513900 [ 2911.185750] x29: ffff8000a1513900 x28: ffff0003f272fe80 x27: 0000000000000001 [ 2911.186600] x26: ffff0003f272fe80 x25: 0000000000000030 x24: 0000000000000008 [ 2911.187458] x23: ffff0003c5788000 x22: ffff0003c16710c8 x21: ffff80008017f180 [ 2911.188310] x20: ffff80008017f000 x19: ffff80008017f180 x18: ffffffffffffffff [ 2911.189160] x17: 0000000000000000 x16: 0000000000000000 x15: ffff8000a15134b8 [ 2911.190015] x14: 0000000000000000 x13: 205d373432323154 x12: 5b5d313131333731 [ 2911.190844] x11: 00000000fffeffff x10: 00000000fffeffff x9 : ffffd1b78274a13c [ 2911.191716] x8 : 000000000017ffe8 x7 : c0000000fffeffff x6 : 000000000057ffa8 [ 2911.192554] x5 : ffff0012f6c24ec0 x4 : 0000000000000000 x3 : ffff2e5b72b5d000 [ 2911.193404] x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff0003ff254480 [ 2911.194259] Call trace: [ 2911.194626]  tracing_map_sort_entries+0x3e0/0x408 [ 2911.195220]  hist_show+0x124/0x800 [ 2911.195692]  seq_read_iter+0x1d4/0x4e8 [ 2911.196193]  seq_read+0xe8/0x138 [ 2911.196638]  vfs_read+0xc8/0x300 [ 2911.197078]  ksys_read+0x70/0x108 [ 2911.197534]  __arm64_sys_read+0x24/0x38 [ 2911.198046]  invoke_syscall+0x78/0x108 [ 2911.198553]  el0_svc_common.constprop.0+0xd0/0xf8 [ 2911.199157]  do_el0_svc+0x28/0x40 [ 2911.199613]  el0_svc+0x40/0x178 [ 2911.200048]  el0t_64_sync_handler+0x13c/0x158 [ 2911.200621]  el0t_64_sync+0x1a8/0x1b0 [ 2911.201115] ---[ end trace 0000000000000000 ]---  The problem appears to be caused by CPU reordering of writes issued from __tracing_map_insert().  The check for the presence of an element with a given key in this function is:   val = READ_ONCE(entry-\u003eval);  if (val \u0026\u0026 keys_match(key, val-\u003ekey, map-\u003ekey_size)) ...  The write of a new entry is:   elt = get_free_elt(map);  memcpy(elt-\u003ekey, key, map-\u003ekey_size);  entry-\u003eval = elt;  The \"memcpy(elt-\u003ekey, key, map-\u003ekey_size);\" and \"entry-\u003eval = elt;\" stores may become visible in the reversed order on another CPU. This second CPU might then incorrectly determine that a new key doesn't match an already present val-\u003ekey and subse ---truncated---",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26645",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52561",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  arm64: dts: qcom: sdm845-db845c: Mark cont splash memory region as reserved  Adding a reserved memory region for the framebuffer memory (the splash memory region set up by the bootloader).  It fixes a kernel panic (arm-smmu: Unhandled context fault at this particular memory region) reported on DB845c running v5.10.y.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52561",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26602",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  sched/membarrier: reduce the ability to hammer on sys_membarrier  On some systems, sys_membarrier can be very expensive, causing overall slowdowns for everything.  So put a lock on the path in order to serialize the accesses to prevent the ability for this to be called at too high of a frequency and saturate the machine.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26602",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-24858",
            "namespace": "debian:11",
            "description": "A race condition was found in the Linux kernel's net/bluetooth in {conn,adv}_{min,max}_interval_set() function. This can result in I2cap connection or broadcast abnormality issue, possibly leading to denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-24858",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "openssl",
            "featureversion": "1.1.1w-0+deb11u1",
            "vulnerability": "CVE-2023-5678",
            "namespace": "debian:11",
            "description": "Issue summary: Generating excessively long X9.42 DH keys or checking excessively long X9.42 DH keys or parameters may be very slow.  Impact summary: Applications that use the functions DH_generate_key() to generate an X9.42 DH key may experience long delays.  Likewise, applications that use DH_check_pub_key(), DH_check_pub_key_ex() or EVP_PKEY_public_check() to check an X9.42 DH key or X9.42 DH parameters may experience long delays. Where the key or parameters that are being checked have been obtained from an untrusted source this may lead to a Denial of Service.  While DH_check() performs all the necessary checks (as of CVE-2023-3817), DH_check_pub_key() doesn't make any of these checks, and is therefore vulnerable for excessively large P and Q parameters.  Likewise, while DH_generate_key() performs a check for an excessively large P, it doesn't check for an excessively large Q.  An application that calls DH_generate_key() or DH_check_pub_key() and supplies a key or parameters obtained from an untrusted source could be vulnerable to a Denial of Service attack.  DH_generate_key() and DH_check_pub_key() are also called by a number of other OpenSSL functions.  An application calling any of those other functions may similarly be affected.  The other functions affected by this are DH_check_pub_key_ex(), EVP_PKEY_public_check(), and EVP_PKEY_generate().  Also vulnerable are the OpenSSL pkey command line application when using the \"-pubcheck\" option, as well as the OpenSSL genpkey command line application.  The OpenSSL SSL/TLS implementation is not affected by this issue.  The OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-5678",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52619",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  pstore/ram: Fix crash when setting number of cpus to an odd number  When the number of cpu cores is adjusted to 7 or other odd numbers, the zone size will become an odd number. The address of the zone will become:     addr of zone0 = BASE     addr of zone1 = BASE + zone_size     addr of zone2 = BASE + zone_size*2     ... The address of zone1/3/5/7 will be mapped to non-alignment va. Eventually crashes will occur when accessing these va.  So, use ALIGN_DOWN() to make sure the zone size is even to avoid this bug.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52619",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-25740",
            "namespace": "debian:11",
            "description": "A memory leak flaw was found in the UBI driver in drivers/mtd/ubi/attach.c in the Linux kernel through 6.7.4 for UBI_IOCATT, because kobj-\u003ename is not released.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-25740",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "gnutls28",
            "featureversion": "3.7.1-5+deb11u4",
            "vulnerability": "CVE-2024-0553",
            "namespace": "debian:11",
            "description": "A vulnerability was found in GnuTLS. The response times to malformed ciphertexts in RSA-PSK ClientKeyExchange differ from the response times of ciphertexts with correct PKCS#1 v1.5 padding. This issue may allow a remote attacker to perform a timing side-channel attack in the RSA-PSK key exchange, potentially leading to the leakage of sensitive data. CVE-2024-0553 is designated as an incomplete resolution for CVE-2023-5981.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-0553",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52434",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  smb: client: fix potential OOBs in smb2_parse_contexts()  Validate offsets and lengths before dereferencing create contexts in smb2_parse_contexts().  This fixes following oops when accessing invalid create contexts from server:    BUG: unable to handle page fault for address: ffff8881178d8cc3   #PF: supervisor read access in kernel mode   #PF: error_code(0x0000) - not-present page   PGD 4a01067 P4D 4a01067 PUD 0   Oops: 0000 [#1] PREEMPT SMP NOPTI   CPU: 3 PID: 1736 Comm: mount.cifs Not tainted 6.7.0-rc4 #1   Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS   rel-1.16.2-3-gd478f380-rebuilt.opensuse.org 04/01/2014   RIP: 0010:smb2_parse_contexts+0xa0/0x3a0 [cifs]   Code: f8 10 75 13 48 b8 93 ad 25 50 9c b4 11 e7 49 39 06 0f 84 d2 00   00 00 8b 45 00 85 c0 74 61 41 29 c5 48 01 c5 41 83 fd 0f 76 55 \u003c0f\u003e b7   7d 04 0f b7 45 06 4c 8d 74 3d 00 66 83 f8 04 75 bc ba 04 00   RSP: 0018:ffffc900007939e0 EFLAGS: 00010216   RAX: ffffc90000793c78 RBX: ffff8880180cc000 RCX: ffffc90000793c90   RDX: ffffc90000793cc0 RSI: ffff8880178d8cc0 RDI: ffff8880180cc000   RBP: ffff8881178d8cbf R08: ffffc90000793c22 R09: 0000000000000000   R10: ffff8880180cc000 R11: 0000000000000024 R12: 0000000000000000   R13: 0000000000000020 R14: 0000000000000000 R15: ffffc90000793c22   FS: 00007f873753cbc0(0000) GS:ffff88806bc00000(0000)   knlGS:0000000000000000   CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033   CR2: ffff8881178d8cc3 CR3: 00000000181ca000 CR4: 0000000000750ef0   PKRU: 55555554   Call Trace:    \u003cTASK\u003e    ? __die+0x23/0x70    ? page_fault_oops+0x181/0x480    ? search_module_extables+0x19/0x60    ? srso_alias_return_thunk+0x5/0xfbef5    ? exc_page_fault+0x1b6/0x1c0    ? asm_exc_page_fault+0x26/0x30    ? smb2_parse_contexts+0xa0/0x3a0 [cifs]    SMB2_open+0x38d/0x5f0 [cifs]    ? smb2_is_path_accessible+0x138/0x260 [cifs]    smb2_is_path_accessible+0x138/0x260 [cifs]    cifs_is_path_remote+0x8d/0x230 [cifs]    cifs_mount+0x7e/0x350 [cifs]    cifs_smb3_do_mount+0x128/0x780 [cifs]    smb3_get_tree+0xd9/0x290 [cifs]    vfs_get_tree+0x2c/0x100    ? capable+0x37/0x70    path_mount+0x2d7/0xb80    ? srso_alias_return_thunk+0x5/0xfbef5    ? _raw_spin_unlock_irqrestore+0x44/0x60    __x64_sys_mount+0x11a/0x150    do_syscall_64+0x47/0xf0    entry_SYSCALL_64_after_hwframe+0x6f/0x77   RIP: 0033:0x7f8737657b1e",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52434",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "gnutls28",
            "featureversion": "3.7.1-5+deb11u4",
            "vulnerability": "CVE-2024-28835",
            "namespace": "debian:11",
            "description": "A flaw has been discovered in GnuTLS where an application crash can be induced when attempting to verify a specially crafted .pem bundle using the \"certtool --verify-chain\" command.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-28835",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "gnutls28",
            "featureversion": "3.7.1-5+deb11u4",
            "vulnerability": "CVE-2024-28834",
            "namespace": "debian:11",
            "description": "A flaw was found in GnuTLS. The Minerva attack is a cryptographic vulnerability that exploits deterministic behavior in systems like GnuTLS, leading to side-channel leaks. In specific scenarios, such as when using the GNUTLS_PRIVKEY_FLAG_REPRODUCIBLE flag, it can result in a noticeable step in nonce size from 513 to 512 bits, exposing a potential timing side-channel.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-28834",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-31083",
            "namespace": "debian:11",
            "description": "An issue was discovered in drivers/bluetooth/hci_ldisc.c in the Linux kernel 6.2. In hci_uart_tty_ioctl, there is a race condition between HCIUARTSETPROTO and HCIUARTGETPROTO. HCI_UART_PROTO_SET is set before hu-\u003eproto is set. A NULL pointer dereference may occur.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-31083",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "krb5",
            "featureversion": "1.18.3-6+deb11u4",
            "vulnerability": "CVE-2024-26458",
            "namespace": "debian:11",
            "description": "Kerberos 5 (aka krb5) 1.21.2 contains a memory leak in /krb5/src/lib/rpc/pmap_rmt.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26458",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "krb5",
            "featureversion": "1.18.3-6+deb11u4",
            "vulnerability": "CVE-2024-26461",
            "namespace": "debian:11",
            "description": "Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/lib/gssapi/krb5/k5sealv3.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26461",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52585",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: Fix possible NULL dereference in amdgpu_ras_query_error_status_helper()  Return invalid error code -EINVAL for invalid block id.  Fixes the below:  drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c:1183 amdgpu_ras_query_error_status_helper() error: we previously assumed 'info' could be null (see line 1176)",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52585",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "krb5",
            "featureversion": "1.18.3-6+deb11u4",
            "vulnerability": "CVE-2024-26462",
            "namespace": "debian:11",
            "description": "Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/kdc/ndr.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26462",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "procps",
            "featureversion": "2:3.3.17-5",
            "vulnerability": "CVE-2023-4016",
            "namespace": "debian:11",
            "description": "Under some circumstances, this weakness allows a user who has access to run the “ps” utility on a machine, the ability to write almost unlimited amounts of unfiltered data into the process heap.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4016",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52617",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  PCI: switchtec: Fix stdev_release() crash after surprise hot remove  A PCI device hot removal may occur while stdev-\u003ecdev is held open. The call to stdev_release() then happens during close or exit, at a point way past switchtec_pci_remove(). Otherwise the last ref would vanish with the trailing put_device(), just before return.  At that later point in time, the devm cleanup has already removed the stdev-\u003emmio_mrpc mapping. Also, the stdev-\u003epdev reference was not a counted one. Therefore, in DMA mode, the iowrite32() in stdev_release() will cause a fatal page fault, and the subsequent dma_free_coherent(), if reached, would pass a stale \u0026stdev-\u003epdev-\u003edev pointer.  Fix by moving MRPC DMA shutdown into switchtec_pci_remove(), after stdev_kill(). Counting the stdev-\u003epdev ref is now optional, but may prevent future accidents.  Reproducible via the script at https://lore.kernel.org/r/20231113212150.96410-1-dns@arista.com",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52617",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52531",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: iwlwifi: mvm: Fix a memory corruption issue  A few lines above, space is kzalloc()'ed for: \tsizeof(struct iwl_nvm_data) + \tsizeof(struct ieee80211_channel) + \tsizeof(struct ieee80211_rate)  'mvm-\u003envm_data' is a 'struct iwl_nvm_data', so it is fine.  At the end of this structure, there is the 'channels' flex array. Each element is of type 'struct ieee80211_channel'. So only 1 element is allocated in this array.  When doing:   mvm-\u003envm_data-\u003ebands[0].channels = mvm-\u003envm_data-\u003echannels; We point at the first element of the 'channels' flex array. So this is fine.  However, when doing:   mvm-\u003envm_data-\u003ebands[0].bitrates = \t\t\t(void *)((u8 *)mvm-\u003envm_data-\u003echannels + 1); because of the \"(u8 *)\" cast, we add only 1 to the address of the beginning of the flex array.  It is likely that we want point at the 'struct ieee80211_rate' allocated just after.  Remove the spurious casting so that the pointer arithmetic works as expected.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52531",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "libgcrypt20",
            "featureversion": "1.8.7-6",
            "vulnerability": "CVE-2024-2236",
            "namespace": "debian:11",
            "description": "A timing-based side-channel flaw was found in libgcrypt's RSA implementation. This issue may allow a remote attacker to initiate a Bleichenbacher-style attack, which can lead to the decryption of RSA ciphertexts.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-2236",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52476",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  perf/x86/lbr: Filter vsyscall addresses  We found that a panic can occur when a vsyscall is made while LBR sampling is active. If the vsyscall is interrupted (NMI) for perf sampling, this call sequence can occur (most recent at top):      __insn_get_emulate_prefix()     insn_get_emulate_prefix()     insn_get_prefixes()     insn_get_opcode()     decode_branch_type()     get_branch_type()     intel_pmu_lbr_filter()     intel_pmu_handle_irq()     perf_event_nmi_handler()  Within __insn_get_emulate_prefix() at frame 0, a macro is called:      peek_nbyte_next(insn_byte_t, insn, i)  Within this macro, this dereference occurs:      (insn)-\u003enext_byte  Inspecting registers at this point, the value of the next_byte field is the address of the vsyscall made, for example the location of the vsyscall version of gettimeofday() at 0xffffffffff600000. The access to an address in the vsyscall region will trigger an oops due to an unhandled page fault.  To fix the bug, filtering for vsyscalls can be done when determining the branch type. This patch will return a \"none\" branch if a kernel address if found to lie in the vsyscall region.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52476",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "util-linux",
            "featureversion": "2.36.1-8+deb11u1",
            "vulnerability": "CVE-2024-28085",
            "namespace": "debian:11",
            "description": "wall in util-linux through 2.40, often installed with setgid tty permissions, allows escape sequences to be sent to other users' terminals through argv. (Specifically, escape sequences received from stdin are blocked, but escape sequences received from argv are not blocked.) There may be plausible scenarios where this leads to account takeover.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-28085",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26640",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  tcp: add sanity checks to rx zerocopy  TCP rx zerocopy intent is to map pages initially allocated from NIC drivers, not pages owned by a fs.  This patch adds to can_map_frag() these additional checks:  - Page must not be a compound one. - page-\u003emapping must be NULL.  This fixes the panic reported by ZhangPeng.  syzbot was able to loopback packets built with sendfile(), mapping pages owned by an ext4 file to TCP rx zerocopy.  r3 = socket$inet_tcp(0x2, 0x1, 0x0) mmap(\u0026(0x7f0000ff9000/0x4000)=nil, 0x4000, 0x0, 0x12, r3, 0x0) r4 = socket$inet_tcp(0x2, 0x1, 0x0) bind$inet(r4, \u0026(0x7f0000000000)={0x2, 0x4e24, @multicast1}, 0x10) connect$inet(r4, \u0026(0x7f00000006c0)={0x2, 0x4e24, @empty}, 0x10) r5 = openat$dir(0xffffffffffffff9c, \u0026(0x7f00000000c0)='./file0\\x00',     0x181e42, 0x0) fallocate(r5, 0x0, 0x0, 0x85b8) sendfile(r4, r5, 0x0, 0x8ba0) getsockopt$inet_tcp_TCP_ZEROCOPY_RECEIVE(r4, 0x6, 0x23,     \u0026(0x7f00000001c0)={\u0026(0x7f0000ffb000/0x3000)=nil, 0x3000, 0x0, 0x0, 0x0,     0x0, 0x0, 0x0, 0x0}, \u0026(0x7f0000000440)=0x40) r6 = openat$dir(0xffffffffffffff9c, \u0026(0x7f00000000c0)='./file0\\x00',     0x181e42, 0x0)",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26640",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26622",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  tomoyo: fix UAF write bug in tomoyo_write_control()  Since tomoyo_write_control() updates head-\u003ewrite_buf when write() of long lines is requested, we need to fetch head-\u003ewrite_buf after head-\u003eio_sem is held.  Otherwise, concurrent write() requests can cause use-after-free-write and double-free problems.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26622",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26636",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  llc: make llc_ui_sendmsg() more robust against bonding changes  syzbot was able to trick llc_ui_sendmsg(), allocating an skb with no headroom, but subsequently trying to push 14 bytes of Ethernet header [1]  Like some others, llc_ui_sendmsg() releases the socket lock before calling sock_alloc_send_skb(). Then it acquires it again, but does not redo all the sanity checks that were performed.  This fix:  - Uses LL_RESERVED_SPACE() to reserve space. - Check all conditions again after socket lock is held again. - Do not account Ethernet header for mtu limitation.  [1]  skbuff: skb_under_panic: text:ffff800088baa334 len:1514 put:14 head:ffff0000c9c37000 data:ffff0000c9c36ff2 tail:0x5dc end:0x6c0 dev:bond0   kernel BUG at net/core/skbuff.c:193 ! Internal error: Oops - BUG: 00000000f2000800 [#1] PREEMPT SMP Modules linked in: CPU: 0 PID: 6875 Comm: syz-executor.0 Not tainted 6.7.0-rc8-syzkaller-00101-g0802e17d9aca-dirty #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 11/17/2023 pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)  pc : skb_panic net/core/skbuff.c:189 [inline]  pc : skb_under_panic+0x13c/0x140 net/core/skbuff.c:203  lr : skb_panic net/core/skbuff.c:189 [inline]  lr : skb_under_panic+0x13c/0x140 net/core/skbuff.c:203 sp : ffff800096f97000 x29: ffff800096f97010 x28: ffff80008cc8d668 x27: dfff800000000000 x26: ffff0000cb970c90 x25: 00000000000005dc x24: ffff0000c9c36ff2 x23: ffff0000c9c37000 x22: 00000000000005ea x21: 00000000000006c0 x20: 000000000000000e x19: ffff800088baa334 x18: 1fffe000368261ce x17: ffff80008e4ed000 x16: ffff80008a8310f8 x15: 0000000000000001 x14: 1ffff00012df2d58 x13: 0000000000000000 x12: 0000000000000000 x11: 0000000000000001 x10: 0000000000ff0100 x9 : e28a51f1087e8400 x8 : e28a51f1087e8400 x7 : ffff80008028f8d0 x6 : 0000000000000000 x5 : 0000000000000001 x4 : 0000000000000001 x3 : ffff800082b78714 x2 : 0000000000000001 x1 : 0000000100000000 x0 : 0000000000000089 Call trace:   skb_panic net/core/skbuff.c:189 [inline]   skb_under_panic+0x13c/0x140 net/core/skbuff.c:203   skb_push+0xf0/0x108 net/core/skbuff.c:2451   eth_header+0x44/0x1f8 net/ethernet/eth.c:83   dev_hard_header include/linux/netdevice.h:3188 [inline]   llc_mac_hdr_init+0x110/0x17c net/llc/llc_output.c:33   llc_sap_action_send_xid_c+0x170/0x344 net/llc/llc_s_ac.c:85   llc_exec_sap_trans_actions net/llc/llc_sap.c:153 [inline]   llc_sap_next_state net/llc/llc_sap.c:182 [inline]   llc_sap_state_process+0x1ec/0x774 net/llc/llc_sap.c:209   llc_build_and_send_xid_pkt+0x12c/0x1c0 net/llc/llc_sap.c:270   llc_ui_sendmsg+0x7bc/0xb1c net/llc/af_llc.c:997   sock_sendmsg_nosec net/socket.c:730 [inline]   __sock_sendmsg net/socket.c:745 [inline]   sock_sendmsg+0x194/0x274 net/socket.c:767   splice_to_socket+0x7cc/0xd58 fs/splice.c:881   do_splice_from fs/splice.c:933 [inline]   direct_splice_actor+0xe4/0x1c0 fs/splice.c:1142   splice_direct_to_actor+0x2a0/0x7e4 fs/splice.c:1088   do_splice_direct+0x20c/0x348 fs/splice.c:1194   do_sendfile+0x4bc/0xc70 fs/read_write.c:1254   __do_sys_sendfile64 fs/read_write.c:1322 [inline]   __se_sys_sendfile64 fs/read_write.c:1308 [inline]   __arm64_sys_sendfile64+0x160/0x3b4 fs/read_write.c:1308   __invoke_syscall arch/arm64/kernel/syscall.c:37 [inline]   invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:51   el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:136   do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:155   el0_svc+0x54/0x158 arch/arm64/kernel/entry-common.c:678   el0t_64_sync_handler+0x84/0xfc arch/arm64/kernel/entry-common.c:696   el0t_64_sync+0x190/0x194 arch/arm64/kernel/entry.S:595 Code: aa1803e6 aa1903e7 a90023f5 94792f6a (d4210000)",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26636",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-6535",
            "namespace": "debian:11",
            "description": "A flaw was found in the Linux kernel's NVMe driver. This issue may allow an unauthenticated malicious actor to send a set of crafted TCP packages when using NVMe over TCP, leading the NVMe driver to a NULL pointer dereference in the NVMe driver, causing kernel panic and a denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-6535",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "glibc",
            "featureversion": "2.31-13+deb11u8",
            "vulnerability": "CVE-2023-4813",
            "namespace": "debian:11",
            "description": "A flaw was found in glibc. In an uncommon situation, the gaih_inet function may use memory that has been freed, resulting in an application crash. This issue is only exploitable when the getaddrinfo function is called and the hosts database in /etc/nsswitch.conf is configured with SUCCESS=continue or SUCCESS=merge.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4813",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52491",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  media: mtk-jpeg: Fix use after free bug due to error path handling in mtk_jpeg_dec_device_run  In mtk_jpeg_probe, \u0026jpeg-\u003ejob_timeout_work is bound with mtk_jpeg_job_timeout_work.  In mtk_jpeg_dec_device_run, if error happens in mtk_jpeg_set_dec_dst, it will finally start the worker while mark the job as finished by invoking v4l2_m2m_job_finish.  There are two methods to trigger the bug. If we remove the module, it which will call mtk_jpeg_remove to make cleanup. The possible sequence is as follows, which will cause a use-after-free bug.  CPU0                  CPU1 mtk_jpeg_dec_...    |   start worker\t    |                     |mtk_jpeg_job_timeout_work mtk_jpeg_remove     |   v4l2_m2m_release  |     kfree(m2m_dev); |                     |                     | v4l2_m2m_get_curr_priv                     |   m2m_dev-\u003ecurr_ctx //use  If we close the file descriptor, which will call mtk_jpeg_release, it will have a similar sequence.  Fix this bug by starting timeout worker only if started jpegdec worker successfully. Then v4l2_m2m_job_finish will only be called in either mtk_jpeg_job_timeout_work or mtk_jpeg_dec_device_run.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52491",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52600",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  jfs: fix uaf in jfs_evict_inode  When the execution of diMount(ipimap) fails, the object ipimap that has been released may be accessed in diFreeSpecial(). Asynchronous ipimap release occurs when rcu_core() calls jfs_free_node().  Therefore, when diMount(ipimap) fails, sbi-\u003eipimap should not be initialized as ipimap.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52600",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52614",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  PM / devfreq: Fix buffer overflow in trans_stat_show  Fix buffer overflow in trans_stat_show().  Convert simple snprintf to the more secure scnprintf with size of PAGE_SIZE.  Add condition checking if we are exceeding PAGE_SIZE and exit early from loop. Also add at the end a warning that we exceeded PAGE_SIZE and that stats is disabled.  Return -EFBIG in the case where we don't have enough space to write the full transition table.  Also document in the ABI that this function can return -EFBIG error.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52614",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52572",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  cifs: Fix UAF in cifs_demultiplex_thread()  There is a UAF when xfstests on cifs:    BUG: KASAN: use-after-free in smb2_is_network_name_deleted+0x27/0x160   Read of size 4 at addr ffff88810103fc08 by task cifsd/923    CPU: 1 PID: 923 Comm: cifsd Not tainted 6.1.0-rc4+ #45   ...   Call Trace:    \u003cTASK\u003e    dump_stack_lvl+0x34/0x44    print_report+0x171/0x472    kasan_report+0xad/0x130    kasan_check_range+0x145/0x1a0    smb2_is_network_name_deleted+0x27/0x160    cifs_demultiplex_thread.cold+0x172/0x5a4    kthread+0x165/0x1a0    ret_from_fork+0x1f/0x30    \u003c/TASK\u003e    Allocated by task 923:    kasan_save_stack+0x1e/0x40    kasan_set_track+0x21/0x30    __kasan_slab_alloc+0x54/0x60    kmem_cache_alloc+0x147/0x320    mempool_alloc+0xe1/0x260    cifs_small_buf_get+0x24/0x60    allocate_buffers+0xa1/0x1c0    cifs_demultiplex_thread+0x199/0x10d0    kthread+0x165/0x1a0    ret_from_fork+0x1f/0x30    Freed by task 921:    kasan_save_stack+0x1e/0x40    kasan_set_track+0x21/0x30    kasan_save_free_info+0x2a/0x40    ____kasan_slab_free+0x143/0x1b0    kmem_cache_free+0xe3/0x4d0    cifs_small_buf_release+0x29/0x90    SMB2_negotiate+0x8b7/0x1c60    smb2_negotiate+0x51/0x70    cifs_negotiate_protocol+0xf0/0x160    cifs_get_smb_ses+0x5fa/0x13c0    mount_get_conns+0x7a/0x750    cifs_mount+0x103/0xd00    cifs_smb3_do_mount+0x1dd/0xcb0    smb3_get_tree+0x1d5/0x300    vfs_get_tree+0x41/0xf0    path_mount+0x9b3/0xdd0    __x64_sys_mount+0x190/0x1d0    do_syscall_64+0x35/0x80    entry_SYSCALL_64_after_hwframe+0x46/0xb0  The UAF is because:   mount(pid: 921)               | cifsd(pid: 923) -------------------------------|-------------------------------                                | cifs_demultiplex_thread SMB2_negotiate                 |  cifs_send_recv                |   compound_send_recv           |    smb_send_rqst               |     wait_for_response          |      wait_event_state      [1] |                                |  standard_receive3                                |   cifs_handle_standard                                |    handle_mid                                |     mid-\u003eresp_buf = buf;  [2]                                |     dequeue_mid           [3]      KILL the process      [4] |     resp_iov[i].iov_base = buf |  free_rsp_buf              [5] |                                |   is_network_name_deleted [6]                                |   callback  1. After send request to server, wait the response until     mid-\u003emid_state != SUBMITTED; 2. Receive response from server, and set it to mid; 3. Set the mid state to RECEIVED; 4. Kill the process, the mid state already RECEIVED, get 0; 5. Handle and release the negotiate response; 6. UAF.  It can be easily reproduce with add some delay in [3] - [6].  Only sync call has the problem since async call's callback is executed in cifsd process.  Add an extra state to mark the mid state to READY before wakeup the waitter, then it can get the resp safely.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52572",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52590",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  ocfs2: Avoid touching renamed directory if parent does not change  The VFS will not be locking moved directory if its parent does not change. Change ocfs2 rename code to avoid touching renamed directory if its parent does not change as without locking that can corrupt the filesystem.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52590",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "glibc",
            "featureversion": "2.31-13+deb11u8",
            "vulnerability": "CVE-2023-4806",
            "namespace": "debian:11",
            "description": "A flaw was found in glibc. In an extremely rare situation, the getaddrinfo function may access memory that has been freed, resulting in an application crash. This issue is only exploitable when a NSS module implements only the _nss_*_gethostbyname2_r and _nss_*_getcanonname_r hooks without implementing the _nss_*_gethostbyname3_r hook. The resolved name should return a large number of IPv6 and IPv4, and the call to the getaddrinfo function should have the AF_INET6 address family with AI_CANONNAME, AI_ALL and AI_V4MAPPED as flags.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4806",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-0565",
            "namespace": "debian:11",
            "description": "An out-of-bounds memory read flaw was found in receive_encrypted_standard in fs/smb/client/smb2ops.c in the SMB Client sub-component in the Linux Kernel. This issue occurs due to integer underflow on the memcpy length, leading to a denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-0565",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52482",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  x86/srso: Add SRSO mitigation for Hygon processors  Add mitigation for the speculative return stack overflow vulnerability which exists on Hygon processors too.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52482",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "perl",
            "featureversion": "5.32.1-4+deb11u3",
            "vulnerability": "CVE-2023-31484",
            "namespace": "debian:11",
            "description": "CPAN.pm before 2.35 does not verify TLS certificates when downloading distributions over HTTPS.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-31484",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-6270",
            "namespace": "debian:11",
            "description": "A flaw was found in the ATA over Ethernet (AoE) driver in the Linux kernel. The aoecmd_cfg_pkts() function improperly updates the refcnt on `struct net_device`, and a use-after-free can be triggered by racing between the free on the struct and the access through the `skbtxq` global queue. This could lead to a denial of service condition or potential code execution.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-6270",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52591",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  reiserfs: Avoid touching renamed directory if parent does not change  The VFS will not be locking moved directory if its parent does not change. Change reiserfs rename code to avoid touching renamed directory if its parent does not change as without locking that can corrupt the filesystem.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52591",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "sudo",
            "featureversion": "1.9.5p2-3+deb11u1",
            "vulnerability": "CVE-2023-28486",
            "namespace": "debian:11",
            "description": "Sudo before 1.9.13 does not escape control characters in log messages.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-28486",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-22386",
            "namespace": "debian:11",
            "description": "A race condition was found in the Linux kernel's drm/exynos device driver in exynos_drm_crtc_atomic_disable() function. This can result in a null pointer dereference issue, possibly leading to a kernel panic or denial of service issue.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-22386",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "sudo",
            "featureversion": "1.9.5p2-3+deb11u1",
            "vulnerability": "CVE-2023-28487",
            "namespace": "debian:11",
            "description": "Sudo before 1.9.13 does not escape control characters in sudoreplay output.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-28487",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "sudo",
            "featureversion": "1.9.5p2-3+deb11u1",
            "vulnerability": "CVE-2023-42465",
            "namespace": "debian:11",
            "description": "Sudo before 1.9.15 might allow row hammer attacks (for authentication bypass or privilege escalation) because application logic sometimes is based on not equaling an error value (instead of equaling a success value), and because the values do not resist flips of a single bit.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-42465",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52517",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  spi: sun6i: fix race between DMA RX transfer completion and RX FIFO drain  Previously the transfer complete IRQ immediately drained to RX FIFO to read any data remaining in FIFO to the RX buffer. This behaviour is correct when dealing with SPI in interrupt mode. However in DMA mode the transfer complete interrupt still fires as soon as all bytes to be transferred have been stored in the FIFO. At that point data in the FIFO still needs to be picked up by the DMA engine. Thus the drain procedure and DMA engine end up racing to read from RX FIFO, corrupting any data read. Additionally the RX buffer pointer is never adjusted according to DMA progress in DMA mode, thus calling the RX FIFO drain procedure in DMA mode is a bug. Fix corruptions in DMA RX mode by draining RX FIFO only in interrupt mode. Also wait for completion of RX DMA when in DMA mode before returning to ensure all data has been copied to the supplied memory buffer.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52517",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "tiff",
            "featureversion": "4.2.0-1+deb11u5",
            "vulnerability": "CVE-2023-3316",
            "namespace": "debian:11",
            "description": "A NULL pointer dereference in TIFFClose() is caused by a failure to open an output file (non-existent path or a path that requires permissions like /dev/null) while specifying zones.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3316",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26600",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  phy: ti: phy-omap-usb2: Fix NULL pointer dereference for SRP  If the external phy working together with phy-omap-usb2 does not implement send_srp(), we may still attempt to call it. This can happen on an idle Ethernet gadget triggering a wakeup for example:  configfs-gadget.g1 gadget.0: ECM Suspend configfs-gadget.g1 gadget.0: Port suspended. Triggering wakeup ... Unable to handle kernel NULL pointer dereference at virtual address 00000000 when execute ... PC is at 0x0 LR is at musb_gadget_wakeup+0x1d4/0x254 [musb_hdrc] ... musb_gadget_wakeup [musb_hdrc] from usb_gadget_wakeup+0x1c/0x3c [udc_core] usb_gadget_wakeup [udc_core] from eth_start_xmit+0x3b0/0x3d4 [u_ether] eth_start_xmit [u_ether] from dev_hard_start_xmit+0x94/0x24c dev_hard_start_xmit from sch_direct_xmit+0x104/0x2e4 sch_direct_xmit from __dev_queue_xmit+0x334/0xd88 __dev_queue_xmit from arp_solicit+0xf0/0x268 arp_solicit from neigh_probe+0x54/0x7c neigh_probe from __neigh_event_send+0x22c/0x47c __neigh_event_send from neigh_resolve_output+0x14c/0x1c0 neigh_resolve_output from ip_finish_output2+0x1c8/0x628 ip_finish_output2 from ip_send_skb+0x40/0xd8 ip_send_skb from udp_send_skb+0x124/0x340 udp_send_skb from udp_sendmsg+0x780/0x984 udp_sendmsg from __sys_sendto+0xd8/0x158 __sys_sendto from ret_fast_syscall+0x0/0x58  Let's fix the issue by checking for send_srp() and set_vbus() before calling them. For USB peripheral only cases these both could be NULL.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26600",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "tiff",
            "featureversion": "4.2.0-1+deb11u5",
            "vulnerability": "CVE-2023-26966",
            "namespace": "debian:11",
            "description": "libtiff 4.5.0 is vulnerable to Buffer Overflow in uv_encode() when libtiff reads a corrupted little-endian TIFF file and specifies the output to be big-endian.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-26966",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "tiff",
            "featureversion": "4.2.0-1+deb11u5",
            "vulnerability": "CVE-2023-26965",
            "namespace": "debian:11",
            "description": "loadImage() in tools/tiffcrop.c in LibTIFF through 4.5.0 has a heap-based use after free via a crafted TIFF image.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-26965",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52498",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  PM: sleep: Fix possible deadlocks in core system-wide PM code  It is reported that in low-memory situations the system-wide resume core code deadlocks, because async_schedule_dev() executes its argument function synchronously if it cannot allocate memory (and not only in that case) and that function attempts to acquire a mutex that is already held.  Executing the argument function synchronously from within dpm_async_fn() may also be problematic for ordering reasons (it may cause a consumer device's resume callback to be invoked before a requisite supplier device's one, for example).  Address this by changing the code in question to use async_schedule_dev_nocall() for scheduling the asynchronous execution of device suspend and resume functions and to directly run them synchronously if async_schedule_dev_nocall() returns false.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52498",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "tiff",
            "featureversion": "4.2.0-1+deb11u5",
            "vulnerability": "CVE-2023-2908",
            "namespace": "debian:11",
            "description": "A null pointer dereference issue was found in Libtiff's tif_dir.c file. This issue may allow an attacker to pass a crafted TIFF image file to the tiffcp utility which triggers a runtime error that causes undefined behavior. This will result in an application crash, eventually leading to a denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-2908",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52594",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: ath9k: Fix potential array-index-out-of-bounds read in ath9k_htc_txstatus()  Fix an array-index-out-of-bounds read in ath9k_htc_txstatus(). The bug occurs when txs-\u003ecnt, data from a URB provided by a USB device, is bigger than the size of the array txs-\u003etxstatus, which is HTC_MAX_TX_STATUS. WARN_ON() already checks it, but there is no bug handling code after the check. Make the function return if that is the case.  Found by a modified version of syzkaller.  UBSAN: array-index-out-of-bounds in htc_drv_txrx.c index 13 is out of range for type '__wmi_event_txstatus [12]' Call Trace:  ath9k_htc_txstatus  ath9k_wmi_event_tasklet  tasklet_action_common  __do_softirq  irq_exit_rxu  sysvec_apic_timer_interrupt",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52594",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52484",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  iommu/arm-smmu-v3: Fix soft lockup triggered by arm_smmu_mm_invalidate_range  When running an SVA case, the following soft lockup is triggered: -------------------------------------------------------------------- watchdog: BUG: soft lockup - CPU#244 stuck for 26s! pstate: 83400009 (Nzcv daif +PAN -UAO +TCO +DIT -SSBS BTYPE=--) pc : arm_smmu_cmdq_issue_cmdlist+0x178/0xa50 lr : arm_smmu_cmdq_issue_cmdlist+0x150/0xa50 sp : ffff8000d83ef290 x29: ffff8000d83ef290 x28: 000000003b9aca00 x27: 0000000000000000 x26: ffff8000d83ef3c0 x25: da86c0812194a0e8 x24: 0000000000000000 x23: 0000000000000040 x22: ffff8000d83ef340 x21: ffff0000c63980c0 x20: 0000000000000001 x19: ffff0000c6398080 x18: 0000000000000000 x17: 0000000000000000 x16: 0000000000000000 x15: ffff3000b4a3bbb0 x14: ffff3000b4a30888 x13: ffff3000b4a3cf60 x12: 0000000000000000 x11: 0000000000000000 x10: 0000000000000000 x9 : ffffc08120e4d6bc x8 : 0000000000000000 x7 : 0000000000000000 x6 : 0000000000048cfa x5 : 0000000000000000 x4 : 0000000000000001 x3 : 000000000000000a x2 : 0000000080000000 x1 : 0000000000000000 x0 : 0000000000000001 Call trace:  arm_smmu_cmdq_issue_cmdlist+0x178/0xa50  __arm_smmu_tlb_inv_range+0x118/0x254  arm_smmu_tlb_inv_range_asid+0x6c/0x130  arm_smmu_mm_invalidate_range+0xa0/0xa4  __mmu_notifier_invalidate_range_end+0x88/0x120  unmap_vmas+0x194/0x1e0  unmap_region+0xb4/0x144  do_mas_align_munmap+0x290/0x490  do_mas_munmap+0xbc/0x124  __vm_munmap+0xa8/0x19c  __arm64_sys_munmap+0x28/0x50  invoke_syscall+0x78/0x11c  el0_svc_common.constprop.0+0x58/0x1c0  do_el0_svc+0x34/0x60  el0_svc+0x2c/0xd4  el0t_64_sync_handler+0x114/0x140  el0t_64_sync+0x1a4/0x1a8 --------------------------------------------------------------------  Note that since 6.6-rc1 the arm_smmu_mm_invalidate_range above is renamed to \"arm_smmu_mm_arch_invalidate_secondary_tlbs\", yet the problem remains.  The commit 06ff87bae8d3 (\"arm64: mm: remove unused functions and variable protoypes\") fixed a similar lockup on the CPU MMU side. Yet, it can occur to SMMU too, since arm_smmu_mm_arch_invalidate_secondary_tlbs() is called typically next to MMU tlb flush function, e.g. \ttlb_flush_mmu_tlbonly { \t\ttlb_flush { \t\t\t__flush_tlb_range { \t\t\t\t// check MAX_TLBI_OPS \t\t\t} \t\t} \t\tmmu_notifier_arch_invalidate_secondary_tlbs { \t\t\tarm_smmu_mm_arch_invalidate_secondary_tlbs { \t\t\t\t// does not check MAX_TLBI_OPS \t\t\t} \t\t} \t}  Clone a CMDQ_MAX_TLBI_OPS from the MAX_TLBI_OPS in tlbflush.h, since in an SVA case SMMU uses the CPU page table, so it makes sense to align with the tlbflush code. Then, replace per-page TLBI commands with a single per-asid TLBI command, if the request size hits this threshold.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52484",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "tiff",
            "featureversion": "4.2.0-1+deb11u5",
            "vulnerability": "CVE-2023-52355",
            "namespace": "debian:11",
            "description": "An out-of-memory flaw was found in libtiff that could be triggered by passing a crafted tiff file to the TIFFRasterScanlineSize64() API. This flaw allows a remote attacker to cause a denial of service via a crafted input with a size smaller than 379 KB.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52355",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "tiff",
            "featureversion": "4.2.0-1+deb11u5",
            "vulnerability": "CVE-2022-40090",
            "namespace": "debian:11",
            "description": "An issue was discovered in function TIFFReadDirectory libtiff before 4.4.0 allows attackers to cause a denial of service via crafted TIFF file.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-40090",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "tiff",
            "featureversion": "4.2.0-1+deb11u5",
            "vulnerability": "CVE-2023-6277",
            "namespace": "debian:11",
            "description": "An out-of-memory flaw was found in libtiff. Passing a crafted tiff file to TIFFOpen() API may allow a remote attacker to cause a denial of service via a craft input with size smaller than 379 KB.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-6277",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26641",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  ip6_tunnel: make sure to pull inner header in __ip6_tnl_rcv()  syzbot found __ip6_tnl_rcv() could access unitiliazed data [1].  Call pskb_inet_may_pull() to fix this, and initialize ipv6h variable after this call as it can change skb-\u003ehead.  [1]  BUG: KMSAN: uninit-value in __INET_ECN_decapsulate include/net/inet_ecn.h:253 [inline]  BUG: KMSAN: uninit-value in INET_ECN_decapsulate include/net/inet_ecn.h:275 [inline]  BUG: KMSAN: uninit-value in IP6_ECN_decapsulate+0x7df/0x1e50 include/net/inet_ecn.h:321   __INET_ECN_decapsulate include/net/inet_ecn.h:253 [inline]   INET_ECN_decapsulate include/net/inet_ecn.h:275 [inline]   IP6_ECN_decapsulate+0x7df/0x1e50 include/net/inet_ecn.h:321   ip6ip6_dscp_ecn_decapsulate+0x178/0x1b0 net/ipv6/ip6_tunnel.c:727   __ip6_tnl_rcv+0xd4e/0x1590 net/ipv6/ip6_tunnel.c:845   ip6_tnl_rcv+0xce/0x100 net/ipv6/ip6_tunnel.c:888  gre_rcv+0x143f/0x1870   ip6_protocol_deliver_rcu+0xda6/0x2a60 net/ipv6/ip6_input.c:438   ip6_input_finish net/ipv6/ip6_input.c:483 [inline]   NF_HOOK include/linux/netfilter.h:314 [inline]   ip6_input+0x15d/0x430 net/ipv6/ip6_input.c:492   ip6_mc_input+0xa7e/0xc80 net/ipv6/ip6_input.c:586   dst_input include/net/dst.h:461 [inline]   ip6_rcv_finish+0x5db/0x870 net/ipv6/ip6_input.c:79   NF_HOOK include/linux/netfilter.h:314 [inline]   ipv6_rcv+0xda/0x390 net/ipv6/ip6_input.c:310   __netif_receive_skb_one_core net/core/dev.c:5532 [inline]   __netif_receive_skb+0x1a6/0x5a0 net/core/dev.c:5646   netif_receive_skb_internal net/core/dev.c:5732 [inline]   netif_receive_skb+0x58/0x660 net/core/dev.c:5791   tun_rx_batched+0x3ee/0x980 drivers/net/tun.c:1555   tun_get_user+0x53af/0x66d0 drivers/net/tun.c:2002   tun_chr_write_iter+0x3af/0x5d0 drivers/net/tun.c:2048   call_write_iter include/linux/fs.h:2084 [inline]   new_sync_write fs/read_write.c:497 [inline]   vfs_write+0x786/0x1200 fs/read_write.c:590   ksys_write+0x20f/0x4c0 fs/read_write.c:643   __do_sys_write fs/read_write.c:655 [inline]   __se_sys_write fs/read_write.c:652 [inline]   __x64_sys_write+0x93/0xd0 fs/read_write.c:652   do_syscall_x64 arch/x86/entry/common.c:52 [inline]   do_syscall_64+0x6d/0x140 arch/x86/entry/common.c:83  entry_SYSCALL_64_after_hwframe+0x63/0x6b  Uninit was created at:   slab_post_alloc_hook+0x129/0xa70 mm/slab.h:768   slab_alloc_node mm/slub.c:3478 [inline]   kmem_cache_alloc_node+0x5e9/0xb10 mm/slub.c:3523   kmalloc_reserve+0x13d/0x4a0 net/core/skbuff.c:560   __alloc_skb+0x318/0x740 net/core/skbuff.c:651   alloc_skb include/linux/skbuff.h:1286 [inline]   alloc_skb_with_frags+0xc8/0xbd0 net/core/skbuff.c:6334   sock_alloc_send_pskb+0xa80/0xbf0 net/core/sock.c:2787   tun_alloc_skb drivers/net/tun.c:1531 [inline]   tun_get_user+0x1e8a/0x66d0 drivers/net/tun.c:1846   tun_chr_write_iter+0x3af/0x5d0 drivers/net/tun.c:2048   call_write_iter include/linux/fs.h:2084 [inline]   new_sync_write fs/read_write.c:497 [inline]   vfs_write+0x786/0x1200 fs/read_write.c:590   ksys_write+0x20f/0x4c0 fs/read_write.c:643   __do_sys_write fs/read_write.c:655 [inline]   __se_sys_write fs/read_write.c:652 [inline]   __x64_sys_write+0x93/0xd0 fs/read_write.c:652   do_syscall_x64 arch/x86/entry/common.c:52 [inline]   do_syscall_64+0x6d/0x140 arch/x86/entry/common.c:83  entry_SYSCALL_64_after_hwframe+0x63/0x6b  CPU: 0 PID: 5034 Comm: syz-executor331 Not tainted 6.7.0-syzkaller-00562-g9f8413c4a66f #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 11/17/2023",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26641",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2022-3108",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 5.16-rc6. kfd_parse_subtype_iolink in drivers/gpu/drm/amd/amdkfd/kfd_crat.c lacks check of the return value of kmemdup().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-3108",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "tiff",
            "featureversion": "4.2.0-1+deb11u5",
            "vulnerability": "CVE-2023-52356",
            "namespace": "debian:11",
            "description": "A segment fault (SEGV) flaw was found in libtiff that could be triggered by passing a crafted tiff file to the TIFFReadRGBATileExt() API. This flaw allows a remote attacker to cause a heap-buffer overflow, leading to a denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52356",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-24861",
            "namespace": "debian:11",
            "description": "A race condition was found in the Linux kernel's media/xc4000 device driver in xc4000 xc4000_get_frequency() function. This can result in return value overflow issue, possibly leading to malfunction or denial of service issue.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-24861",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-4010",
            "namespace": "debian:11",
            "description": "A flaw was found in the USB Host Controller Driver framework in the Linux kernel. The usb_giveback_urb function has a logic loophole in its implementation. Due to the inappropriate judgment condition of the goto statement, the function cannot return under the input of a specific malformed descriptor file, so it falls into an endless loop, resulting in a denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4010",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "tiff",
            "featureversion": "4.2.0-1+deb11u5",
            "vulnerability": "CVE-2023-25433",
            "namespace": "debian:11",
            "description": "libtiff 4.5.0 is vulnerable to Buffer Overflow via /libtiff/tools/tiffcrop.c:8499. Incorrect updating of buffer size after rotateImage() in tiffcrop cause heap-buffer-overflow and SEGV.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-25433",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-0607",
            "namespace": "debian:11",
            "description": "A flaw was found in the Netfilter subsystem in the Linux kernel. The issue is in the nft_byteorder_eval() function, where the code iterates through a loop and writes to the `dst` array. On each iteration, 8 bytes are written, but `dst` is an array of u32, so each element only has space for 4 bytes. That means every iteration overwrites part of the previous element corrupting this array of u32. This flaw allows a local user to cause a denial of service or potentially break NetFilter functionality.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-0607",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-25741",
            "namespace": "debian:11",
            "description": "printer_write in drivers/usb/gadget/function/f_printer.c in the Linux kernel through 6.7.4 does not properly call usb_ep_queue, which might allow attackers to cause a denial of service or have unspecified other impact.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-25741",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52606",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  powerpc/lib: Validate size for vector operations  Some of the fp/vmx code in sstep.c assume a certain maximum size for the instructions being emulated. The size of those operations however is determined separately in analyse_instr().  Add a check to validate the assumption on the maximum size of the operations, so as to prevent any unintended kernel stack corruption.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52606",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "tiff",
            "featureversion": "4.2.0-1+deb11u5",
            "vulnerability": "CVE-2023-3618",
            "namespace": "debian:11",
            "description": "A flaw was found in libtiff. A specially crafted tiff file can lead to a segmentation fault due to a buffer overflow in the Fax3Encode function in libtiff/tif_fax3.c, resulting in a denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3618",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52595",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: rt2x00: restart beacon queue when hardware reset  When a hardware reset is triggered, all registers are reset, so all queues are forced to stop in hardware interface. However, mac80211 will not automatically stop the queue. If we don't manually stop the beacon queue, the queue will be deadlocked and unable to start again. This patch fixes the issue where Apple devices cannot connect to the AP after calling ieee80211_restart_hw().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52595",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "pam",
            "featureversion": "1.4.0-9+deb11u1",
            "vulnerability": "CVE-2024-22365",
            "namespace": "debian:11",
            "description": "linux-pam (aka Linux PAM) before 1.6.0 allows attackers to cause a denial of service (blocked login process) via mkfifo because the openat call (for protect_dir) lacks O_DIRECTORY.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-22365",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "libbpf",
            "featureversion": "0.3-2",
            "vulnerability": "CVE-2022-3534",
            "namespace": "debian:11",
            "description": "A vulnerability classified as critical has been found in Linux Kernel. Affected is the function btf_dump_name_dups of the file tools/lib/bpf/btf_dump.c of the component libbpf. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211032.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-3534",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-23851",
            "namespace": "debian:11",
            "description": "copy_params in drivers/md/dm-ioctl.c in the Linux kernel through 6.7.1 can attempt to allocate more than INT_MAX bytes, and crash, because of a missing param_kernel-\u003edata_size check. This is related to ctl_ioctl.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-23851",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-3397",
            "namespace": "debian:11",
            "description": "A race condition occurred between the functions lmLogClose and txEnd in JFS, in the Linux Kernel, executed in different threads. This flaw allows a local attacker with normal user privileges to crash the system or leak internal kernel information.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-3397",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "libbpf",
            "featureversion": "0.3-2",
            "vulnerability": "CVE-2022-3606",
            "namespace": "debian:11",
            "description": "A vulnerability was found in Linux Kernel. It has been classified as problematic. This affects the function find_prog_by_sec_insn of the file tools/lib/bpf/libbpf.c of the component BPF. The manipulation leads to null pointer dereference. It is recommended to apply a patch to fix this issue. The identifier VDB-211749 was assigned to this vulnerability.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-3606",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2021-3669",
            "namespace": "debian:11",
            "description": "A flaw was found in the Linux kernel. Measuring usage of the shared memory does not scale with large shared memory segment counts which could lead to resource exhaustion and DoS.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2021-3669",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "systemd",
            "featureversion": "247.3-7+deb11u4",
            "vulnerability": "CVE-2023-50387",
            "namespace": "debian:11",
            "description": "Certain DNSSEC aspects of the DNS protocol (in RFC 4033, 4034, 4035, 6840, and related RFCs) allow remote attackers to cause a denial of service (CPU consumption) via one or more DNSSEC responses, aka the \"KeyTrap\" issue. One of the concerns is that, when there is a zone with many DNSKEY and RRSIG records, the protocol specification implies that an algorithm must evaluate all combinations of DNSKEY and RRSIG records.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-50387",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-21803",
            "namespace": "debian:11",
            "description": "Use After Free vulnerability in Linux Linux kernel kernel on Linux, x86, ARM (bluetooth modules) allows Local Execution of Code. This vulnerability is associated with program files https://gitee.Com/anolis/cloud-kernel/blob/devel-5.10/net/bluetooth/af_bluetooth.C.  This issue affects Linux kernel: from v2.6.12-rc2 before v6.8-rc1.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-21803",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-24857",
            "namespace": "debian:11",
            "description": "A race condition was found in the Linux kernel's net/bluetooth device driver in conn_info_{min,max}_age_set() function. This can result in integrity overflow issue, possibly leading to bluetooth connection abnormality or denial of service.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-24857",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "systemd",
            "featureversion": "247.3-7+deb11u4",
            "vulnerability": "CVE-2023-7008",
            "namespace": "debian:11",
            "description": "A vulnerability was found in systemd-resolved. This issue may allow systemd-resolved to accept records of DNSSEC-signed domains even when they have no signature, allowing man-in-the-middles (or the upstream DNS resolver) to manipulate records.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-7008",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "systemd",
            "featureversion": "247.3-7+deb11u4",
            "vulnerability": "CVE-2023-50868",
            "namespace": "debian:11",
            "description": "The Closest Encloser Proof aspect of the DNS protocol (in RFC 5155 when RFC 9276 guidance is skipped) allows remote attackers to cause a denial of service (CPU consumption for SHA-1 computations) via DNSSEC responses in a random subdomain attack, aka the \"NSEC3\" issue. The RFC 5155 specification implies that an algorithm must perform thousands of iterations of a hash function in certain situations.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-50868",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52589",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  media: rkisp1: Fix IRQ disable race issue  In rkisp1_isp_stop() and rkisp1_csi_disable() the driver masks the interrupts and then apparently assumes that the interrupt handler won't be running, and proceeds in the stop procedure. This is not the case, as the interrupt handler can already be running, which would lead to the ISP being disabled while the interrupt handler handling a captured frame.  This brings up two issues: 1) the ISP could be powered off while the interrupt handler is still running and accessing registers, leading to board lockup, and 2) the interrupt handler code and the code that disables the streaming might do things that conflict.  It is not clear to me if 2) causes a real issue, but 1) can be seen with a suitable delay (or printk in my case) in the interrupt handler, leading to board lockup.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52589",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52479",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix uaf in smb20_oplock_break_ack  drop reference after use opinfo.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52479",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "ncurses",
            "featureversion": "6.2+20201114-2+deb11u2",
            "vulnerability": "CVE-2023-45918",
            "namespace": "debian:11",
            "description": "ncurses 6.4-20230610 has a NULL pointer dereference in tgetstr in tinfo/lib_termcap.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-45918",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "ncurses",
            "featureversion": "6.2+20201114-2+deb11u2",
            "vulnerability": "CVE-2023-50495",
            "namespace": "debian:11",
            "description": "NCurse v6.4-20230418 was discovered to contain a segmentation fault via the component _nc_wrap_entry().",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-50495",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "zlib",
            "featureversion": "1:1.2.11.dfsg-2+deb11u2",
            "vulnerability": "CVE-2023-45853",
            "namespace": "debian:11",
            "description": "MiniZip in zlib through 1.3 has an integer overflow and resultant heap-based buffer overflow in zipOpenNewFileInZip4_64 via a long filename, comment, or extra field. NOTE: MiniZip is not a supported part of the zlib product. NOTE: pyminizip through 0.2.6 is also vulnerable because it bundles an affected zlib version, and exposes the applicable MiniZip code through its compress API.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-45853",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2022-43945",
            "namespace": "debian:11",
            "description": "The Linux kernel NFSD implementation prior to versions 5.19.17 and 6.0.2 are vulnerable to buffer overflow. NFSD tracks the number of pages held by each NFSD thread by combining the receive and send buffers of a remote procedure call (RPC) into a single array of pages. A client can force the send buffer to shrink by sending an RPC message over TCP with garbage data added at the end of the message. The RPC message with garbage data is still correctly formed according to the specification and is passed forward to handlers. Vulnerable code in NFSD is not expecting the oversized request and writes beyond the allocated buffer space. CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-43945",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2022-3523",
            "namespace": "debian:11",
            "description": "A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is an unknown function of the file mm/memory.c of the component Driver Handler. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211020.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-3523",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26614",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  tcp: make sure init the accept_queue's spinlocks once  When I run syz's reproduction C program locally, it causes the following issue: pvqspinlock: lock 0xffff9d181cd5c660 has corrupted value 0x0! WARNING: CPU: 19 PID: 21160 at __pv_queued_spin_unlock_slowpath (kernel/locking/qspinlock_paravirt.h:508) Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011 RIP: 0010:__pv_queued_spin_unlock_slowpath (kernel/locking/qspinlock_paravirt.h:508) Code: 73 56 3a ff 90 c3 cc cc cc cc 8b 05 bb 1f 48 01 85 c0 74 05 c3 cc cc cc cc 8b 17 48 89 fe 48 c7 c7 30 20 ce 8f e8 ad 56 42 ff \u003c0f\u003e 0b c3 cc cc cc cc 0f 0b 0f 1f 40 00 90 90 90 90 90 90 90 90 90 RSP: 0018:ffffa8d200604cb8 EFLAGS: 00010282 RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffff9d1ef60e0908 RDX: 00000000ffffffd8 RSI: 0000000000000027 RDI: ffff9d1ef60e0900 RBP: ffff9d181cd5c280 R08: 0000000000000000 R09: 00000000ffff7fff R10: ffffa8d200604b68 R11: ffffffff907dcdc8 R12: 0000000000000000 R13: ffff9d181cd5c660 R14: ffff9d1813a3f330 R15: 0000000000001000 FS:  00007fa110184640(0000) GS:ffff9d1ef60c0000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000020000000 CR3: 000000011f65e000 CR4: 00000000000006f0 Call Trace: \u003cIRQ\u003e   _raw_spin_unlock (kernel/locking/spinlock.c:186)   inet_csk_reqsk_queue_add (net/ipv4/inet_connection_sock.c:1321)   inet_csk_complete_hashdance (net/ipv4/inet_connection_sock.c:1358)   tcp_check_req (net/ipv4/tcp_minisocks.c:868)   tcp_v4_rcv (net/ipv4/tcp_ipv4.c:2260)   ip_protocol_deliver_rcu (net/ipv4/ip_input.c:205)   ip_local_deliver_finish (net/ipv4/ip_input.c:234)   __netif_receive_skb_one_core (net/core/dev.c:5529)   process_backlog (./include/linux/rcupdate.h:779)   __napi_poll (net/core/dev.c:6533)   net_rx_action (net/core/dev.c:6604)   __do_softirq (./arch/x86/include/asm/jump_label.h:27)   do_softirq (kernel/softirq.c:454 kernel/softirq.c:441) \u003c/IRQ\u003e \u003cTASK\u003e   __local_bh_enable_ip (kernel/softirq.c:381)   __dev_queue_xmit (net/core/dev.c:4374)   ip_finish_output2 (./include/net/neighbour.h:540 net/ipv4/ip_output.c:235)   __ip_queue_xmit (net/ipv4/ip_output.c:535)   __tcp_transmit_skb (net/ipv4/tcp_output.c:1462)   tcp_rcv_synsent_state_process (net/ipv4/tcp_input.c:6469)   tcp_rcv_state_process (net/ipv4/tcp_input.c:6657)   tcp_v4_do_rcv (net/ipv4/tcp_ipv4.c:1929)   __release_sock (./include/net/sock.h:1121 net/core/sock.c:2968)   release_sock (net/core/sock.c:3536)   inet_wait_for_connect (net/ipv4/af_inet.c:609)   __inet_stream_connect (net/ipv4/af_inet.c:702)   inet_stream_connect (net/ipv4/af_inet.c:748)   __sys_connect (./include/linux/file.h:45 net/socket.c:2064)   __x64_sys_connect (net/socket.c:2073 net/socket.c:2070 net/socket.c:2070)   do_syscall_64 (arch/x86/entry/common.c:51 arch/x86/entry/common.c:82)   entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:129)   RIP: 0033:0x7fa10ff05a3d   Code: 5b 41 5c c3 66 0f 1f 84 00 00 00 00 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89   c2 4d 89 c8 4c 8b 4c 24 08 0f 05 \u003c48\u003e 3d 01 f0 ff ff 73 01 c3 48 8b 0d ab a3 0e 00 f7 d8 64 89 01 48   RSP: 002b:00007fa110183de8 EFLAGS: 00000202 ORIG_RAX: 000000000000002a   RAX: ffffffffffffffda RBX: 0000000020000054 RCX: 00007fa10ff05a3d   RDX: 000000000000001c RSI: 0000000020000040 RDI: 0000000000000003   RBP: 00007fa110183e20 R08: 0000000000000000 R09: 0000000000000000   R10: 0000000000000000 R11: 0000000000000202 R12: 00007fa110184640   R13: 0000000000000000 R14: 00007fa10fe8b060 R15: 00007fff73e23b20 \u003c/TASK\u003e  The issue triggering process is analyzed as follows: Thread A                                       Thread B tcp_v4_rcv\t//receive ack TCP packet       inet_shutdown   tcp_check_req                                  tcp_disconnect //disconnect sock   ...                                              tcp_set_state(sk, TCP_CLOSE)     inet_csk_complete_hashdance                ...       inet_csk_reqsk_queue_add          ---truncated---",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26614",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52587",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  IB/ipoib: Fix mcast list locking  Releasing the `priv-\u003elock` while iterating the `priv-\u003emulticast_list` in `ipoib_mcast_join_task()` opens a window for `ipoib_mcast_dev_flush()` to remove the items while in the middle of iteration. If the mcast is removed while the lock was dropped, the for loop spins forever resulting in a hard lockup (as was reported on RHEL 4.18.0-372.75.1.el8_6 kernel):      Task A (kworker/u72:2 below)       | Task B (kworker/u72:0 below)     -----------------------------------+-----------------------------------     ipoib_mcast_join_task(work)        | ipoib_ib_dev_flush_light(work)       spin_lock_irq(\u0026priv-\u003elock)       | __ipoib_ib_dev_flush(priv, ...)       list_for_each_entry(mcast,       | ipoib_mcast_dev_flush(dev = priv-\u003edev)           \u0026priv-\u003emulticast_list, list) |         ipoib_mcast_join(dev, mcast)   |           spin_unlock_irq(\u0026priv-\u003elock) |                                        |   spin_lock_irqsave(\u0026priv-\u003elock, flags)                                        |   list_for_each_entry_safe(mcast, tmcast,                                        |                  \u0026priv-\u003emulticast_list, list)                                        |     list_del(\u0026mcast-\u003elist);                                        |     list_add_tail(\u0026mcast-\u003elist, \u0026remove_list)                                        |   spin_unlock_irqrestore(\u0026priv-\u003elock, flags)           spin_lock_irq(\u0026priv-\u003elock)   |                                        |   ipoib_mcast_remove_list(\u0026remove_list)    (Here, `mcast` is no longer on the  |     list_for_each_entry_safe(mcast, tmcast,     `priv-\u003emulticast_list` and we keep |                            remove_list, list)     spinning on the `remove_list` of   |  \u003e\u003e\u003e  wait_for_completion(\u0026mcast-\u003edone)     the other thread which is blocked  |     and the list is still valid on     |     it's stack.)  Fix this by keeping the lock held and changing to GFP_ATOMIC to prevent eventual sleeps. Unfortunately we could not reproduce the lockup and confirm this fix but based on the code review I think this fix should address such lockups.  crash\u003e bc 31 PID: 747      TASK: ff1c6a1a007e8000  CPU: 31   COMMAND: \"kworker/u72:2\" --     [exception RIP: ipoib_mcast_join_task+0x1b1]     RIP: ffffffffc0944ac1  RSP: ff646f199a8c7e00  RFLAGS: 00000002     RAX: 0000000000000000  RBX: ff1c6a1a04dc82f8  RCX: 0000000000000000                                   work (\u0026priv-\u003emcast_task{,.work})     RDX: ff1c6a192d60ac68  RSI: 0000000000000286  RDI: ff1c6a1a04dc8000            \u0026mcast-\u003elist     RBP: ff646f199a8c7e90   R8: ff1c699980019420   R9: ff1c6a1920c9a000     R10: ff646f199a8c7e00  R11: ff1c6a191a7d9800  R12: ff1c6a192d60ac00                                                          mcast     R13: ff1c6a1d82200000  R14: ff1c6a1a04dc8000  R15: ff1c6a1a04dc82d8            dev                    priv (\u0026priv-\u003elock)     \u0026priv-\u003emulticast_list (aka head)     ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018 --- \u003cNMI exception stack\u003e ---  #5 [ff646f199a8c7e00] ipoib_mcast_join_task+0x1b1 at ffffffffc0944ac1 [ib_ipoib]  #6 [ff646f199a8c7e98] process_one_work+0x1a7 at ffffffff9bf10967  crash\u003e rx ff646f199a8c7e68 ff646f199a8c7e68:  ff1c6a1a04dc82f8 \u003c\u003c\u003c work = \u0026priv-\u003emcast_task.work  crash\u003e list -hO ipoib_dev_priv.multicast_list ff1c6a1a04dc8000 (empty)  crash\u003e ipoib_dev_priv.mcast_task.work.func,mcast_mutex.owner.counter ff1c6a1a04dc8000   mcast_task.work.func = 0xffffffffc0944910 \u003cipoib_mcast_join_task\u003e,   mcast_mutex.owner.counter = 0xff1c69998efec000  crash\u003e b 8 PID: 8        TASK: ff1c69998efec000  CPU: 33   COMMAND: \"kworker/u72:0\" --  #3 [ff646f1980153d50] wait_for_completion+0x96 at ffffffff9c7d7646  #4 [ff646f1980153d90] ipoib_mcast_remove_list+0x56 at ffffffffc0944dc6 [ib_ipoib]  #5 [ff646f1980153de8] ipoib_mcast_dev_flush+0x1a7 at ffffffffc09455a7 [ib_ipoib]  #6 [ff646f1980153e58] __ipoib_ib_dev_flush+0x1a4 at ffffffffc09431a4 [ib_ipoib]  #7 [ff ---truncated---",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52587",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-0597",
            "namespace": "debian:11",
            "description": "A flaw possibility of memory leak in the Linux kernel cpu_entry_area mapping of X86 CPU data to memory was found in the way user can guess location of exception stack(s) or other important data. A local user could use this flaw to get access to some important data with expected location in memory.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-0597",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52597",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  KVM: s390: fix setting of fpc register  kvm_arch_vcpu_ioctl_set_fpu() allows to set the floating point control (fpc) register of a guest cpu. The new value is tested for validity by temporarily loading it into the fpc register.  This may lead to corruption of the fpc register of the host process: if an interrupt happens while the value is temporarily loaded into the fpc register, and within interrupt context floating point or vector registers are used, the current fp/vx registers are saved with save_fpu_regs() assuming they belong to user space and will be loaded into fp/vx registers when returning to user space.  test_fp_ctl() restores the original user space / host process fpc register value, however it will be discarded, when returning to user space.  In result the host process will incorrectly continue to run with the value that was supposed to be used for a guest cpu.  Fix this by simply removing the test. There is another test right before the SIE context is entered which will handles invalid values.  This results in a change of behaviour: invalid values will now be accepted instead of that the ioctl fails with -EINVAL. This seems to be acceptable, given that this interface is most likely not used anymore, and this is in addition the same behaviour implemented with the memory mapped interface (replace invalid values with zero) - see sync_regs() in kvm-s390.c.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52597",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "openssl",
            "featureversion": "1.1.1w-0+deb11u1",
            "vulnerability": "CVE-2024-0727",
            "namespace": "debian:11",
            "description": "Issue summary: Processing a maliciously formatted PKCS12 file may lead OpenSSL to crash leading to a potential Denial of Service attack  Impact summary: Applications loading files in the PKCS12 format from untrusted sources might terminate abruptly.  A file in PKCS12 format can contain certificates and keys and may come from an untrusted source. The PKCS12 specification allows certain fields to be NULL, but OpenSSL does not correctly check for this case. This can lead to a NULL pointer dereference that results in OpenSSL crashing. If an application processes PKCS12 files from an untrusted source using the OpenSSL APIs then that application will be vulnerable to this issue.  OpenSSL APIs that are vulnerable to this are: PKCS12_parse(), PKCS12_unpack_p7data(), PKCS12_unpack_p7encdata(), PKCS12_unpack_authsafes() and PKCS12_newpass().  We have also fixed a similar issue in SMIME_write_PKCS7(). However since this function is related to writing data we do not consider it security significant.  The FIPS modules in 3.2, 3.1 and 3.0 are not affected by this issue.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-0727",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52569",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: remove BUG() after failure to insert delayed dir index item  Instead of calling BUG() when we fail to insert a delayed dir index item into the delayed node's tree, we can just release all the resources we have allocated/acquired before and return the error to the caller. This is fine because all existing call chains undo anything they have done before calling btrfs_insert_delayed_dir_index() or BUG_ON (when creating pending snapshots in the transaction commit path).  So remove the BUG() call and do proper error handling.  This relates to a syzbot report linked below, but does not fix it because it only prevents hitting a BUG(), it does not fix the issue where somehow we attempt to use twice the same index number for different index items.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52569",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "shadow",
            "featureversion": "1:4.8.1-1",
            "vulnerability": "CVE-2023-29383",
            "namespace": "debian:11",
            "description": "In Shadow 4.13, it is possible to inject control characters into fields provided to the SUID program chfn (change finger). Although it is not possible to exploit this directly (e.g., adding a new user fails because \\n is in the block list), it is possible to misrepresent the /etc/passwd file when viewed. Use of \\r manipulations and Unicode characters to work around blocking of the : character make it possible to give the impression that a new user has been added. In other words, an adversary may be able to convince a system administrator to take the system offline (an indirect, social-engineered denial of service) by demonstrating that \"cat /etc/passwd\" shows a rogue user account.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-29383",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-6240",
            "namespace": "debian:11",
            "description": "A Marvin vulnerability side-channel leakage was found in the RSA decryption operation in the Linux Kernel. This issue may allow a network attacker to decrypt ciphertexts or forge signatures, limiting the services that use that private key.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-6240",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-37454",
            "namespace": "debian:11",
            "description": "An issue was discovered in the Linux kernel through 6.4.2. A crafted UDF filesystem image causes a use-after-free write operation in the udf_put_super and udf_close_lvid functions in fs/udf/super.c. NOTE: the suse.com reference has a different perspective about this.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-37454",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "shadow",
            "featureversion": "1:4.8.1-1",
            "vulnerability": "CVE-2023-4641",
            "namespace": "debian:11",
            "description": "A flaw was found in shadow-utils. When asking for a new password, shadow-utils asks the password twice. If the password fails on the second attempt, shadow-utils fails in cleaning the buffer used to store the first entry. This may allow an attacker with enough access to retrieve the password from the memory.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-4641",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2022-3566",
            "namespace": "debian:11",
            "description": "A vulnerability, which was classified as problematic, was found in Linux Kernel. This affects the function tcp_getsockopt/tcp_setsockopt of the component TCP Handler. The manipulation leads to race condition. It is recommended to apply a patch to fix this issue. The identifier VDB-211089 was assigned to this vulnerability.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-3566",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2023-52488",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  serial: sc16is7xx: convert from _raw_ to _noinc_ regmap functions for FIFO  The SC16IS7XX IC supports a burst mode to access the FIFOs where the initial register address is sent ($00), followed by all the FIFO data without having to resend the register address each time. In this mode, the IC doesn't increment the register address for each R/W byte.  The regmap_raw_read() and regmap_raw_write() are functions which can perform IO over multiple registers. They are currently used to read/write from/to the FIFO, and although they operate correctly in this burst mode on the SPI bus, they would corrupt the regmap cache if it was not disabled manually. The reason is that when the R/W size is more than 1 byte, these functions assume that the register address is incremented and handle the cache accordingly.  Convert FIFO R/W functions to use the regmap _noinc_ versions in order to remove the manual cache control which was a workaround when using the _raw_ versions. FIFO registers are properly declared as volatile so cache will not be used/updated for FIFO accesses.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52488",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-0564",
            "namespace": "debian:11",
            "description": "A flaw was found in the Linux kernel's memory deduplication mechanism. The max page sharing of Kernel Samepage Merging (KSM), added in Linux kernel version 4.4.0-96.119, can create a side channel. When the attacker and the victim share the same host and the default setting of KSM is \"max page sharing=256\", it is possible for the attacker to time the unmap to merge with the victim's page. The unmapping time depends on whether it merges with the victim's page and additional physical pages are created beyond the KSM's \"max page share\". Through these operations, the attacker can leak the victim's page.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-0564",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2024-26629",
            "namespace": "debian:11",
            "description": "In the Linux kernel, the following vulnerability has been resolved:  nfsd: fix RELEASE_LOCKOWNER  The test on so_count in nfsd4_release_lockowner() is nonsense and harmful.  Revert to using check_for_locks(), changing that to not sleep.  First: harmful. As is documented in the kdoc comment for nfsd4_release_lockowner(), the test on so_count can transiently return a false positive resulting in a return of NFS4ERR_LOCKS_HELD when in fact no locks are held.  This is clearly a protocol violation and with the Linux NFS client it can cause incorrect behaviour.  If RELEASE_LOCKOWNER is sent while some other thread is still processing a LOCK request which failed because, at the time that request was received, the given owner held a conflicting lock, then the nfsd thread processing that LOCK request can hold a reference (conflock) to the lock owner that causes nfsd4_release_lockowner() to return an incorrect error.  The Linux NFS client ignores that NFS4ERR_LOCKS_HELD error because it never sends NFS4_RELEASE_LOCKOWNER without first releasing any locks, so it knows that the error is impossible.  It assumes the lock owner was in fact released so it feels free to use the same lock owner identifier in some later locking request.  When it does reuse a lock owner identifier for which a previous RELEASE failed, it will naturally use a lock_seqid of zero.  However the server, which didn't release the lock owner, will expect a larger lock_seqid and so will respond with NFS4ERR_BAD_SEQID.  So clearly it is harmful to allow a false positive, which testing so_count allows.  The test is nonsense because ... well... it doesn't mean anything.  so_count is the sum of three different counts. 1/ the set of states listed on so_stateids 2/ the set of active vfs locks owned by any of those states 3/ various transient counts such as for conflicting locks.  When it is tested against '2' it is clear that one of these is the transient reference obtained by find_lockowner_str_locked().  It is not clear what the other one is expected to be.  In practice, the count is often 2 because there is precisely one state on so_stateids.  If there were more, this would fail.  In my testing I see two circumstances when RELEASE_LOCKOWNER is called. In one case, CLOSE is called before RELEASE_LOCKOWNER.  That results in all the lock states being removed, and so the lockowner being discarded (it is removed when there are no more references which usually happens when the lock state is discarded).  When nfsd4_release_lockowner() finds that the lock owner doesn't exist, it returns success.  The other case shows an so_count of '2' and precisely one state listed in so_stateid.  It appears that the Linux client uses a separate lock owner for each file resulting in one lock state per lock owner, so this test on '2' is safe.  For another client it might not be safe.  So this patch changes check_for_locks() to use the (newish) find_any_file_locked() so that it doesn't take a reference on the nfs4_file and so never calls nfsd_file_put(), and so never sleeps.  With this check is it safe to restore the use of check_for_locks() rather than testing so_count against the mysterious '2'.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-26629",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "expat",
            "featureversion": "2.2.10-2+deb11u5",
            "vulnerability": "CVE-2023-52425",
            "namespace": "debian:11",
            "description": "libexpat through 2.5.0 allows a denial of service (resource consumption) because many full reparsings are required in the case of a large token for which multiple buffer fills are needed.",
            "link": "https://security-tracker.debian.org/tracker/CVE-2023-52425",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "expat",
            "featureversion": "2.2.10-2+deb11u5",
            "vulnerability": "CVE-2024-28757",
            "namespace": "debian:11",
            "description": "libexpat through 2.6.1 allows an XML Entity Expansion attack when there is isolated use of external parsers (created via XML_ExternalEntityParserCreate).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2024-28757",
            "severity": "Unknown",
            "fixedby": ""
        },
        {
            "featurename": "linux",
            "featureversion": "5.10.209-2",
            "vulnerability": "CVE-2022-3344",
            "namespace": "debian:11",
            "description": "A flaw was found in the KVM's AMD nested virtualization (SVM). A malicious L1 guest could purposely fail to intercept the shutdown of a cooperative nested guest (L2), possibly leading to a page fault and kernel panic in the host (L0).",
            "link": "https://security-tracker.debian.org/tracker/CVE-2022-3344",
            "severity": "Unknown",
            "fixedby": ""
        }
    ]
}